// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX___SCHEMAS_NEURO_ML2_NEURO_ML_V2BETA3_H
#define CXX___SCHEMAS_NEURO_ML2_NEURO_ML_V2BETA3_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace neurona
{
  namespace schema
  {
    class NmlId;
    class Nml2Quantity;
    class Nml2Quantity_none;
    class Nml2Quantity_voltage;
    class Nml2Quantity_length;
    class Nml2Quantity_resistance;
    class Nml2Quantity_conductance;
    class Nml2Quantity_conductanceDensity;
    class Nml2Quantity_permeability;
    class Nml2Quantity_time;
    class Nml2Quantity_pertime;
    class Nml2Quantity_capacitance;
    class Nml2Quantity_specificCapacitance;
    class Nml2Quantity_concentration;
    class Nml2Quantity_current;
    class Nml2Quantity_temperature;
    class Nml2Quantity_rhoFactor;
    class MetaId;
    class NeuroLexId;
    class SegmentId;
    class Notes;
    class Property;
    class Annotation;
    class ComponentType;
    class ZeroToOne;
    class BaseWithoutId;
    class Base;
    class Standalone;
    class NeuroMLDocument;
    class IncludeType;
    class IonChannel;
    class IonChannelHH;
    class ChannelTypes;
    class GateTypes;
    class GateHHUndetermined;
    class GateHHRates;
    class GateHHTauInf;
    class GateHHRatesTauInf;
    class GateHHRatesTau;
    class GateHHRatesInf;
    class Q10Settings;
    class HHRate;
    class HHVariable;
    class HHTime;
    class DecayingPoolConcentrationModel;
    class FixedFactorConcentrationModel;
    class BaseSynapse;
    class BaseConductanceBasedSynapse;
    class ExpOneSynapse;
    class ExpTwoSynapse;
    class BlockingPlasticSynapse;
    class BlockTypes;
    class BlockMechanism;
    class PlasticityTypes;
    class PlasticityMechanism;
    class BaseCell;
    class IafTauCell;
    class IafTauRefCell;
    class IafCell;
    class IafRefCell;
    class IzhikevichCell;
    class AdExIaFCell;
    class FitzHughNagumoCell;
    class Cell;
    class Morphology;
    class Segment;
    class SegmentParent;
    class Point3DWithDiam;
    class SegmentGroup;
    class InhomogeneousParameter;
    class Metric;
    class ProximalDetails;
    class DistalDetails;
    class Member;
    class Include;
    class Path;
    class SubTree;
    class SegmentEndPoint;
    class BiophysicalProperties;
    class MembraneProperties;
    class ValueAcrossSegOrSegGroup;
    class SpikeThresh;
    class SpecificCapacitance;
    class InitMembPotential;
    class Resistivity;
    class ChannelPopulation;
    class ChannelDensityNonUniform;
    class ChannelDensityNonUniformNernst;
    class ChannelDensity;
    class ChannelDensityNernst;
    class ChannelDensityGHK;
    class VariableParameter;
    class InhomogeneousValue;
    class Species;
    class ConcentrationModel_D;
    class IntracellularProperties;
    class ExtracellularProperties;
    class ExtracellularPropertiesLocal;
    class ReactionScheme;
    class PulseGenerator;
    class SineGenerator;
    class RampGenerator;
    class VoltageClamp;
    class Spike;
    class SpikeArray;
    class SpikeGenerator;
    class SpikeGeneratorRandom;
    class SpikeGeneratorPoisson;
    class Network;
    class NetworkTypes;
    class Space;
    class SpaceStructure;
    class AllowedSpaces;
    class Region;
    class Population;
    class PopulationTypes;
    class Layout;
    class UnstructuredLayout;
    class RandomLayout;
    class GridLayout;
    class Instance;
    class Location;
    class CellSet;
    class SynapticConnection;
    class Projection;
    class Connection;
    class ExplicitInput;
    class InputList;
    class Input;
    class BasePyNNCell;
    class BasePyNNIaFCell;
    class BasePyNNIaFCondCell;
    class IF_curr_alpha;
    class IF_curr_exp;
    class IF_cond_alpha;
    class IF_cond_exp;
    class EIF_cond_exp_isfa_ista;
    class EIF_cond_alpha_isfa_ista;
    class HH_cond_exp;
    class BasePynnSynapse;
    class ExpCondSynapse;
    class AlphaCondSynapse;
    class ExpCurrSynapse;
    class AlphaCurrSynapse;
    class SpikeSourcePoisson;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace neurona
{
  namespace schema
  {
    class NmlId: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      NmlId ();

      NmlId (const char*);

      NmlId (const ::std::string&);

      NmlId (const ::xml_schema::String&);

      NmlId (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      NmlId (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      NmlId (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      NmlId (const NmlId& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual NmlId*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~NmlId ();
    };

    class Nml2Quantity: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity ();

      Nml2Quantity (const char*);

      Nml2Quantity (const ::std::string&);

      Nml2Quantity (const ::xml_schema::String&);

      Nml2Quantity (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      Nml2Quantity (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      Nml2Quantity (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      Nml2Quantity (const Nml2Quantity& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual Nml2Quantity*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity ();
    };

    class Nml2Quantity_none: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_none ();

      Nml2Quantity_none (const char*);

      Nml2Quantity_none (const ::std::string&);

      Nml2Quantity_none (const ::xml_schema::String&);

      Nml2Quantity_none (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      Nml2Quantity_none (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      Nml2Quantity_none (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      Nml2Quantity_none (const Nml2Quantity_none& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_none*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_none ();
    };

    class Nml2Quantity_voltage: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_voltage ();

      Nml2Quantity_voltage (const char*);

      Nml2Quantity_voltage (const ::std::string&);

      Nml2Quantity_voltage (const ::xml_schema::String&);

      Nml2Quantity_voltage (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_voltage (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_voltage (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_voltage (const Nml2Quantity_voltage& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_voltage*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_voltage ();
    };

    class Nml2Quantity_length: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_length ();

      Nml2Quantity_length (const char*);

      Nml2Quantity_length (const ::std::string&);

      Nml2Quantity_length (const ::xml_schema::String&);

      Nml2Quantity_length (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      Nml2Quantity_length (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      Nml2Quantity_length (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      Nml2Quantity_length (const Nml2Quantity_length& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_length*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_length ();
    };

    class Nml2Quantity_resistance: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_resistance ();

      Nml2Quantity_resistance (const char*);

      Nml2Quantity_resistance (const ::std::string&);

      Nml2Quantity_resistance (const ::xml_schema::String&);

      Nml2Quantity_resistance (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      Nml2Quantity_resistance (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      Nml2Quantity_resistance (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      Nml2Quantity_resistance (const Nml2Quantity_resistance& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_resistance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_resistance ();
    };

    class Nml2Quantity_conductance: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_conductance ();

      Nml2Quantity_conductance (const char*);

      Nml2Quantity_conductance (const ::std::string&);

      Nml2Quantity_conductance (const ::xml_schema::String&);

      Nml2Quantity_conductance (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_conductance (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_conductance (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_conductance (const Nml2Quantity_conductance& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_conductance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_conductance ();
    };

    class Nml2Quantity_conductanceDensity: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_conductanceDensity ();

      Nml2Quantity_conductanceDensity (const char*);

      Nml2Quantity_conductanceDensity (const ::std::string&);

      Nml2Quantity_conductanceDensity (const ::xml_schema::String&);

      Nml2Quantity_conductanceDensity (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      Nml2Quantity_conductanceDensity (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      Nml2Quantity_conductanceDensity (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      Nml2Quantity_conductanceDensity (const Nml2Quantity_conductanceDensity& x,
                                       ::xml_schema::Flags f = 0,
                                       ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_conductanceDensity*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_conductanceDensity ();
    };

    class Nml2Quantity_permeability: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_permeability ();

      Nml2Quantity_permeability (const char*);

      Nml2Quantity_permeability (const ::std::string&);

      Nml2Quantity_permeability (const ::xml_schema::String&);

      Nml2Quantity_permeability (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      Nml2Quantity_permeability (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      Nml2Quantity_permeability (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      Nml2Quantity_permeability (const Nml2Quantity_permeability& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_permeability*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_permeability ();
    };

    class Nml2Quantity_time: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_time ();

      Nml2Quantity_time (const char*);

      Nml2Quantity_time (const ::std::string&);

      Nml2Quantity_time (const ::xml_schema::String&);

      Nml2Quantity_time (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      Nml2Quantity_time (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      Nml2Quantity_time (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      Nml2Quantity_time (const Nml2Quantity_time& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_time*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_time ();
    };

    class Nml2Quantity_pertime: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_pertime ();

      Nml2Quantity_pertime (const char*);

      Nml2Quantity_pertime (const ::std::string&);

      Nml2Quantity_pertime (const ::xml_schema::String&);

      Nml2Quantity_pertime (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_pertime (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_pertime (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_pertime (const Nml2Quantity_pertime& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_pertime*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_pertime ();
    };

    class Nml2Quantity_capacitance: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_capacitance ();

      Nml2Quantity_capacitance (const char*);

      Nml2Quantity_capacitance (const ::std::string&);

      Nml2Quantity_capacitance (const ::xml_schema::String&);

      Nml2Quantity_capacitance (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_capacitance (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_capacitance (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_capacitance (const Nml2Quantity_capacitance& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_capacitance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_capacitance ();
    };

    class Nml2Quantity_specificCapacitance: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_specificCapacitance ();

      Nml2Quantity_specificCapacitance (const char*);

      Nml2Quantity_specificCapacitance (const ::std::string&);

      Nml2Quantity_specificCapacitance (const ::xml_schema::String&);

      Nml2Quantity_specificCapacitance (const ::xercesc::DOMElement& e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

      Nml2Quantity_specificCapacitance (const ::xercesc::DOMAttr& a,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

      Nml2Quantity_specificCapacitance (const ::std::string& s,
                                        const ::xercesc::DOMElement* e,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

      Nml2Quantity_specificCapacitance (const Nml2Quantity_specificCapacitance& x,
                                        ::xml_schema::Flags f = 0,
                                        ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_specificCapacitance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_specificCapacitance ();
    };

    class Nml2Quantity_concentration: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_concentration ();

      Nml2Quantity_concentration (const char*);

      Nml2Quantity_concentration (const ::std::string&);

      Nml2Quantity_concentration (const ::xml_schema::String&);

      Nml2Quantity_concentration (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      Nml2Quantity_concentration (const ::xercesc::DOMAttr& a,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      Nml2Quantity_concentration (const ::std::string& s,
                                  const ::xercesc::DOMElement* e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      Nml2Quantity_concentration (const Nml2Quantity_concentration& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_concentration*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_concentration ();
    };

    class Nml2Quantity_current: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_current ();

      Nml2Quantity_current (const char*);

      Nml2Quantity_current (const ::std::string&);

      Nml2Quantity_current (const ::xml_schema::String&);

      Nml2Quantity_current (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_current (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_current (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      Nml2Quantity_current (const Nml2Quantity_current& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_current*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_current ();
    };

    class Nml2Quantity_temperature: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_temperature ();

      Nml2Quantity_temperature (const char*);

      Nml2Quantity_temperature (const ::std::string&);

      Nml2Quantity_temperature (const ::xml_schema::String&);

      Nml2Quantity_temperature (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_temperature (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_temperature (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      Nml2Quantity_temperature (const Nml2Quantity_temperature& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_temperature*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_temperature ();
    };

    class Nml2Quantity_rhoFactor: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Nml2Quantity_rhoFactor ();

      Nml2Quantity_rhoFactor (const char*);

      Nml2Quantity_rhoFactor (const ::std::string&);

      Nml2Quantity_rhoFactor (const ::xml_schema::String&);

      Nml2Quantity_rhoFactor (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      Nml2Quantity_rhoFactor (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      Nml2Quantity_rhoFactor (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      Nml2Quantity_rhoFactor (const Nml2Quantity_rhoFactor& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      virtual Nml2Quantity_rhoFactor*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Nml2Quantity_rhoFactor ();
    };

    class MetaId: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      MetaId ();

      MetaId (const char*);

      MetaId (const ::std::string&);

      MetaId (const ::xml_schema::String&);

      MetaId (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      MetaId (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      MetaId (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      MetaId (const MetaId& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual MetaId*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~MetaId ();
    };

    class NeuroLexId: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      NeuroLexId ();

      NeuroLexId (const char*);

      NeuroLexId (const ::std::string&);

      NeuroLexId (const ::xml_schema::String&);

      NeuroLexId (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      NeuroLexId (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      NeuroLexId (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      NeuroLexId (const NeuroLexId& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual NeuroLexId*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~NeuroLexId ();
    };

    class SegmentId: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType >
    {
      public:
      // Constructors.
      //
      SegmentId (const ::xml_schema::NonNegativeInteger&);

      SegmentId (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      SegmentId (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      SegmentId (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      SegmentId (const SegmentId& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      virtual SegmentId*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~SegmentId ();
    };

    class Notes: public ::xml_schema::String
    {
      public:
      // Constructors.
      //
      Notes ();

      Notes (const char*);

      Notes (const ::std::string&);

      Notes (const ::xml_schema::String&);

      Notes (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      Notes (const ::xercesc::DOMAttr& a,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      Notes (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      Notes (const Notes& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual Notes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Notes ();
    };

    class Property: public ::xml_schema::Type
    {
      public:
      // tag
      //
      typedef ::xml_schema::String TagType;
      typedef ::xsd::cxx::tree::traits< TagType, char > TagTraits;

      const TagType&
      tag () const;

      TagType&
      tag ();

      void
      setTag (const TagType& x);

      void
      setTag (::std::unique_ptr< TagType > p);

      // value
      //
      typedef ::xml_schema::String ValueType;
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      const ValueType&
      value () const;

      ValueType&
      value ();

      void
      setValue (const ValueType& x);

      void
      setValue (::std::unique_ptr< ValueType > p);

      // Constructors.
      //
      Property (const TagType&,
                const ValueType&);

      Property (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      Property (const Property& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual Property*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Property&
      operator= (const Property& x);

      virtual 
      ~Property ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TagType > tag_;
      ::xsd::cxx::tree::one< ValueType > value_;
    };

    class Annotation: public ::xml_schema::Type
    {
      public:
      // Constructors.
      //
      Annotation ();

      Annotation (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      Annotation (const Annotation& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual Annotation*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Annotation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
    };

    class ComponentType: public ::xml_schema::Type
    {
      public:
      // name
      //
      typedef ::xml_schema::String NameType;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameType&
      name () const;

      NameType&
      name ();

      void
      setName (const NameType& x);

      void
      setName (::std::unique_ptr< NameType > p);

      // extends
      //
      typedef ::xml_schema::String ExtendsType;
      typedef ::xsd::cxx::tree::optional< ExtendsType > ExtendsOptional;
      typedef ::xsd::cxx::tree::traits< ExtendsType, char > ExtendsTraits;

      const ExtendsOptional&
      extends () const;

      ExtendsOptional&
      extends ();

      void
      setExtends (const ExtendsType& x);

      void
      setExtends (const ExtendsOptional& x);

      void
      setExtends (::std::unique_ptr< ExtendsType > p);

      // description
      //
      typedef ::xml_schema::String DescriptionType;
      typedef ::xsd::cxx::tree::optional< DescriptionType > DescriptionOptional;
      typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

      const DescriptionOptional&
      description () const;

      DescriptionOptional&
      description ();

      void
      setDescription (const DescriptionType& x);

      void
      setDescription (const DescriptionOptional& x);

      void
      setDescription (::std::unique_ptr< DescriptionType > p);

      // Constructors.
      //
      ComponentType (const NameType&);

      ComponentType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      ComponentType (const ComponentType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual ComponentType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ComponentType&
      operator= (const ComponentType& x);

      virtual 
      ~ComponentType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NameType > name_;
      ExtendsOptional extends_;
      DescriptionOptional description_;
    };

    class ZeroToOne: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      // Constructors.
      //
      ZeroToOne (const ::xml_schema::Double&);

      ZeroToOne (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      ZeroToOne (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      ZeroToOne (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      ZeroToOne (const ZeroToOne& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      virtual ZeroToOne*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~ZeroToOne ();
    };

    class BaseWithoutId: public ::xml_schema::Type
    {
      public:
      // neuroLexId
      //
      typedef ::neurona::schema::NeuroLexId NeuroLexIdType;
      typedef ::xsd::cxx::tree::optional< NeuroLexIdType > NeuroLexIdOptional;
      typedef ::xsd::cxx::tree::traits< NeuroLexIdType, char > NeuroLexIdTraits;

      const NeuroLexIdOptional&
      neuroLexId () const;

      NeuroLexIdOptional&
      neuroLexId ();

      void
      setNeuroLexId (const NeuroLexIdType& x);

      void
      setNeuroLexId (const NeuroLexIdOptional& x);

      void
      setNeuroLexId (::std::unique_ptr< NeuroLexIdType > p);

      // Constructors.
      //
      BaseWithoutId ();

      BaseWithoutId (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      BaseWithoutId (const BaseWithoutId& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual BaseWithoutId*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BaseWithoutId&
      operator= (const BaseWithoutId& x);

      virtual 
      ~BaseWithoutId ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NeuroLexIdOptional neuroLexId_;
    };

    class Base: public ::neurona::schema::BaseWithoutId
    {
      public:
      // id
      //
      typedef ::neurona::schema::NmlId IdType;
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      const IdType&
      id () const;

      IdType&
      id ();

      void
      setId (const IdType& x);

      void
      setId (::std::unique_ptr< IdType > p);

      // Constructors.
      //
      Base (const IdType&);

      Base (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      Base (const Base& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      virtual Base*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Base&
      operator= (const Base& x);

      virtual 
      ~Base ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
    };

    class Standalone: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // annotation
      //
      typedef ::neurona::schema::Annotation AnnotationType;
      typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
      typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

      const AnnotationOptional&
      annotation () const;

      AnnotationOptional&
      annotation ();

      void
      setAnnotation (const AnnotationType& x);

      void
      setAnnotation (const AnnotationOptional& x);

      void
      setAnnotation (::std::unique_ptr< AnnotationType > p);

      // metaid
      //
      typedef ::neurona::schema::MetaId MetaidType;
      typedef ::xsd::cxx::tree::optional< MetaidType > MetaidOptional;
      typedef ::xsd::cxx::tree::traits< MetaidType, char > MetaidTraits;

      const MetaidOptional&
      metaid () const;

      MetaidOptional&
      metaid ();

      void
      setMetaid (const MetaidType& x);

      void
      setMetaid (const MetaidOptional& x);

      void
      setMetaid (::std::unique_ptr< MetaidType > p);

      // Constructors.
      //
      Standalone (const IdType&);

      Standalone (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      Standalone (const Standalone& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual Standalone*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Standalone&
      operator= (const Standalone& x);

      virtual 
      ~Standalone ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      AnnotationOptional annotation_;
      MetaidOptional metaid_;
    };

    class NeuroMLDocument: public ::neurona::schema::Standalone
    {
      public:
      // include
      //
      typedef ::neurona::schema::IncludeType IncludeType;
      typedef ::xsd::cxx::tree::sequence< IncludeType > IncludeSequence;
      typedef IncludeSequence::iterator IncludeIterator;
      typedef IncludeSequence::const_iterator IncludeConstIterator;
      typedef ::xsd::cxx::tree::traits< IncludeType, char > IncludeTraits;

      const IncludeSequence&
      includes () const;

      IncludeSequence&
      includes ();

      void
      setIncludes (const IncludeSequence& s);

      // extracellularProperties
      //
      typedef ::neurona::schema::ExtracellularProperties ExtracellularPropertiesType;
      typedef ::xsd::cxx::tree::sequence< ExtracellularPropertiesType > ExtracellularPropertiesSequence;
      typedef ExtracellularPropertiesSequence::iterator ExtracellularPropertiesIterator;
      typedef ExtracellularPropertiesSequence::const_iterator ExtracellularPropertiesConstIterator;
      typedef ::xsd::cxx::tree::traits< ExtracellularPropertiesType, char > ExtracellularPropertiesTraits;

      const ExtracellularPropertiesSequence&
      extracellularPropertiess () const;

      ExtracellularPropertiesSequence&
      extracellularPropertiess ();

      void
      setExtracellularPropertiess (const ExtracellularPropertiesSequence& s);

      // intracellularProperties
      //
      typedef ::neurona::schema::IntracellularProperties IntracellularPropertiesType;
      typedef ::xsd::cxx::tree::sequence< IntracellularPropertiesType > IntracellularPropertiesSequence;
      typedef IntracellularPropertiesSequence::iterator IntracellularPropertiesIterator;
      typedef IntracellularPropertiesSequence::const_iterator IntracellularPropertiesConstIterator;
      typedef ::xsd::cxx::tree::traits< IntracellularPropertiesType, char > IntracellularPropertiesTraits;

      const IntracellularPropertiesSequence&
      intracellularPropertiess () const;

      IntracellularPropertiesSequence&
      intracellularPropertiess ();

      void
      setIntracellularPropertiess (const IntracellularPropertiesSequence& s);

      // morphology
      //
      typedef ::neurona::schema::Morphology MorphologyType;
      typedef ::xsd::cxx::tree::sequence< MorphologyType > MorphologySequence;
      typedef MorphologySequence::iterator MorphologyIterator;
      typedef MorphologySequence::const_iterator MorphologyConstIterator;
      typedef ::xsd::cxx::tree::traits< MorphologyType, char > MorphologyTraits;

      const MorphologySequence&
      morphologys () const;

      MorphologySequence&
      morphologys ();

      void
      setMorphologys (const MorphologySequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::IonChannel IonChannelType;
      typedef ::xsd::cxx::tree::sequence< IonChannelType > IonChannelSequence;
      typedef IonChannelSequence::iterator IonChannelIterator;
      typedef IonChannelSequence::const_iterator IonChannelConstIterator;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelSequence&
      ionChannels () const;

      IonChannelSequence&
      ionChannels ();

      void
      setIonChannels (const IonChannelSequence& s);

      // ionChannelHH
      //
      typedef ::neurona::schema::IonChannelHH IonChannelHHType;
      typedef ::xsd::cxx::tree::sequence< IonChannelHHType > IonChannelHHSequence;
      typedef IonChannelHHSequence::iterator IonChannelHHIterator;
      typedef IonChannelHHSequence::const_iterator IonChannelHHConstIterator;
      typedef ::xsd::cxx::tree::traits< IonChannelHHType, char > IonChannelHHTraits;

      const IonChannelHHSequence&
      ionChannelHHs () const;

      IonChannelHHSequence&
      ionChannelHHs ();

      void
      setIonChannelHHs (const IonChannelHHSequence& s);

      // decayingPoolConcentrationModel
      //
      typedef ::neurona::schema::DecayingPoolConcentrationModel DecayingPoolConcentrationModelType;
      typedef ::xsd::cxx::tree::sequence< DecayingPoolConcentrationModelType > DecayingPoolConcentrationModelSequence;
      typedef DecayingPoolConcentrationModelSequence::iterator DecayingPoolConcentrationModelIterator;
      typedef DecayingPoolConcentrationModelSequence::const_iterator DecayingPoolConcentrationModelConstIterator;
      typedef ::xsd::cxx::tree::traits< DecayingPoolConcentrationModelType, char > DecayingPoolConcentrationModelTraits;

      const DecayingPoolConcentrationModelSequence&
      decayingPoolConcentrationModels () const;

      DecayingPoolConcentrationModelSequence&
      decayingPoolConcentrationModels ();

      void
      setDecayingPoolConcentrationModels (const DecayingPoolConcentrationModelSequence& s);

      // fixedFactorConcentrationModel
      //
      typedef ::neurona::schema::FixedFactorConcentrationModel FixedFactorConcentrationModelType;
      typedef ::xsd::cxx::tree::sequence< FixedFactorConcentrationModelType > FixedFactorConcentrationModelSequence;
      typedef FixedFactorConcentrationModelSequence::iterator FixedFactorConcentrationModelIterator;
      typedef FixedFactorConcentrationModelSequence::const_iterator FixedFactorConcentrationModelConstIterator;
      typedef ::xsd::cxx::tree::traits< FixedFactorConcentrationModelType, char > FixedFactorConcentrationModelTraits;

      const FixedFactorConcentrationModelSequence&
      fixedFactorConcentrationModels () const;

      FixedFactorConcentrationModelSequence&
      fixedFactorConcentrationModels ();

      void
      setFixedFactorConcentrationModels (const FixedFactorConcentrationModelSequence& s);

      // expOneSynapse
      //
      typedef ::neurona::schema::ExpOneSynapse ExpOneSynapseType;
      typedef ::xsd::cxx::tree::sequence< ExpOneSynapseType > ExpOneSynapseSequence;
      typedef ExpOneSynapseSequence::iterator ExpOneSynapseIterator;
      typedef ExpOneSynapseSequence::const_iterator ExpOneSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< ExpOneSynapseType, char > ExpOneSynapseTraits;

      const ExpOneSynapseSequence&
      expOneSynapses () const;

      ExpOneSynapseSequence&
      expOneSynapses ();

      void
      setExpOneSynapses (const ExpOneSynapseSequence& s);

      // expTwoSynapse
      //
      typedef ::neurona::schema::ExpTwoSynapse ExpTwoSynapseType;
      typedef ::xsd::cxx::tree::sequence< ExpTwoSynapseType > ExpTwoSynapseSequence;
      typedef ExpTwoSynapseSequence::iterator ExpTwoSynapseIterator;
      typedef ExpTwoSynapseSequence::const_iterator ExpTwoSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< ExpTwoSynapseType, char > ExpTwoSynapseTraits;

      const ExpTwoSynapseSequence&
      expTwoSynapses () const;

      ExpTwoSynapseSequence&
      expTwoSynapses ();

      void
      setExpTwoSynapses (const ExpTwoSynapseSequence& s);

      // blockingPlasticSynapse
      //
      typedef ::neurona::schema::BlockingPlasticSynapse BlockingPlasticSynapseType;
      typedef ::xsd::cxx::tree::sequence< BlockingPlasticSynapseType > BlockingPlasticSynapseSequence;
      typedef BlockingPlasticSynapseSequence::iterator BlockingPlasticSynapseIterator;
      typedef BlockingPlasticSynapseSequence::const_iterator BlockingPlasticSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< BlockingPlasticSynapseType, char > BlockingPlasticSynapseTraits;

      const BlockingPlasticSynapseSequence&
      blockingPlasticSynapses () const;

      BlockingPlasticSynapseSequence&
      blockingPlasticSynapses ();

      void
      setBlockingPlasticSynapses (const BlockingPlasticSynapseSequence& s);

      // biophysicalProperties
      //
      typedef ::neurona::schema::BiophysicalProperties BiophysicalPropertiesType;
      typedef ::xsd::cxx::tree::sequence< BiophysicalPropertiesType > BiophysicalPropertiesSequence;
      typedef BiophysicalPropertiesSequence::iterator BiophysicalPropertiesIterator;
      typedef BiophysicalPropertiesSequence::const_iterator BiophysicalPropertiesConstIterator;
      typedef ::xsd::cxx::tree::traits< BiophysicalPropertiesType, char > BiophysicalPropertiesTraits;

      const BiophysicalPropertiesSequence&
      biophysicalPropertiess () const;

      BiophysicalPropertiesSequence&
      biophysicalPropertiess ();

      void
      setBiophysicalPropertiess (const BiophysicalPropertiesSequence& s);

      // cell
      //
      typedef ::neurona::schema::Cell CellType;
      typedef ::xsd::cxx::tree::sequence< CellType > CellSequence;
      typedef CellSequence::iterator CellIterator;
      typedef CellSequence::const_iterator CellConstIterator;
      typedef ::xsd::cxx::tree::traits< CellType, char > CellTraits;

      const CellSequence&
      cells () const;

      CellSequence&
      cells ();

      void
      setCells (const CellSequence& s);

      // baseCell
      //
      typedef ::neurona::schema::BaseCell BaseCellType;
      typedef ::xsd::cxx::tree::sequence< BaseCellType > BaseCellSequence;
      typedef BaseCellSequence::iterator BaseCellIterator;
      typedef BaseCellSequence::const_iterator BaseCellConstIterator;
      typedef ::xsd::cxx::tree::traits< BaseCellType, char > BaseCellTraits;

      const BaseCellSequence&
      baseCells () const;

      BaseCellSequence&
      baseCells ();

      void
      setBaseCells (const BaseCellSequence& s);

      // iafTauCell
      //
      typedef ::neurona::schema::IafTauCell IafTauCellType;
      typedef ::xsd::cxx::tree::sequence< IafTauCellType > IafTauCellSequence;
      typedef IafTauCellSequence::iterator IafTauCellIterator;
      typedef IafTauCellSequence::const_iterator IafTauCellConstIterator;
      typedef ::xsd::cxx::tree::traits< IafTauCellType, char > IafTauCellTraits;

      const IafTauCellSequence&
      iafTauCells () const;

      IafTauCellSequence&
      iafTauCells ();

      void
      setIafTauCells (const IafTauCellSequence& s);

      // iafTauRefCell
      //
      typedef ::neurona::schema::IafTauRefCell IafTauRefCellType;
      typedef ::xsd::cxx::tree::sequence< IafTauRefCellType > IafTauRefCellSequence;
      typedef IafTauRefCellSequence::iterator IafTauRefCellIterator;
      typedef IafTauRefCellSequence::const_iterator IafTauRefCellConstIterator;
      typedef ::xsd::cxx::tree::traits< IafTauRefCellType, char > IafTauRefCellTraits;

      const IafTauRefCellSequence&
      iafTauRefCells () const;

      IafTauRefCellSequence&
      iafTauRefCells ();

      void
      setIafTauRefCells (const IafTauRefCellSequence& s);

      // iafCell
      //
      typedef ::neurona::schema::IafCell IafCellType;
      typedef ::xsd::cxx::tree::sequence< IafCellType > IafCellSequence;
      typedef IafCellSequence::iterator IafCellIterator;
      typedef IafCellSequence::const_iterator IafCellConstIterator;
      typedef ::xsd::cxx::tree::traits< IafCellType, char > IafCellTraits;

      const IafCellSequence&
      iafCells () const;

      IafCellSequence&
      iafCells ();

      void
      setIafCells (const IafCellSequence& s);

      // iafRefCell
      //
      typedef ::neurona::schema::IafRefCell IafRefCellType;
      typedef ::xsd::cxx::tree::sequence< IafRefCellType > IafRefCellSequence;
      typedef IafRefCellSequence::iterator IafRefCellIterator;
      typedef IafRefCellSequence::const_iterator IafRefCellConstIterator;
      typedef ::xsd::cxx::tree::traits< IafRefCellType, char > IafRefCellTraits;

      const IafRefCellSequence&
      iafRefCells () const;

      IafRefCellSequence&
      iafRefCells ();

      void
      setIafRefCells (const IafRefCellSequence& s);

      // izhikevichCell
      //
      typedef ::neurona::schema::IzhikevichCell IzhikevichCellType;
      typedef ::xsd::cxx::tree::sequence< IzhikevichCellType > IzhikevichCellSequence;
      typedef IzhikevichCellSequence::iterator IzhikevichCellIterator;
      typedef IzhikevichCellSequence::const_iterator IzhikevichCellConstIterator;
      typedef ::xsd::cxx::tree::traits< IzhikevichCellType, char > IzhikevichCellTraits;

      const IzhikevichCellSequence&
      izhikevichCells () const;

      IzhikevichCellSequence&
      izhikevichCells ();

      void
      setIzhikevichCells (const IzhikevichCellSequence& s);

      // adExIaFCell
      //
      typedef ::neurona::schema::AdExIaFCell AdExIaFCellType;
      typedef ::xsd::cxx::tree::sequence< AdExIaFCellType > AdExIaFCellSequence;
      typedef AdExIaFCellSequence::iterator AdExIaFCellIterator;
      typedef AdExIaFCellSequence::const_iterator AdExIaFCellConstIterator;
      typedef ::xsd::cxx::tree::traits< AdExIaFCellType, char > AdExIaFCellTraits;

      const AdExIaFCellSequence&
      adExIaFCells () const;

      AdExIaFCellSequence&
      adExIaFCells ();

      void
      setAdExIaFCells (const AdExIaFCellSequence& s);

      // fitzHughNagumoCell
      //
      typedef ::neurona::schema::FitzHughNagumoCell FitzHughNagumoCellType;
      typedef ::xsd::cxx::tree::sequence< FitzHughNagumoCellType > FitzHughNagumoCellSequence;
      typedef FitzHughNagumoCellSequence::iterator FitzHughNagumoCellIterator;
      typedef FitzHughNagumoCellSequence::const_iterator FitzHughNagumoCellConstIterator;
      typedef ::xsd::cxx::tree::traits< FitzHughNagumoCellType, char > FitzHughNagumoCellTraits;

      const FitzHughNagumoCellSequence&
      fitzHughNagumoCells () const;

      FitzHughNagumoCellSequence&
      fitzHughNagumoCells ();

      void
      setFitzHughNagumoCells (const FitzHughNagumoCellSequence& s);

      // pulseGenerator
      //
      typedef ::neurona::schema::PulseGenerator PulseGeneratorType;
      typedef ::xsd::cxx::tree::sequence< PulseGeneratorType > PulseGeneratorSequence;
      typedef PulseGeneratorSequence::iterator PulseGeneratorIterator;
      typedef PulseGeneratorSequence::const_iterator PulseGeneratorConstIterator;
      typedef ::xsd::cxx::tree::traits< PulseGeneratorType, char > PulseGeneratorTraits;

      const PulseGeneratorSequence&
      pulseGenerators () const;

      PulseGeneratorSequence&
      pulseGenerators ();

      void
      setPulseGenerators (const PulseGeneratorSequence& s);

      // sineGenerator
      //
      typedef ::neurona::schema::SineGenerator SineGeneratorType;
      typedef ::xsd::cxx::tree::sequence< SineGeneratorType > SineGeneratorSequence;
      typedef SineGeneratorSequence::iterator SineGeneratorIterator;
      typedef SineGeneratorSequence::const_iterator SineGeneratorConstIterator;
      typedef ::xsd::cxx::tree::traits< SineGeneratorType, char > SineGeneratorTraits;

      const SineGeneratorSequence&
      sineGenerators () const;

      SineGeneratorSequence&
      sineGenerators ();

      void
      setSineGenerators (const SineGeneratorSequence& s);

      // rampGenerator
      //
      typedef ::neurona::schema::RampGenerator RampGeneratorType;
      typedef ::xsd::cxx::tree::sequence< RampGeneratorType > RampGeneratorSequence;
      typedef RampGeneratorSequence::iterator RampGeneratorIterator;
      typedef RampGeneratorSequence::const_iterator RampGeneratorConstIterator;
      typedef ::xsd::cxx::tree::traits< RampGeneratorType, char > RampGeneratorTraits;

      const RampGeneratorSequence&
      rampGenerators () const;

      RampGeneratorSequence&
      rampGenerators ();

      void
      setRampGenerators (const RampGeneratorSequence& s);

      // voltageClamp
      //
      typedef ::neurona::schema::VoltageClamp VoltageClampType;
      typedef ::xsd::cxx::tree::sequence< VoltageClampType > VoltageClampSequence;
      typedef VoltageClampSequence::iterator VoltageClampIterator;
      typedef VoltageClampSequence::const_iterator VoltageClampConstIterator;
      typedef ::xsd::cxx::tree::traits< VoltageClampType, char > VoltageClampTraits;

      const VoltageClampSequence&
      voltageClamps () const;

      VoltageClampSequence&
      voltageClamps ();

      void
      setVoltageClamps (const VoltageClampSequence& s);

      // spikeArray
      //
      typedef ::neurona::schema::SpikeArray SpikeArrayType;
      typedef ::xsd::cxx::tree::sequence< SpikeArrayType > SpikeArraySequence;
      typedef SpikeArraySequence::iterator SpikeArrayIterator;
      typedef SpikeArraySequence::const_iterator SpikeArrayConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeArrayType, char > SpikeArrayTraits;

      const SpikeArraySequence&
      spikeArrays () const;

      SpikeArraySequence&
      spikeArrays ();

      void
      setSpikeArrays (const SpikeArraySequence& s);

      // spikeGenerator
      //
      typedef ::neurona::schema::SpikeGenerator SpikeGeneratorType;
      typedef ::xsd::cxx::tree::sequence< SpikeGeneratorType > SpikeGeneratorSequence;
      typedef SpikeGeneratorSequence::iterator SpikeGeneratorIterator;
      typedef SpikeGeneratorSequence::const_iterator SpikeGeneratorConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeGeneratorType, char > SpikeGeneratorTraits;

      const SpikeGeneratorSequence&
      spikeGenerators () const;

      SpikeGeneratorSequence&
      spikeGenerators ();

      void
      setSpikeGenerators (const SpikeGeneratorSequence& s);

      // spikeGeneratorRandom
      //
      typedef ::neurona::schema::SpikeGeneratorRandom SpikeGeneratorRandomType;
      typedef ::xsd::cxx::tree::sequence< SpikeGeneratorRandomType > SpikeGeneratorRandomSequence;
      typedef SpikeGeneratorRandomSequence::iterator SpikeGeneratorRandomIterator;
      typedef SpikeGeneratorRandomSequence::const_iterator SpikeGeneratorRandomConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeGeneratorRandomType, char > SpikeGeneratorRandomTraits;

      const SpikeGeneratorRandomSequence&
      spikeGeneratorRandoms () const;

      SpikeGeneratorRandomSequence&
      spikeGeneratorRandoms ();

      void
      setSpikeGeneratorRandoms (const SpikeGeneratorRandomSequence& s);

      // spikeGeneratorPoisson
      //
      typedef ::neurona::schema::SpikeGeneratorPoisson SpikeGeneratorPoissonType;
      typedef ::xsd::cxx::tree::sequence< SpikeGeneratorPoissonType > SpikeGeneratorPoissonSequence;
      typedef SpikeGeneratorPoissonSequence::iterator SpikeGeneratorPoissonIterator;
      typedef SpikeGeneratorPoissonSequence::const_iterator SpikeGeneratorPoissonConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeGeneratorPoissonType, char > SpikeGeneratorPoissonTraits;

      const SpikeGeneratorPoissonSequence&
      spikeGeneratorPoissons () const;

      SpikeGeneratorPoissonSequence&
      spikeGeneratorPoissons ();

      void
      setSpikeGeneratorPoissons (const SpikeGeneratorPoissonSequence& s);

      // IF_curr_alpha
      //
      typedef ::neurona::schema::IF_curr_alpha IF_curr_alphaType;
      typedef ::xsd::cxx::tree::sequence< IF_curr_alphaType > IF_curr_alphaSequence;
      typedef IF_curr_alphaSequence::iterator IF_curr_alphaIterator;
      typedef IF_curr_alphaSequence::const_iterator IF_curr_alphaConstIterator;
      typedef ::xsd::cxx::tree::traits< IF_curr_alphaType, char > IF_curr_alphaTraits;

      const IF_curr_alphaSequence&
      IF_curr_alphas () const;

      IF_curr_alphaSequence&
      IF_curr_alphas ();

      void
      setIF_curr_alphas (const IF_curr_alphaSequence& s);

      // IF_curr_exp
      //
      typedef ::neurona::schema::IF_curr_exp IF_curr_expType;
      typedef ::xsd::cxx::tree::sequence< IF_curr_expType > IF_curr_expSequence;
      typedef IF_curr_expSequence::iterator IF_curr_expIterator;
      typedef IF_curr_expSequence::const_iterator IF_curr_expConstIterator;
      typedef ::xsd::cxx::tree::traits< IF_curr_expType, char > IF_curr_expTraits;

      const IF_curr_expSequence&
      IF_curr_exps () const;

      IF_curr_expSequence&
      IF_curr_exps ();

      void
      setIF_curr_exps (const IF_curr_expSequence& s);

      // IF_cond_alpha
      //
      typedef ::neurona::schema::IF_cond_alpha IF_cond_alphaType;
      typedef ::xsd::cxx::tree::sequence< IF_cond_alphaType > IF_cond_alphaSequence;
      typedef IF_cond_alphaSequence::iterator IF_cond_alphaIterator;
      typedef IF_cond_alphaSequence::const_iterator IF_cond_alphaConstIterator;
      typedef ::xsd::cxx::tree::traits< IF_cond_alphaType, char > IF_cond_alphaTraits;

      const IF_cond_alphaSequence&
      IF_cond_alphas () const;

      IF_cond_alphaSequence&
      IF_cond_alphas ();

      void
      setIF_cond_alphas (const IF_cond_alphaSequence& s);

      // IF_cond_exp
      //
      typedef ::neurona::schema::IF_cond_exp IF_cond_expType;
      typedef ::xsd::cxx::tree::sequence< IF_cond_expType > IF_cond_expSequence;
      typedef IF_cond_expSequence::iterator IF_cond_expIterator;
      typedef IF_cond_expSequence::const_iterator IF_cond_expConstIterator;
      typedef ::xsd::cxx::tree::traits< IF_cond_expType, char > IF_cond_expTraits;

      const IF_cond_expSequence&
      IF_cond_exps () const;

      IF_cond_expSequence&
      IF_cond_exps ();

      void
      setIF_cond_exps (const IF_cond_expSequence& s);

      // EIF_cond_exp_isfa_ista
      //
      typedef ::neurona::schema::EIF_cond_exp_isfa_ista EIF_cond_exp_isfa_istaType;
      typedef ::xsd::cxx::tree::sequence< EIF_cond_exp_isfa_istaType > EIF_cond_exp_isfa_istaSequence;
      typedef EIF_cond_exp_isfa_istaSequence::iterator EIF_cond_exp_isfa_istaIterator;
      typedef EIF_cond_exp_isfa_istaSequence::const_iterator EIF_cond_exp_isfa_istaConstIterator;
      typedef ::xsd::cxx::tree::traits< EIF_cond_exp_isfa_istaType, char > EIF_cond_exp_isfa_istaTraits;

      const EIF_cond_exp_isfa_istaSequence&
      EIF_cond_exp_isfa_istas () const;

      EIF_cond_exp_isfa_istaSequence&
      EIF_cond_exp_isfa_istas ();

      void
      setEIF_cond_exp_isfa_istas (const EIF_cond_exp_isfa_istaSequence& s);

      // EIF_cond_alpha_isfa_ista
      //
      typedef ::neurona::schema::EIF_cond_alpha_isfa_ista EIF_cond_alpha_isfa_istaType;
      typedef ::xsd::cxx::tree::sequence< EIF_cond_alpha_isfa_istaType > EIF_cond_alpha_isfa_istaSequence;
      typedef EIF_cond_alpha_isfa_istaSequence::iterator EIF_cond_alpha_isfa_istaIterator;
      typedef EIF_cond_alpha_isfa_istaSequence::const_iterator EIF_cond_alpha_isfa_istaConstIterator;
      typedef ::xsd::cxx::tree::traits< EIF_cond_alpha_isfa_istaType, char > EIF_cond_alpha_isfa_istaTraits;

      const EIF_cond_alpha_isfa_istaSequence&
      EIF_cond_alpha_isfa_istas () const;

      EIF_cond_alpha_isfa_istaSequence&
      EIF_cond_alpha_isfa_istas ();

      void
      setEIF_cond_alpha_isfa_istas (const EIF_cond_alpha_isfa_istaSequence& s);

      // HH_cond_exp
      //
      typedef ::neurona::schema::HH_cond_exp HH_cond_expType;
      typedef ::xsd::cxx::tree::sequence< HH_cond_expType > HH_cond_expSequence;
      typedef HH_cond_expSequence::iterator HH_cond_expIterator;
      typedef HH_cond_expSequence::const_iterator HH_cond_expConstIterator;
      typedef ::xsd::cxx::tree::traits< HH_cond_expType, char > HH_cond_expTraits;

      const HH_cond_expSequence&
      HH_cond_exps () const;

      HH_cond_expSequence&
      HH_cond_exps ();

      void
      setHH_cond_exps (const HH_cond_expSequence& s);

      // expCondSynapse
      //
      typedef ::neurona::schema::ExpCondSynapse ExpCondSynapseType;
      typedef ::xsd::cxx::tree::sequence< ExpCondSynapseType > ExpCondSynapseSequence;
      typedef ExpCondSynapseSequence::iterator ExpCondSynapseIterator;
      typedef ExpCondSynapseSequence::const_iterator ExpCondSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< ExpCondSynapseType, char > ExpCondSynapseTraits;

      const ExpCondSynapseSequence&
      expCondSynapses () const;

      ExpCondSynapseSequence&
      expCondSynapses ();

      void
      setExpCondSynapses (const ExpCondSynapseSequence& s);

      // alphaCondSynapse
      //
      typedef ::neurona::schema::AlphaCondSynapse AlphaCondSynapseType;
      typedef ::xsd::cxx::tree::sequence< AlphaCondSynapseType > AlphaCondSynapseSequence;
      typedef AlphaCondSynapseSequence::iterator AlphaCondSynapseIterator;
      typedef AlphaCondSynapseSequence::const_iterator AlphaCondSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< AlphaCondSynapseType, char > AlphaCondSynapseTraits;

      const AlphaCondSynapseSequence&
      alphaCondSynapses () const;

      AlphaCondSynapseSequence&
      alphaCondSynapses ();

      void
      setAlphaCondSynapses (const AlphaCondSynapseSequence& s);

      // expCurrSynapse
      //
      typedef ::neurona::schema::ExpCurrSynapse ExpCurrSynapseType;
      typedef ::xsd::cxx::tree::sequence< ExpCurrSynapseType > ExpCurrSynapseSequence;
      typedef ExpCurrSynapseSequence::iterator ExpCurrSynapseIterator;
      typedef ExpCurrSynapseSequence::const_iterator ExpCurrSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< ExpCurrSynapseType, char > ExpCurrSynapseTraits;

      const ExpCurrSynapseSequence&
      expCurrSynapses () const;

      ExpCurrSynapseSequence&
      expCurrSynapses ();

      void
      setExpCurrSynapses (const ExpCurrSynapseSequence& s);

      // alphaCurrSynapse
      //
      typedef ::neurona::schema::AlphaCurrSynapse AlphaCurrSynapseType;
      typedef ::xsd::cxx::tree::sequence< AlphaCurrSynapseType > AlphaCurrSynapseSequence;
      typedef AlphaCurrSynapseSequence::iterator AlphaCurrSynapseIterator;
      typedef AlphaCurrSynapseSequence::const_iterator AlphaCurrSynapseConstIterator;
      typedef ::xsd::cxx::tree::traits< AlphaCurrSynapseType, char > AlphaCurrSynapseTraits;

      const AlphaCurrSynapseSequence&
      alphaCurrSynapses () const;

      AlphaCurrSynapseSequence&
      alphaCurrSynapses ();

      void
      setAlphaCurrSynapses (const AlphaCurrSynapseSequence& s);

      // SpikeSourcePoisson
      //
      typedef ::neurona::schema::SpikeSourcePoisson SpikeSourcePoissonType;
      typedef ::xsd::cxx::tree::sequence< SpikeSourcePoissonType > SpikeSourcePoissonSequence;
      typedef SpikeSourcePoissonSequence::iterator SpikeSourcePoissonIterator;
      typedef SpikeSourcePoissonSequence::const_iterator SpikeSourcePoissonConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeSourcePoissonType, char > SpikeSourcePoissonTraits;

      const SpikeSourcePoissonSequence&
      SpikeSourcePoissons () const;

      SpikeSourcePoissonSequence&
      SpikeSourcePoissons ();

      void
      setSpikeSourcePoissons (const SpikeSourcePoissonSequence& s);

      // network
      //
      typedef ::neurona::schema::Network NetworkType;
      typedef ::xsd::cxx::tree::sequence< NetworkType > NetworkSequence;
      typedef NetworkSequence::iterator NetworkIterator;
      typedef NetworkSequence::const_iterator NetworkConstIterator;
      typedef ::xsd::cxx::tree::traits< NetworkType, char > NetworkTraits;

      const NetworkSequence&
      networks () const;

      NetworkSequence&
      networks ();

      void
      setNetworks (const NetworkSequence& s);

      // ComponentType
      //
      typedef ::neurona::schema::ComponentType ComponentTypeType;
      typedef ::xsd::cxx::tree::sequence< ComponentTypeType > ComponentTypeSequence;
      typedef ComponentTypeSequence::iterator ComponentTypeIterator;
      typedef ComponentTypeSequence::const_iterator ComponentTypeConstIterator;
      typedef ::xsd::cxx::tree::traits< ComponentTypeType, char > ComponentTypeTraits;

      const ComponentTypeSequence&
      ComponentTypes () const;

      ComponentTypeSequence&
      ComponentTypes ();

      void
      setComponentTypes (const ComponentTypeSequence& s);

      // Constructors.
      //
      NeuroMLDocument (const IdType&);

      NeuroMLDocument (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      NeuroMLDocument (const NeuroMLDocument& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual NeuroMLDocument*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      NeuroMLDocument&
      operator= (const NeuroMLDocument& x);

      virtual 
      ~NeuroMLDocument ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      IncludeSequence include_;
      ExtracellularPropertiesSequence extracellularProperties_;
      IntracellularPropertiesSequence intracellularProperties_;
      MorphologySequence morphology_;
      IonChannelSequence ionChannel_;
      IonChannelHHSequence ionChannelHH_;
      DecayingPoolConcentrationModelSequence decayingPoolConcentrationModel_;
      FixedFactorConcentrationModelSequence fixedFactorConcentrationModel_;
      ExpOneSynapseSequence expOneSynapse_;
      ExpTwoSynapseSequence expTwoSynapse_;
      BlockingPlasticSynapseSequence blockingPlasticSynapse_;
      BiophysicalPropertiesSequence biophysicalProperties_;
      CellSequence cell_;
      BaseCellSequence baseCell_;
      IafTauCellSequence iafTauCell_;
      IafTauRefCellSequence iafTauRefCell_;
      IafCellSequence iafCell_;
      IafRefCellSequence iafRefCell_;
      IzhikevichCellSequence izhikevichCell_;
      AdExIaFCellSequence adExIaFCell_;
      FitzHughNagumoCellSequence fitzHughNagumoCell_;
      PulseGeneratorSequence pulseGenerator_;
      SineGeneratorSequence sineGenerator_;
      RampGeneratorSequence rampGenerator_;
      VoltageClampSequence voltageClamp_;
      SpikeArraySequence spikeArray_;
      SpikeGeneratorSequence spikeGenerator_;
      SpikeGeneratorRandomSequence spikeGeneratorRandom_;
      SpikeGeneratorPoissonSequence spikeGeneratorPoisson_;
      IF_curr_alphaSequence IF_curr_alpha_;
      IF_curr_expSequence IF_curr_exp_;
      IF_cond_alphaSequence IF_cond_alpha_;
      IF_cond_expSequence IF_cond_exp_;
      EIF_cond_exp_isfa_istaSequence EIF_cond_exp_isfa_ista_;
      EIF_cond_alpha_isfa_istaSequence EIF_cond_alpha_isfa_ista_;
      HH_cond_expSequence HH_cond_exp_;
      ExpCondSynapseSequence expCondSynapse_;
      AlphaCondSynapseSequence alphaCondSynapse_;
      ExpCurrSynapseSequence expCurrSynapse_;
      AlphaCurrSynapseSequence alphaCurrSynapse_;
      SpikeSourcePoissonSequence SpikeSourcePoisson_;
      NetworkSequence network_;
      ComponentTypeSequence ComponentType_;
    };

    class IncludeType: public ::xml_schema::Type
    {
      public:
      // href
      //
      typedef ::xml_schema::Uri HrefType;
      typedef ::xsd::cxx::tree::optional< HrefType > HrefOptional;
      typedef ::xsd::cxx::tree::traits< HrefType, char > HrefTraits;

      const HrefOptional&
      href () const;

      HrefOptional&
      href ();

      void
      setHref (const HrefType& x);

      void
      setHref (const HrefOptional& x);

      void
      setHref (::std::unique_ptr< HrefType > p);

      // Constructors.
      //
      IncludeType ();

      IncludeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      IncludeType (const IncludeType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual IncludeType*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IncludeType&
      operator= (const IncludeType& x);

      virtual 
      ~IncludeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      HrefOptional href_;
    };

    class IonChannel: public ::neurona::schema::Standalone
    {
      public:
      // gate
      //
      typedef ::neurona::schema::GateHHUndetermined GateType;
      typedef ::xsd::cxx::tree::sequence< GateType > GateSequence;
      typedef GateSequence::iterator GateIterator;
      typedef GateSequence::const_iterator GateConstIterator;
      typedef ::xsd::cxx::tree::traits< GateType, char > GateTraits;

      const GateSequence&
      gates () const;

      GateSequence&
      gates ();

      void
      setGates (const GateSequence& s);

      // gateHHrates
      //
      typedef ::neurona::schema::GateHHRates GateHHratesType;
      typedef ::xsd::cxx::tree::sequence< GateHHratesType > GateHHratesSequence;
      typedef GateHHratesSequence::iterator GateHHratesIterator;
      typedef GateHHratesSequence::const_iterator GateHHratesConstIterator;
      typedef ::xsd::cxx::tree::traits< GateHHratesType, char > GateHHratesTraits;

      const GateHHratesSequence&
      gateHHratess () const;

      GateHHratesSequence&
      gateHHratess ();

      void
      setGateHHratess (const GateHHratesSequence& s);

      // gateHHratesTau
      //
      typedef ::neurona::schema::GateHHRatesTau GateHHratesTauType;
      typedef ::xsd::cxx::tree::sequence< GateHHratesTauType > GateHHratesTauSequence;
      typedef GateHHratesTauSequence::iterator GateHHratesTauIterator;
      typedef GateHHratesTauSequence::const_iterator GateHHratesTauConstIterator;
      typedef ::xsd::cxx::tree::traits< GateHHratesTauType, char > GateHHratesTauTraits;

      const GateHHratesTauSequence&
      gateHHratesTaus () const;

      GateHHratesTauSequence&
      gateHHratesTaus ();

      void
      setGateHHratesTaus (const GateHHratesTauSequence& s);

      // gateHHtauInf
      //
      typedef ::neurona::schema::GateHHTauInf GateHHtauInfType;
      typedef ::xsd::cxx::tree::sequence< GateHHtauInfType > GateHHtauInfSequence;
      typedef GateHHtauInfSequence::iterator GateHHtauInfIterator;
      typedef GateHHtauInfSequence::const_iterator GateHHtauInfConstIterator;
      typedef ::xsd::cxx::tree::traits< GateHHtauInfType, char > GateHHtauInfTraits;

      const GateHHtauInfSequence&
      gateHHtauInfs () const;

      GateHHtauInfSequence&
      gateHHtauInfs ();

      void
      setGateHHtauInfs (const GateHHtauInfSequence& s);

      // gateHHratesInf
      //
      typedef ::neurona::schema::GateHHRatesInf GateHHratesInfType;
      typedef ::xsd::cxx::tree::sequence< GateHHratesInfType > GateHHratesInfSequence;
      typedef GateHHratesInfSequence::iterator GateHHratesInfIterator;
      typedef GateHHratesInfSequence::const_iterator GateHHratesInfConstIterator;
      typedef ::xsd::cxx::tree::traits< GateHHratesInfType, char > GateHHratesInfTraits;

      const GateHHratesInfSequence&
      gateHHratesInfs () const;

      GateHHratesInfSequence&
      gateHHratesInfs ();

      void
      setGateHHratesInfs (const GateHHratesInfSequence& s);

      // gateHHratesTauInf
      //
      typedef ::neurona::schema::GateHHRatesTauInf GateHHratesTauInfType;
      typedef ::xsd::cxx::tree::sequence< GateHHratesTauInfType > GateHHratesTauInfSequence;
      typedef GateHHratesTauInfSequence::iterator GateHHratesTauInfIterator;
      typedef GateHHratesTauInfSequence::const_iterator GateHHratesTauInfConstIterator;
      typedef ::xsd::cxx::tree::traits< GateHHratesTauInfType, char > GateHHratesTauInfTraits;

      const GateHHratesTauInfSequence&
      gateHHratesTauInfs () const;

      GateHHratesTauInfSequence&
      gateHHratesTauInfs ();

      void
      setGateHHratesTauInfs (const GateHHratesTauInfSequence& s);

      // species
      //
      typedef ::neurona::schema::NmlId SpeciesType;
      typedef ::xsd::cxx::tree::optional< SpeciesType > SpeciesOptional;
      typedef ::xsd::cxx::tree::traits< SpeciesType, char > SpeciesTraits;

      const SpeciesOptional&
      species () const;

      SpeciesOptional&
      species ();

      void
      setSpecies (const SpeciesType& x);

      void
      setSpecies (const SpeciesOptional& x);

      void
      setSpecies (::std::unique_ptr< SpeciesType > p);

      // type
      //
      typedef ::neurona::schema::ChannelTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // conductance
      //
      typedef ::neurona::schema::Nml2Quantity_conductance ConductanceType;
      typedef ::xsd::cxx::tree::optional< ConductanceType > ConductanceOptional;
      typedef ::xsd::cxx::tree::traits< ConductanceType, char > ConductanceTraits;

      const ConductanceOptional&
      conductance () const;

      ConductanceOptional&
      conductance ();

      void
      setConductance (const ConductanceType& x);

      void
      setConductance (const ConductanceOptional& x);

      void
      setConductance (::std::unique_ptr< ConductanceType > p);

      // Constructors.
      //
      IonChannel (const IdType&);

      IonChannel (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      IonChannel (const IonChannel& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual IonChannel*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IonChannel&
      operator= (const IonChannel& x);

      virtual 
      ~IonChannel ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      GateSequence gate_;
      GateHHratesSequence gateHHrates_;
      GateHHratesTauSequence gateHHratesTau_;
      GateHHtauInfSequence gateHHtauInf_;
      GateHHratesInfSequence gateHHratesInf_;
      GateHHratesTauInfSequence gateHHratesTauInf_;
      SpeciesOptional species_;
      TypeOptional type_;
      ConductanceOptional conductance_;
    };

    class IonChannelHH: public ::neurona::schema::IonChannel
    {
      public:
      // Constructors.
      //
      IonChannelHH (const IdType&);

      IonChannelHH (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      IonChannelHH (const IonChannelHH& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual IonChannelHH*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~IonChannelHH ();
    };

    class ChannelTypes: public ::xml_schema::String
    {
      public:
      enum Value
      {
        ionChannelPassive,
        ionChannelHH
      };

      ChannelTypes (Value v);

      ChannelTypes (const char* v);

      ChannelTypes (const ::std::string& v);

      ChannelTypes (const ::xml_schema::String& v);

      ChannelTypes (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      ChannelTypes (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      ChannelTypes (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      ChannelTypes (const ChannelTypes& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual ChannelTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelTypes&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_ChannelTypes_convert ();
      }

      protected:
      Value
      _xsd_ChannelTypes_convert () const;

      public:
      static const char* const _xsd_ChannelTypes_literals_[2];
      static const Value _xsd_ChannelTypes_indexes_[2];
    };

    class GateTypes: public ::xml_schema::String
    {
      public:
      enum Value
      {
        gateHHrates,
        gateHHratesTau,
        gateHHtauInf,
        gateHHratesInf,
        gateHHratesTauInf,
        gateKS
      };

      GateTypes (Value v);

      GateTypes (const char* v);

      GateTypes (const ::std::string& v);

      GateTypes (const ::xml_schema::String& v);

      GateTypes (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      GateTypes (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      GateTypes (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      GateTypes (const GateTypes& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      virtual GateTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateTypes&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_GateTypes_convert ();
      }

      protected:
      Value
      _xsd_GateTypes_convert () const;

      public:
      static const char* const _xsd_GateTypes_literals_[6];
      static const Value _xsd_GateTypes_indexes_[6];
    };

    class GateHHUndetermined: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // q10Settings
      //
      typedef ::neurona::schema::Q10Settings Q10SettingsType;
      typedef ::xsd::cxx::tree::optional< Q10SettingsType > Q10SettingsOptional;
      typedef ::xsd::cxx::tree::traits< Q10SettingsType, char > Q10SettingsTraits;

      const Q10SettingsOptional&
      q10Settings () const;

      Q10SettingsOptional&
      q10Settings ();

      void
      setQ10Settings (const Q10SettingsType& x);

      void
      setQ10Settings (const Q10SettingsOptional& x);

      void
      setQ10Settings (::std::unique_ptr< Q10SettingsType > p);

      // forwardRate
      //
      typedef ::neurona::schema::HHRate ForwardRateType;
      typedef ::xsd::cxx::tree::optional< ForwardRateType > ForwardRateOptional;
      typedef ::xsd::cxx::tree::traits< ForwardRateType, char > ForwardRateTraits;

      const ForwardRateOptional&
      forwardRate () const;

      ForwardRateOptional&
      forwardRate ();

      void
      setForwardRate (const ForwardRateType& x);

      void
      setForwardRate (const ForwardRateOptional& x);

      void
      setForwardRate (::std::unique_ptr< ForwardRateType > p);

      // reverseRate
      //
      typedef ::neurona::schema::HHRate ReverseRateType;
      typedef ::xsd::cxx::tree::optional< ReverseRateType > ReverseRateOptional;
      typedef ::xsd::cxx::tree::traits< ReverseRateType, char > ReverseRateTraits;

      const ReverseRateOptional&
      reverseRate () const;

      ReverseRateOptional&
      reverseRate ();

      void
      setReverseRate (const ReverseRateType& x);

      void
      setReverseRate (const ReverseRateOptional& x);

      void
      setReverseRate (::std::unique_ptr< ReverseRateType > p);

      // timeCourse
      //
      typedef ::neurona::schema::HHTime TimeCourseType;
      typedef ::xsd::cxx::tree::optional< TimeCourseType > TimeCourseOptional;
      typedef ::xsd::cxx::tree::traits< TimeCourseType, char > TimeCourseTraits;

      const TimeCourseOptional&
      timeCourse () const;

      TimeCourseOptional&
      timeCourse ();

      void
      setTimeCourse (const TimeCourseType& x);

      void
      setTimeCourse (const TimeCourseOptional& x);

      void
      setTimeCourse (::std::unique_ptr< TimeCourseType > p);

      // steadyState
      //
      typedef ::neurona::schema::HHVariable SteadyStateType;
      typedef ::xsd::cxx::tree::optional< SteadyStateType > SteadyStateOptional;
      typedef ::xsd::cxx::tree::traits< SteadyStateType, char > SteadyStateTraits;

      const SteadyStateOptional&
      steadyState () const;

      SteadyStateOptional&
      steadyState ();

      void
      setSteadyState (const SteadyStateType& x);

      void
      setSteadyState (const SteadyStateOptional& x);

      void
      setSteadyState (::std::unique_ptr< SteadyStateType > p);

      // instances
      //
      typedef ::xml_schema::Integer InstancesType;
      typedef ::xsd::cxx::tree::traits< InstancesType, char > InstancesTraits;

      const InstancesType&
      instances () const;

      InstancesType&
      instances ();

      void
      setInstances (const InstancesType& x);

      static InstancesType
      instancesDefaultValue ();

      // type
      //
      typedef ::neurona::schema::GateTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      GateHHUndetermined (const IdType&);

      GateHHUndetermined (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      GateHHUndetermined (const GateHHUndetermined& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual GateHHUndetermined*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateHHUndetermined&
      operator= (const GateHHUndetermined& x);

      virtual 
      ~GateHHUndetermined ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      Q10SettingsOptional q10Settings_;
      ForwardRateOptional forwardRate_;
      ReverseRateOptional reverseRate_;
      TimeCourseOptional timeCourse_;
      SteadyStateOptional steadyState_;
      ::xsd::cxx::tree::one< InstancesType > instances_;
      TypeOptional type_;
    };

    class GateHHRates: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // q10Settings
      //
      typedef ::neurona::schema::Q10Settings Q10SettingsType;
      typedef ::xsd::cxx::tree::optional< Q10SettingsType > Q10SettingsOptional;
      typedef ::xsd::cxx::tree::traits< Q10SettingsType, char > Q10SettingsTraits;

      const Q10SettingsOptional&
      q10Settings () const;

      Q10SettingsOptional&
      q10Settings ();

      void
      setQ10Settings (const Q10SettingsType& x);

      void
      setQ10Settings (const Q10SettingsOptional& x);

      void
      setQ10Settings (::std::unique_ptr< Q10SettingsType > p);

      // forwardRate
      //
      typedef ::neurona::schema::HHRate ForwardRateType;
      typedef ::xsd::cxx::tree::traits< ForwardRateType, char > ForwardRateTraits;

      const ForwardRateType&
      forwardRate () const;

      ForwardRateType&
      forwardRate ();

      void
      setForwardRate (const ForwardRateType& x);

      void
      setForwardRate (::std::unique_ptr< ForwardRateType > p);

      // reverseRate
      //
      typedef ::neurona::schema::HHRate ReverseRateType;
      typedef ::xsd::cxx::tree::traits< ReverseRateType, char > ReverseRateTraits;

      const ReverseRateType&
      reverseRate () const;

      ReverseRateType&
      reverseRate ();

      void
      setReverseRate (const ReverseRateType& x);

      void
      setReverseRate (::std::unique_ptr< ReverseRateType > p);

      // instances
      //
      typedef ::xml_schema::Integer InstancesType;
      typedef ::xsd::cxx::tree::traits< InstancesType, char > InstancesTraits;

      const InstancesType&
      instances () const;

      InstancesType&
      instances ();

      void
      setInstances (const InstancesType& x);

      static InstancesType
      instancesDefaultValue ();

      // type
      //
      typedef ::neurona::schema::GateTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      GateHHRates (const IdType&,
                   const ForwardRateType&,
                   const ReverseRateType&);

      GateHHRates (const IdType&,
                   ::std::unique_ptr< ForwardRateType >,
                   ::std::unique_ptr< ReverseRateType >);

      GateHHRates (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      GateHHRates (const GateHHRates& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual GateHHRates*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateHHRates&
      operator= (const GateHHRates& x);

      virtual 
      ~GateHHRates ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      Q10SettingsOptional q10Settings_;
      ::xsd::cxx::tree::one< ForwardRateType > forwardRate_;
      ::xsd::cxx::tree::one< ReverseRateType > reverseRate_;
      ::xsd::cxx::tree::one< InstancesType > instances_;
      TypeOptional type_;
    };

    class GateHHTauInf: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // q10Settings
      //
      typedef ::neurona::schema::Q10Settings Q10SettingsType;
      typedef ::xsd::cxx::tree::optional< Q10SettingsType > Q10SettingsOptional;
      typedef ::xsd::cxx::tree::traits< Q10SettingsType, char > Q10SettingsTraits;

      const Q10SettingsOptional&
      q10Settings () const;

      Q10SettingsOptional&
      q10Settings ();

      void
      setQ10Settings (const Q10SettingsType& x);

      void
      setQ10Settings (const Q10SettingsOptional& x);

      void
      setQ10Settings (::std::unique_ptr< Q10SettingsType > p);

      // timeCourse
      //
      typedef ::neurona::schema::HHTime TimeCourseType;
      typedef ::xsd::cxx::tree::traits< TimeCourseType, char > TimeCourseTraits;

      const TimeCourseType&
      timeCourse () const;

      TimeCourseType&
      timeCourse ();

      void
      setTimeCourse (const TimeCourseType& x);

      void
      setTimeCourse (::std::unique_ptr< TimeCourseType > p);

      // steadyState
      //
      typedef ::neurona::schema::HHVariable SteadyStateType;
      typedef ::xsd::cxx::tree::traits< SteadyStateType, char > SteadyStateTraits;

      const SteadyStateType&
      steadyState () const;

      SteadyStateType&
      steadyState ();

      void
      setSteadyState (const SteadyStateType& x);

      void
      setSteadyState (::std::unique_ptr< SteadyStateType > p);

      // instances
      //
      typedef ::xml_schema::Integer InstancesType;
      typedef ::xsd::cxx::tree::traits< InstancesType, char > InstancesTraits;

      const InstancesType&
      instances () const;

      InstancesType&
      instances ();

      void
      setInstances (const InstancesType& x);

      static InstancesType
      instancesDefaultValue ();

      // type
      //
      typedef ::neurona::schema::GateTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      GateHHTauInf (const IdType&,
                    const TimeCourseType&,
                    const SteadyStateType&);

      GateHHTauInf (const IdType&,
                    ::std::unique_ptr< TimeCourseType >,
                    ::std::unique_ptr< SteadyStateType >);

      GateHHTauInf (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      GateHHTauInf (const GateHHTauInf& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual GateHHTauInf*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateHHTauInf&
      operator= (const GateHHTauInf& x);

      virtual 
      ~GateHHTauInf ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      Q10SettingsOptional q10Settings_;
      ::xsd::cxx::tree::one< TimeCourseType > timeCourse_;
      ::xsd::cxx::tree::one< SteadyStateType > steadyState_;
      ::xsd::cxx::tree::one< InstancesType > instances_;
      TypeOptional type_;
    };

    class GateHHRatesTauInf: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // q10Settings
      //
      typedef ::neurona::schema::Q10Settings Q10SettingsType;
      typedef ::xsd::cxx::tree::optional< Q10SettingsType > Q10SettingsOptional;
      typedef ::xsd::cxx::tree::traits< Q10SettingsType, char > Q10SettingsTraits;

      const Q10SettingsOptional&
      q10Settings () const;

      Q10SettingsOptional&
      q10Settings ();

      void
      setQ10Settings (const Q10SettingsType& x);

      void
      setQ10Settings (const Q10SettingsOptional& x);

      void
      setQ10Settings (::std::unique_ptr< Q10SettingsType > p);

      // forwardRate
      //
      typedef ::neurona::schema::HHRate ForwardRateType;
      typedef ::xsd::cxx::tree::traits< ForwardRateType, char > ForwardRateTraits;

      const ForwardRateType&
      forwardRate () const;

      ForwardRateType&
      forwardRate ();

      void
      setForwardRate (const ForwardRateType& x);

      void
      setForwardRate (::std::unique_ptr< ForwardRateType > p);

      // reverseRate
      //
      typedef ::neurona::schema::HHRate ReverseRateType;
      typedef ::xsd::cxx::tree::traits< ReverseRateType, char > ReverseRateTraits;

      const ReverseRateType&
      reverseRate () const;

      ReverseRateType&
      reverseRate ();

      void
      setReverseRate (const ReverseRateType& x);

      void
      setReverseRate (::std::unique_ptr< ReverseRateType > p);

      // timeCourse
      //
      typedef ::neurona::schema::HHTime TimeCourseType;
      typedef ::xsd::cxx::tree::traits< TimeCourseType, char > TimeCourseTraits;

      const TimeCourseType&
      timeCourse () const;

      TimeCourseType&
      timeCourse ();

      void
      setTimeCourse (const TimeCourseType& x);

      void
      setTimeCourse (::std::unique_ptr< TimeCourseType > p);

      // steadyState
      //
      typedef ::neurona::schema::HHVariable SteadyStateType;
      typedef ::xsd::cxx::tree::traits< SteadyStateType, char > SteadyStateTraits;

      const SteadyStateType&
      steadyState () const;

      SteadyStateType&
      steadyState ();

      void
      setSteadyState (const SteadyStateType& x);

      void
      setSteadyState (::std::unique_ptr< SteadyStateType > p);

      // instances
      //
      typedef ::xml_schema::Integer InstancesType;
      typedef ::xsd::cxx::tree::traits< InstancesType, char > InstancesTraits;

      const InstancesType&
      instances () const;

      InstancesType&
      instances ();

      void
      setInstances (const InstancesType& x);

      static InstancesType
      instancesDefaultValue ();

      // type
      //
      typedef ::neurona::schema::GateTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      GateHHRatesTauInf (const IdType&,
                         const ForwardRateType&,
                         const ReverseRateType&,
                         const TimeCourseType&,
                         const SteadyStateType&);

      GateHHRatesTauInf (const IdType&,
                         ::std::unique_ptr< ForwardRateType >,
                         ::std::unique_ptr< ReverseRateType >,
                         ::std::unique_ptr< TimeCourseType >,
                         ::std::unique_ptr< SteadyStateType >);

      GateHHRatesTauInf (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      GateHHRatesTauInf (const GateHHRatesTauInf& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual GateHHRatesTauInf*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateHHRatesTauInf&
      operator= (const GateHHRatesTauInf& x);

      virtual 
      ~GateHHRatesTauInf ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      Q10SettingsOptional q10Settings_;
      ::xsd::cxx::tree::one< ForwardRateType > forwardRate_;
      ::xsd::cxx::tree::one< ReverseRateType > reverseRate_;
      ::xsd::cxx::tree::one< TimeCourseType > timeCourse_;
      ::xsd::cxx::tree::one< SteadyStateType > steadyState_;
      ::xsd::cxx::tree::one< InstancesType > instances_;
      TypeOptional type_;
    };

    class GateHHRatesTau: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // q10Settings
      //
      typedef ::neurona::schema::Q10Settings Q10SettingsType;
      typedef ::xsd::cxx::tree::optional< Q10SettingsType > Q10SettingsOptional;
      typedef ::xsd::cxx::tree::traits< Q10SettingsType, char > Q10SettingsTraits;

      const Q10SettingsOptional&
      q10Settings () const;

      Q10SettingsOptional&
      q10Settings ();

      void
      setQ10Settings (const Q10SettingsType& x);

      void
      setQ10Settings (const Q10SettingsOptional& x);

      void
      setQ10Settings (::std::unique_ptr< Q10SettingsType > p);

      // forwardRate
      //
      typedef ::neurona::schema::HHRate ForwardRateType;
      typedef ::xsd::cxx::tree::traits< ForwardRateType, char > ForwardRateTraits;

      const ForwardRateType&
      forwardRate () const;

      ForwardRateType&
      forwardRate ();

      void
      setForwardRate (const ForwardRateType& x);

      void
      setForwardRate (::std::unique_ptr< ForwardRateType > p);

      // reverseRate
      //
      typedef ::neurona::schema::HHRate ReverseRateType;
      typedef ::xsd::cxx::tree::traits< ReverseRateType, char > ReverseRateTraits;

      const ReverseRateType&
      reverseRate () const;

      ReverseRateType&
      reverseRate ();

      void
      setReverseRate (const ReverseRateType& x);

      void
      setReverseRate (::std::unique_ptr< ReverseRateType > p);

      // timeCourse
      //
      typedef ::neurona::schema::HHTime TimeCourseType;
      typedef ::xsd::cxx::tree::traits< TimeCourseType, char > TimeCourseTraits;

      const TimeCourseType&
      timeCourse () const;

      TimeCourseType&
      timeCourse ();

      void
      setTimeCourse (const TimeCourseType& x);

      void
      setTimeCourse (::std::unique_ptr< TimeCourseType > p);

      // instances
      //
      typedef ::xml_schema::Integer InstancesType;
      typedef ::xsd::cxx::tree::traits< InstancesType, char > InstancesTraits;

      const InstancesType&
      instances () const;

      InstancesType&
      instances ();

      void
      setInstances (const InstancesType& x);

      static InstancesType
      instancesDefaultValue ();

      // type
      //
      typedef ::neurona::schema::GateTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      GateHHRatesTau (const IdType&,
                      const ForwardRateType&,
                      const ReverseRateType&,
                      const TimeCourseType&);

      GateHHRatesTau (const IdType&,
                      ::std::unique_ptr< ForwardRateType >,
                      ::std::unique_ptr< ReverseRateType >,
                      ::std::unique_ptr< TimeCourseType >);

      GateHHRatesTau (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      GateHHRatesTau (const GateHHRatesTau& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual GateHHRatesTau*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateHHRatesTau&
      operator= (const GateHHRatesTau& x);

      virtual 
      ~GateHHRatesTau ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      Q10SettingsOptional q10Settings_;
      ::xsd::cxx::tree::one< ForwardRateType > forwardRate_;
      ::xsd::cxx::tree::one< ReverseRateType > reverseRate_;
      ::xsd::cxx::tree::one< TimeCourseType > timeCourse_;
      ::xsd::cxx::tree::one< InstancesType > instances_;
      TypeOptional type_;
    };

    class GateHHRatesInf: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // q10Settings
      //
      typedef ::neurona::schema::Q10Settings Q10SettingsType;
      typedef ::xsd::cxx::tree::optional< Q10SettingsType > Q10SettingsOptional;
      typedef ::xsd::cxx::tree::traits< Q10SettingsType, char > Q10SettingsTraits;

      const Q10SettingsOptional&
      q10Settings () const;

      Q10SettingsOptional&
      q10Settings ();

      void
      setQ10Settings (const Q10SettingsType& x);

      void
      setQ10Settings (const Q10SettingsOptional& x);

      void
      setQ10Settings (::std::unique_ptr< Q10SettingsType > p);

      // forwardRate
      //
      typedef ::neurona::schema::HHRate ForwardRateType;
      typedef ::xsd::cxx::tree::traits< ForwardRateType, char > ForwardRateTraits;

      const ForwardRateType&
      forwardRate () const;

      ForwardRateType&
      forwardRate ();

      void
      setForwardRate (const ForwardRateType& x);

      void
      setForwardRate (::std::unique_ptr< ForwardRateType > p);

      // reverseRate
      //
      typedef ::neurona::schema::HHRate ReverseRateType;
      typedef ::xsd::cxx::tree::traits< ReverseRateType, char > ReverseRateTraits;

      const ReverseRateType&
      reverseRate () const;

      ReverseRateType&
      reverseRate ();

      void
      setReverseRate (const ReverseRateType& x);

      void
      setReverseRate (::std::unique_ptr< ReverseRateType > p);

      // steadyState
      //
      typedef ::neurona::schema::HHVariable SteadyStateType;
      typedef ::xsd::cxx::tree::traits< SteadyStateType, char > SteadyStateTraits;

      const SteadyStateType&
      steadyState () const;

      SteadyStateType&
      steadyState ();

      void
      setSteadyState (const SteadyStateType& x);

      void
      setSteadyState (::std::unique_ptr< SteadyStateType > p);

      // instances
      //
      typedef ::xml_schema::Integer InstancesType;
      typedef ::xsd::cxx::tree::traits< InstancesType, char > InstancesTraits;

      const InstancesType&
      instances () const;

      InstancesType&
      instances ();

      void
      setInstances (const InstancesType& x);

      static InstancesType
      instancesDefaultValue ();

      // type
      //
      typedef ::neurona::schema::GateTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      GateHHRatesInf (const IdType&,
                      const ForwardRateType&,
                      const ReverseRateType&,
                      const SteadyStateType&);

      GateHHRatesInf (const IdType&,
                      ::std::unique_ptr< ForwardRateType >,
                      ::std::unique_ptr< ReverseRateType >,
                      ::std::unique_ptr< SteadyStateType >);

      GateHHRatesInf (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      GateHHRatesInf (const GateHHRatesInf& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual GateHHRatesInf*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GateHHRatesInf&
      operator= (const GateHHRatesInf& x);

      virtual 
      ~GateHHRatesInf ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      Q10SettingsOptional q10Settings_;
      ::xsd::cxx::tree::one< ForwardRateType > forwardRate_;
      ::xsd::cxx::tree::one< ReverseRateType > reverseRate_;
      ::xsd::cxx::tree::one< SteadyStateType > steadyState_;
      ::xsd::cxx::tree::one< InstancesType > instances_;
      TypeOptional type_;
    };

    class Q10Settings: public ::xml_schema::Type
    {
      public:
      // type
      //
      typedef ::neurona::schema::NmlId TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // fixedQ10
      //
      typedef ::neurona::schema::Nml2Quantity_none FixedQ10Type;
      typedef ::xsd::cxx::tree::optional< FixedQ10Type > FixedQ10Optional;
      typedef ::xsd::cxx::tree::traits< FixedQ10Type, char > FixedQ10Traits;

      const FixedQ10Optional&
      fixedQ10 () const;

      FixedQ10Optional&
      fixedQ10 ();

      void
      setFixedQ10 (const FixedQ10Type& x);

      void
      setFixedQ10 (const FixedQ10Optional& x);

      void
      setFixedQ10 (::std::unique_ptr< FixedQ10Type > p);

      // q10Factor
      //
      typedef ::neurona::schema::Nml2Quantity_none Q10FactorType;
      typedef ::xsd::cxx::tree::optional< Q10FactorType > Q10FactorOptional;
      typedef ::xsd::cxx::tree::traits< Q10FactorType, char > Q10FactorTraits;

      const Q10FactorOptional&
      q10Factor () const;

      Q10FactorOptional&
      q10Factor ();

      void
      setQ10Factor (const Q10FactorType& x);

      void
      setQ10Factor (const Q10FactorOptional& x);

      void
      setQ10Factor (::std::unique_ptr< Q10FactorType > p);

      // experimentalTemp
      //
      typedef ::neurona::schema::Nml2Quantity_temperature ExperimentalTempType;
      typedef ::xsd::cxx::tree::optional< ExperimentalTempType > ExperimentalTempOptional;
      typedef ::xsd::cxx::tree::traits< ExperimentalTempType, char > ExperimentalTempTraits;

      const ExperimentalTempOptional&
      experimentalTemp () const;

      ExperimentalTempOptional&
      experimentalTemp ();

      void
      setExperimentalTemp (const ExperimentalTempType& x);

      void
      setExperimentalTemp (const ExperimentalTempOptional& x);

      void
      setExperimentalTemp (::std::unique_ptr< ExperimentalTempType > p);

      // Constructors.
      //
      Q10Settings (const TypeType&);

      Q10Settings (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      Q10Settings (const Q10Settings& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual Q10Settings*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Q10Settings&
      operator= (const Q10Settings& x);

      virtual 
      ~Q10Settings ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      FixedQ10Optional fixedQ10_;
      Q10FactorOptional q10Factor_;
      ExperimentalTempOptional experimentalTemp_;
    };

    class HHRate: public ::xml_schema::Type
    {
      public:
      // type
      //
      typedef ::neurona::schema::NmlId TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // rate
      //
      typedef ::neurona::schema::Nml2Quantity_pertime RateType;
      typedef ::xsd::cxx::tree::optional< RateType > RateOptional;
      typedef ::xsd::cxx::tree::traits< RateType, char > RateTraits;

      const RateOptional&
      rate () const;

      RateOptional&
      rate ();

      void
      setRate (const RateType& x);

      void
      setRate (const RateOptional& x);

      void
      setRate (::std::unique_ptr< RateType > p);

      // midpoint
      //
      typedef ::neurona::schema::Nml2Quantity_voltage MidpointType;
      typedef ::xsd::cxx::tree::optional< MidpointType > MidpointOptional;
      typedef ::xsd::cxx::tree::traits< MidpointType, char > MidpointTraits;

      const MidpointOptional&
      midpoint () const;

      MidpointOptional&
      midpoint ();

      void
      setMidpoint (const MidpointType& x);

      void
      setMidpoint (const MidpointOptional& x);

      void
      setMidpoint (::std::unique_ptr< MidpointType > p);

      // scale
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ScaleType;
      typedef ::xsd::cxx::tree::optional< ScaleType > ScaleOptional;
      typedef ::xsd::cxx::tree::traits< ScaleType, char > ScaleTraits;

      const ScaleOptional&
      scale () const;

      ScaleOptional&
      scale ();

      void
      setScale (const ScaleType& x);

      void
      setScale (const ScaleOptional& x);

      void
      setScale (::std::unique_ptr< ScaleType > p);

      // Constructors.
      //
      HHRate (const TypeType&);

      HHRate (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      HHRate (const HHRate& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual HHRate*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      HHRate&
      operator= (const HHRate& x);

      virtual 
      ~HHRate ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      RateOptional rate_;
      MidpointOptional midpoint_;
      ScaleOptional scale_;
    };

    class HHVariable: public ::xml_schema::Type
    {
      public:
      // type
      //
      typedef ::neurona::schema::NmlId TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // rate
      //
      typedef ::xml_schema::Float RateType;
      typedef ::xsd::cxx::tree::optional< RateType > RateOptional;
      typedef ::xsd::cxx::tree::traits< RateType, char > RateTraits;

      const RateOptional&
      rate () const;

      RateOptional&
      rate ();

      void
      setRate (const RateType& x);

      void
      setRate (const RateOptional& x);

      // midpoint
      //
      typedef ::neurona::schema::Nml2Quantity_voltage MidpointType;
      typedef ::xsd::cxx::tree::optional< MidpointType > MidpointOptional;
      typedef ::xsd::cxx::tree::traits< MidpointType, char > MidpointTraits;

      const MidpointOptional&
      midpoint () const;

      MidpointOptional&
      midpoint ();

      void
      setMidpoint (const MidpointType& x);

      void
      setMidpoint (const MidpointOptional& x);

      void
      setMidpoint (::std::unique_ptr< MidpointType > p);

      // scale
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ScaleType;
      typedef ::xsd::cxx::tree::optional< ScaleType > ScaleOptional;
      typedef ::xsd::cxx::tree::traits< ScaleType, char > ScaleTraits;

      const ScaleOptional&
      scale () const;

      ScaleOptional&
      scale ();

      void
      setScale (const ScaleType& x);

      void
      setScale (const ScaleOptional& x);

      void
      setScale (::std::unique_ptr< ScaleType > p);

      // Constructors.
      //
      HHVariable (const TypeType&);

      HHVariable (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      HHVariable (const HHVariable& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual HHVariable*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      HHVariable&
      operator= (const HHVariable& x);

      virtual 
      ~HHVariable ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      RateOptional rate_;
      MidpointOptional midpoint_;
      ScaleOptional scale_;
    };

    class HHTime: public ::xml_schema::Type
    {
      public:
      // type
      //
      typedef ::neurona::schema::NmlId TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // rate
      //
      typedef ::neurona::schema::Nml2Quantity_time RateType;
      typedef ::xsd::cxx::tree::optional< RateType > RateOptional;
      typedef ::xsd::cxx::tree::traits< RateType, char > RateTraits;

      const RateOptional&
      rate () const;

      RateOptional&
      rate ();

      void
      setRate (const RateType& x);

      void
      setRate (const RateOptional& x);

      void
      setRate (::std::unique_ptr< RateType > p);

      // midpoint
      //
      typedef ::neurona::schema::Nml2Quantity_voltage MidpointType;
      typedef ::xsd::cxx::tree::optional< MidpointType > MidpointOptional;
      typedef ::xsd::cxx::tree::traits< MidpointType, char > MidpointTraits;

      const MidpointOptional&
      midpoint () const;

      MidpointOptional&
      midpoint ();

      void
      setMidpoint (const MidpointType& x);

      void
      setMidpoint (const MidpointOptional& x);

      void
      setMidpoint (::std::unique_ptr< MidpointType > p);

      // scale
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ScaleType;
      typedef ::xsd::cxx::tree::optional< ScaleType > ScaleOptional;
      typedef ::xsd::cxx::tree::traits< ScaleType, char > ScaleTraits;

      const ScaleOptional&
      scale () const;

      ScaleOptional&
      scale ();

      void
      setScale (const ScaleType& x);

      void
      setScale (const ScaleOptional& x);

      void
      setScale (::std::unique_ptr< ScaleType > p);

      // tau
      //
      typedef ::neurona::schema::Nml2Quantity_time TauType;
      typedef ::xsd::cxx::tree::optional< TauType > TauOptional;
      typedef ::xsd::cxx::tree::traits< TauType, char > TauTraits;

      const TauOptional&
      tau () const;

      TauOptional&
      tau ();

      void
      setTau (const TauType& x);

      void
      setTau (const TauOptional& x);

      void
      setTau (::std::unique_ptr< TauType > p);

      // Constructors.
      //
      HHTime (const TypeType&);

      HHTime (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      HHTime (const HHTime& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual HHTime*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      HHTime&
      operator= (const HHTime& x);

      virtual 
      ~HHTime ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      RateOptional rate_;
      MidpointOptional midpoint_;
      ScaleOptional scale_;
      TauOptional tau_;
    };

    class DecayingPoolConcentrationModel: public ::neurona::schema::Standalone
    {
      public:
      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonType&
      ion () const;

      IonType&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // restingConc
      //
      typedef ::neurona::schema::Nml2Quantity_concentration RestingConcType;
      typedef ::xsd::cxx::tree::traits< RestingConcType, char > RestingConcTraits;

      const RestingConcType&
      restingConc () const;

      RestingConcType&
      restingConc ();

      void
      setRestingConc (const RestingConcType& x);

      void
      setRestingConc (::std::unique_ptr< RestingConcType > p);

      // decayConstant
      //
      typedef ::neurona::schema::Nml2Quantity_time DecayConstantType;
      typedef ::xsd::cxx::tree::traits< DecayConstantType, char > DecayConstantTraits;

      const DecayConstantType&
      decayConstant () const;

      DecayConstantType&
      decayConstant ();

      void
      setDecayConstant (const DecayConstantType& x);

      void
      setDecayConstant (::std::unique_ptr< DecayConstantType > p);

      // shellThickness
      //
      typedef ::neurona::schema::Nml2Quantity_length ShellThicknessType;
      typedef ::xsd::cxx::tree::traits< ShellThicknessType, char > ShellThicknessTraits;

      const ShellThicknessType&
      shellThickness () const;

      ShellThicknessType&
      shellThickness ();

      void
      setShellThickness (const ShellThicknessType& x);

      void
      setShellThickness (::std::unique_ptr< ShellThicknessType > p);

      // Constructors.
      //
      DecayingPoolConcentrationModel (const IdType&,
                                      const IonType&,
                                      const RestingConcType&,
                                      const DecayConstantType&,
                                      const ShellThicknessType&);

      DecayingPoolConcentrationModel (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

      DecayingPoolConcentrationModel (const DecayingPoolConcentrationModel& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

      virtual DecayingPoolConcentrationModel*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      DecayingPoolConcentrationModel&
      operator= (const DecayingPoolConcentrationModel& x);

      virtual 
      ~DecayingPoolConcentrationModel ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IonType > ion_;
      ::xsd::cxx::tree::one< RestingConcType > restingConc_;
      ::xsd::cxx::tree::one< DecayConstantType > decayConstant_;
      ::xsd::cxx::tree::one< ShellThicknessType > shellThickness_;
    };

    class FixedFactorConcentrationModel: public ::neurona::schema::Standalone
    {
      public:
      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonType&
      ion () const;

      IonType&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // restingConc
      //
      typedef ::neurona::schema::Nml2Quantity_concentration RestingConcType;
      typedef ::xsd::cxx::tree::traits< RestingConcType, char > RestingConcTraits;

      const RestingConcType&
      restingConc () const;

      RestingConcType&
      restingConc ();

      void
      setRestingConc (const RestingConcType& x);

      void
      setRestingConc (::std::unique_ptr< RestingConcType > p);

      // decayConstant
      //
      typedef ::neurona::schema::Nml2Quantity_time DecayConstantType;
      typedef ::xsd::cxx::tree::traits< DecayConstantType, char > DecayConstantTraits;

      const DecayConstantType&
      decayConstant () const;

      DecayConstantType&
      decayConstant ();

      void
      setDecayConstant (const DecayConstantType& x);

      void
      setDecayConstant (::std::unique_ptr< DecayConstantType > p);

      // rho
      //
      typedef ::neurona::schema::Nml2Quantity_rhoFactor RhoType;
      typedef ::xsd::cxx::tree::traits< RhoType, char > RhoTraits;

      const RhoType&
      rho () const;

      RhoType&
      rho ();

      void
      setRho (const RhoType& x);

      void
      setRho (::std::unique_ptr< RhoType > p);

      // Constructors.
      //
      FixedFactorConcentrationModel (const IdType&,
                                     const IonType&,
                                     const RestingConcType&,
                                     const DecayConstantType&,
                                     const RhoType&);

      FixedFactorConcentrationModel (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

      FixedFactorConcentrationModel (const FixedFactorConcentrationModel& x,
                                     ::xml_schema::Flags f = 0,
                                     ::xml_schema::Container* c = 0);

      virtual FixedFactorConcentrationModel*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      FixedFactorConcentrationModel&
      operator= (const FixedFactorConcentrationModel& x);

      virtual 
      ~FixedFactorConcentrationModel ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IonType > ion_;
      ::xsd::cxx::tree::one< RestingConcType > restingConc_;
      ::xsd::cxx::tree::one< DecayConstantType > decayConstant_;
      ::xsd::cxx::tree::one< RhoType > rho_;
    };

    class BaseSynapse: public ::neurona::schema::Standalone
    {
      public:
      // Constructors.
      //
      BaseSynapse (const IdType&);

      BaseSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      BaseSynapse (const BaseSynapse& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual BaseSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~BaseSynapse ();
    };

    class BaseConductanceBasedSynapse: public ::neurona::schema::BaseSynapse
    {
      public:
      // gbase
      //
      typedef ::neurona::schema::Nml2Quantity_conductance GbaseType;
      typedef ::xsd::cxx::tree::traits< GbaseType, char > GbaseTraits;

      const GbaseType&
      gbase () const;

      GbaseType&
      gbase ();

      void
      setGbase (const GbaseType& x);

      void
      setGbase (::std::unique_ptr< GbaseType > p);

      // erev
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ErevType;
      typedef ::xsd::cxx::tree::traits< ErevType, char > ErevTraits;

      const ErevType&
      erev () const;

      ErevType&
      erev ();

      void
      setErev (const ErevType& x);

      void
      setErev (::std::unique_ptr< ErevType > p);

      // Constructors.
      //
      BaseConductanceBasedSynapse (const IdType&,
                                   const GbaseType&,
                                   const ErevType&);

      BaseConductanceBasedSynapse (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

      BaseConductanceBasedSynapse (const BaseConductanceBasedSynapse& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

      virtual BaseConductanceBasedSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BaseConductanceBasedSynapse&
      operator= (const BaseConductanceBasedSynapse& x);

      virtual 
      ~BaseConductanceBasedSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< GbaseType > gbase_;
      ::xsd::cxx::tree::one< ErevType > erev_;
    };

    class ExpOneSynapse: public ::neurona::schema::BaseConductanceBasedSynapse
    {
      public:
      // tauDecay
      //
      typedef ::neurona::schema::Nml2Quantity_time TauDecayType;
      typedef ::xsd::cxx::tree::traits< TauDecayType, char > TauDecayTraits;

      const TauDecayType&
      tauDecay () const;

      TauDecayType&
      tauDecay ();

      void
      setTauDecay (const TauDecayType& x);

      void
      setTauDecay (::std::unique_ptr< TauDecayType > p);

      // Constructors.
      //
      ExpOneSynapse (const IdType&,
                     const GbaseType&,
                     const ErevType&,
                     const TauDecayType&);

      ExpOneSynapse (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      ExpOneSynapse (const ExpOneSynapse& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual ExpOneSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ExpOneSynapse&
      operator= (const ExpOneSynapse& x);

      virtual 
      ~ExpOneSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TauDecayType > tauDecay_;
    };

    class ExpTwoSynapse: public ::neurona::schema::BaseConductanceBasedSynapse
    {
      public:
      // tauDecay
      //
      typedef ::neurona::schema::Nml2Quantity_time TauDecayType;
      typedef ::xsd::cxx::tree::traits< TauDecayType, char > TauDecayTraits;

      const TauDecayType&
      tauDecay () const;

      TauDecayType&
      tauDecay ();

      void
      setTauDecay (const TauDecayType& x);

      void
      setTauDecay (::std::unique_ptr< TauDecayType > p);

      // tauRise
      //
      typedef ::neurona::schema::Nml2Quantity_time TauRiseType;
      typedef ::xsd::cxx::tree::traits< TauRiseType, char > TauRiseTraits;

      const TauRiseType&
      tauRise () const;

      TauRiseType&
      tauRise ();

      void
      setTauRise (const TauRiseType& x);

      void
      setTauRise (::std::unique_ptr< TauRiseType > p);

      // Constructors.
      //
      ExpTwoSynapse (const IdType&,
                     const GbaseType&,
                     const ErevType&,
                     const TauDecayType&,
                     const TauRiseType&);

      ExpTwoSynapse (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      ExpTwoSynapse (const ExpTwoSynapse& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual ExpTwoSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ExpTwoSynapse&
      operator= (const ExpTwoSynapse& x);

      virtual 
      ~ExpTwoSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TauDecayType > tauDecay_;
      ::xsd::cxx::tree::one< TauRiseType > tauRise_;
    };

    class BlockingPlasticSynapse: public ::neurona::schema::ExpTwoSynapse
    {
      public:
      // plasticityMechanism
      //
      typedef ::neurona::schema::PlasticityMechanism PlasticityMechanismType;
      typedef ::xsd::cxx::tree::optional< PlasticityMechanismType > PlasticityMechanismOptional;
      typedef ::xsd::cxx::tree::traits< PlasticityMechanismType, char > PlasticityMechanismTraits;

      const PlasticityMechanismOptional&
      plasticityMechanism () const;

      PlasticityMechanismOptional&
      plasticityMechanism ();

      void
      setPlasticityMechanism (const PlasticityMechanismType& x);

      void
      setPlasticityMechanism (const PlasticityMechanismOptional& x);

      void
      setPlasticityMechanism (::std::unique_ptr< PlasticityMechanismType > p);

      // blockMechanism
      //
      typedef ::neurona::schema::BlockMechanism BlockMechanismType;
      typedef ::xsd::cxx::tree::optional< BlockMechanismType > BlockMechanismOptional;
      typedef ::xsd::cxx::tree::traits< BlockMechanismType, char > BlockMechanismTraits;

      const BlockMechanismOptional&
      blockMechanism () const;

      BlockMechanismOptional&
      blockMechanism ();

      void
      setBlockMechanism (const BlockMechanismType& x);

      void
      setBlockMechanism (const BlockMechanismOptional& x);

      void
      setBlockMechanism (::std::unique_ptr< BlockMechanismType > p);

      // Constructors.
      //
      BlockingPlasticSynapse (const IdType&,
                              const GbaseType&,
                              const ErevType&,
                              const TauDecayType&,
                              const TauRiseType&);

      BlockingPlasticSynapse (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      BlockingPlasticSynapse (const BlockingPlasticSynapse& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      virtual BlockingPlasticSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BlockingPlasticSynapse&
      operator= (const BlockingPlasticSynapse& x);

      virtual 
      ~BlockingPlasticSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      PlasticityMechanismOptional plasticityMechanism_;
      BlockMechanismOptional blockMechanism_;
    };

    class BlockTypes: public ::xml_schema::String
    {
      public:
      enum Value
      {
        voltageConcDepBlockMechanism
      };

      BlockTypes (Value v);

      BlockTypes (const char* v);

      BlockTypes (const ::std::string& v);

      BlockTypes (const ::xml_schema::String& v);

      BlockTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      BlockTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      BlockTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      BlockTypes (const BlockTypes& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual BlockTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BlockTypes&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_BlockTypes_convert ();
      }

      protected:
      Value
      _xsd_BlockTypes_convert () const;

      public:
      static const char* const _xsd_BlockTypes_literals_[1];
      static const Value _xsd_BlockTypes_indexes_[1];
    };

    class BlockMechanism: public ::xml_schema::Type
    {
      public:
      // type
      //
      typedef ::neurona::schema::BlockTypes TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // species
      //
      typedef ::neurona::schema::NmlId SpeciesType;
      typedef ::xsd::cxx::tree::traits< SpeciesType, char > SpeciesTraits;

      const SpeciesType&
      species () const;

      SpeciesType&
      species ();

      void
      setSpecies (const SpeciesType& x);

      void
      setSpecies (::std::unique_ptr< SpeciesType > p);

      // blockConcentration
      //
      typedef ::neurona::schema::Nml2Quantity_concentration BlockConcentrationType;
      typedef ::xsd::cxx::tree::traits< BlockConcentrationType, char > BlockConcentrationTraits;

      const BlockConcentrationType&
      blockConcentration () const;

      BlockConcentrationType&
      blockConcentration ();

      void
      setBlockConcentration (const BlockConcentrationType& x);

      void
      setBlockConcentration (::std::unique_ptr< BlockConcentrationType > p);

      // scalingConc
      //
      typedef ::neurona::schema::Nml2Quantity_concentration ScalingConcType;
      typedef ::xsd::cxx::tree::traits< ScalingConcType, char > ScalingConcTraits;

      const ScalingConcType&
      scalingConc () const;

      ScalingConcType&
      scalingConc ();

      void
      setScalingConc (const ScalingConcType& x);

      void
      setScalingConc (::std::unique_ptr< ScalingConcType > p);

      // scalingVolt
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ScalingVoltType;
      typedef ::xsd::cxx::tree::traits< ScalingVoltType, char > ScalingVoltTraits;

      const ScalingVoltType&
      scalingVolt () const;

      ScalingVoltType&
      scalingVolt ();

      void
      setScalingVolt (const ScalingVoltType& x);

      void
      setScalingVolt (::std::unique_ptr< ScalingVoltType > p);

      // Constructors.
      //
      BlockMechanism (const TypeType&,
                      const SpeciesType&,
                      const BlockConcentrationType&,
                      const ScalingConcType&,
                      const ScalingVoltType&);

      BlockMechanism (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      BlockMechanism (const BlockMechanism& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual BlockMechanism*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BlockMechanism&
      operator= (const BlockMechanism& x);

      virtual 
      ~BlockMechanism ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      ::xsd::cxx::tree::one< SpeciesType > species_;
      ::xsd::cxx::tree::one< BlockConcentrationType > blockConcentration_;
      ::xsd::cxx::tree::one< ScalingConcType > scalingConc_;
      ::xsd::cxx::tree::one< ScalingVoltType > scalingVolt_;
    };

    class PlasticityTypes: public ::xml_schema::String
    {
      public:
      enum Value
      {
        tsodyksMarkramDepMechanism,
        tsodyksMarkramDepFacMechanism
      };

      PlasticityTypes (Value v);

      PlasticityTypes (const char* v);

      PlasticityTypes (const ::std::string& v);

      PlasticityTypes (const ::xml_schema::String& v);

      PlasticityTypes (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      PlasticityTypes (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      PlasticityTypes (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      PlasticityTypes (const PlasticityTypes& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual PlasticityTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      PlasticityTypes&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_PlasticityTypes_convert ();
      }

      protected:
      Value
      _xsd_PlasticityTypes_convert () const;

      public:
      static const char* const _xsd_PlasticityTypes_literals_[2];
      static const Value _xsd_PlasticityTypes_indexes_[2];
    };

    class PlasticityMechanism: public ::xml_schema::Type
    {
      public:
      // type
      //
      typedef ::neurona::schema::PlasticityTypes TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // initReleaseProb
      //
      typedef ::neurona::schema::ZeroToOne InitReleaseProbType;
      typedef ::xsd::cxx::tree::traits< InitReleaseProbType, char > InitReleaseProbTraits;

      const InitReleaseProbType&
      initReleaseProb () const;

      InitReleaseProbType&
      initReleaseProb ();

      void
      setInitReleaseProb (const InitReleaseProbType& x);

      void
      setInitReleaseProb (::std::unique_ptr< InitReleaseProbType > p);

      // tauRec
      //
      typedef ::neurona::schema::Nml2Quantity_time TauRecType;
      typedef ::xsd::cxx::tree::traits< TauRecType, char > TauRecTraits;

      const TauRecType&
      tauRec () const;

      TauRecType&
      tauRec ();

      void
      setTauRec (const TauRecType& x);

      void
      setTauRec (::std::unique_ptr< TauRecType > p);

      // tauFac
      //
      typedef ::neurona::schema::Nml2Quantity_time TauFacType;
      typedef ::xsd::cxx::tree::optional< TauFacType > TauFacOptional;
      typedef ::xsd::cxx::tree::traits< TauFacType, char > TauFacTraits;

      const TauFacOptional&
      tauFac () const;

      TauFacOptional&
      tauFac ();

      void
      setTauFac (const TauFacType& x);

      void
      setTauFac (const TauFacOptional& x);

      void
      setTauFac (::std::unique_ptr< TauFacType > p);

      // Constructors.
      //
      PlasticityMechanism (const TypeType&,
                           const InitReleaseProbType&,
                           const TauRecType&);

      PlasticityMechanism (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      PlasticityMechanism (const PlasticityMechanism& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      virtual PlasticityMechanism*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      PlasticityMechanism&
      operator= (const PlasticityMechanism& x);

      virtual 
      ~PlasticityMechanism ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      ::xsd::cxx::tree::one< InitReleaseProbType > initReleaseProb_;
      ::xsd::cxx::tree::one< TauRecType > tauRec_;
      TauFacOptional tauFac_;
    };

    class BaseCell: public ::neurona::schema::Standalone
    {
      public:
      // Constructors.
      //
      BaseCell (const IdType&);

      BaseCell (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      BaseCell (const BaseCell& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual BaseCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~BaseCell ();
    };

    class IafTauCell: public ::neurona::schema::BaseCell
    {
      public:
      // leakReversal
      //
      typedef ::neurona::schema::Nml2Quantity_voltage LeakReversalType;
      typedef ::xsd::cxx::tree::traits< LeakReversalType, char > LeakReversalTraits;

      const LeakReversalType&
      leakReversal () const;

      LeakReversalType&
      leakReversal ();

      void
      setLeakReversal (const LeakReversalType& x);

      void
      setLeakReversal (::std::unique_ptr< LeakReversalType > p);

      // thresh
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ThreshType;
      typedef ::xsd::cxx::tree::traits< ThreshType, char > ThreshTraits;

      const ThreshType&
      thresh () const;

      ThreshType&
      thresh ();

      void
      setThresh (const ThreshType& x);

      void
      setThresh (::std::unique_ptr< ThreshType > p);

      // reset
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ResetType;
      typedef ::xsd::cxx::tree::traits< ResetType, char > ResetTraits;

      const ResetType&
      reset () const;

      ResetType&
      reset ();

      void
      setReset (const ResetType& x);

      void
      setReset (::std::unique_ptr< ResetType > p);

      // tau
      //
      typedef ::neurona::schema::Nml2Quantity_time TauType;
      typedef ::xsd::cxx::tree::traits< TauType, char > TauTraits;

      const TauType&
      tau () const;

      TauType&
      tau ();

      void
      setTau (const TauType& x);

      void
      setTau (::std::unique_ptr< TauType > p);

      // Constructors.
      //
      IafTauCell (const IdType&,
                  const LeakReversalType&,
                  const ThreshType&,
                  const ResetType&,
                  const TauType&);

      IafTauCell (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      IafTauCell (const IafTauCell& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual IafTauCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IafTauCell&
      operator= (const IafTauCell& x);

      virtual 
      ~IafTauCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< LeakReversalType > leakReversal_;
      ::xsd::cxx::tree::one< ThreshType > thresh_;
      ::xsd::cxx::tree::one< ResetType > reset_;
      ::xsd::cxx::tree::one< TauType > tau_;
    };

    class IafTauRefCell: public ::neurona::schema::IafTauCell
    {
      public:
      // refract
      //
      typedef ::neurona::schema::Nml2Quantity_time RefractType;
      typedef ::xsd::cxx::tree::traits< RefractType, char > RefractTraits;

      const RefractType&
      refract () const;

      RefractType&
      refract ();

      void
      setRefract (const RefractType& x);

      void
      setRefract (::std::unique_ptr< RefractType > p);

      // Constructors.
      //
      IafTauRefCell (const IdType&,
                     const LeakReversalType&,
                     const ThreshType&,
                     const ResetType&,
                     const TauType&,
                     const RefractType&);

      IafTauRefCell (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      IafTauRefCell (const IafTauRefCell& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual IafTauRefCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IafTauRefCell&
      operator= (const IafTauRefCell& x);

      virtual 
      ~IafTauRefCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefractType > refract_;
    };

    class IafCell: public ::neurona::schema::BaseCell
    {
      public:
      // leakReversal
      //
      typedef ::neurona::schema::Nml2Quantity_voltage LeakReversalType;
      typedef ::xsd::cxx::tree::traits< LeakReversalType, char > LeakReversalTraits;

      const LeakReversalType&
      leakReversal () const;

      LeakReversalType&
      leakReversal ();

      void
      setLeakReversal (const LeakReversalType& x);

      void
      setLeakReversal (::std::unique_ptr< LeakReversalType > p);

      // thresh
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ThreshType;
      typedef ::xsd::cxx::tree::traits< ThreshType, char > ThreshTraits;

      const ThreshType&
      thresh () const;

      ThreshType&
      thresh ();

      void
      setThresh (const ThreshType& x);

      void
      setThresh (::std::unique_ptr< ThreshType > p);

      // reset
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ResetType;
      typedef ::xsd::cxx::tree::traits< ResetType, char > ResetTraits;

      const ResetType&
      reset () const;

      ResetType&
      reset ();

      void
      setReset (const ResetType& x);

      void
      setReset (::std::unique_ptr< ResetType > p);

      // C
      //
      typedef ::neurona::schema::Nml2Quantity_capacitance CType;
      typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

      const CType&
      c () const;

      CType&
      c ();

      void
      setC (const CType& x);

      void
      setC (::std::unique_ptr< CType > p);

      // leakConductance
      //
      typedef ::neurona::schema::Nml2Quantity_conductance LeakConductanceType;
      typedef ::xsd::cxx::tree::traits< LeakConductanceType, char > LeakConductanceTraits;

      const LeakConductanceType&
      leakConductance () const;

      LeakConductanceType&
      leakConductance ();

      void
      setLeakConductance (const LeakConductanceType& x);

      void
      setLeakConductance (::std::unique_ptr< LeakConductanceType > p);

      // Constructors.
      //
      IafCell (const IdType&,
               const LeakReversalType&,
               const ThreshType&,
               const ResetType&,
               const CType&,
               const LeakConductanceType&);

      IafCell (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      IafCell (const IafCell& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual IafCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IafCell&
      operator= (const IafCell& x);

      virtual 
      ~IafCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< LeakReversalType > leakReversal_;
      ::xsd::cxx::tree::one< ThreshType > thresh_;
      ::xsd::cxx::tree::one< ResetType > reset_;
      ::xsd::cxx::tree::one< CType > C_;
      ::xsd::cxx::tree::one< LeakConductanceType > leakConductance_;
    };

    class IafRefCell: public ::neurona::schema::IafCell
    {
      public:
      // refract
      //
      typedef ::neurona::schema::Nml2Quantity_time RefractType;
      typedef ::xsd::cxx::tree::traits< RefractType, char > RefractTraits;

      const RefractType&
      refract () const;

      RefractType&
      refract ();

      void
      setRefract (const RefractType& x);

      void
      setRefract (::std::unique_ptr< RefractType > p);

      // Constructors.
      //
      IafRefCell (const IdType&,
                  const LeakReversalType&,
                  const ThreshType&,
                  const ResetType&,
                  const CType&,
                  const LeakConductanceType&,
                  const RefractType&);

      IafRefCell (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      IafRefCell (const IafRefCell& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual IafRefCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IafRefCell&
      operator= (const IafRefCell& x);

      virtual 
      ~IafRefCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefractType > refract_;
    };

    class IzhikevichCell: public ::neurona::schema::BaseCell
    {
      public:
      // v0
      //
      typedef ::neurona::schema::Nml2Quantity_voltage V0Type;
      typedef ::xsd::cxx::tree::traits< V0Type, char > V0Traits;

      const V0Type&
      v0 () const;

      V0Type&
      v0 ();

      void
      setV0 (const V0Type& x);

      void
      setV0 (::std::unique_ptr< V0Type > p);

      // thresh
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ThreshType;
      typedef ::xsd::cxx::tree::traits< ThreshType, char > ThreshTraits;

      const ThreshType&
      thresh () const;

      ThreshType&
      thresh ();

      void
      setThresh (const ThreshType& x);

      void
      setThresh (::std::unique_ptr< ThreshType > p);

      // a
      //
      typedef ::neurona::schema::Nml2Quantity_none AType;
      typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

      const AType&
      a () const;

      AType&
      a ();

      void
      setA (const AType& x);

      void
      setA (::std::unique_ptr< AType > p);

      // b
      //
      typedef ::neurona::schema::Nml2Quantity_none BType;
      typedef ::xsd::cxx::tree::traits< BType, char > BTraits;

      const BType&
      b () const;

      BType&
      b ();

      void
      setB (const BType& x);

      void
      setB (::std::unique_ptr< BType > p);

      // c
      //
      typedef ::neurona::schema::Nml2Quantity_none CType;
      typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

      const CType&
      c () const;

      CType&
      c ();

      void
      setC (const CType& x);

      void
      setC (::std::unique_ptr< CType > p);

      // d
      //
      typedef ::neurona::schema::Nml2Quantity_none DType;
      typedef ::xsd::cxx::tree::traits< DType, char > DTraits;

      const DType&
      d () const;

      DType&
      d ();

      void
      setD (const DType& x);

      void
      setD (::std::unique_ptr< DType > p);

      // Constructors.
      //
      IzhikevichCell (const IdType&,
                      const V0Type&,
                      const ThreshType&,
                      const AType&,
                      const BType&,
                      const CType&,
                      const DType&);

      IzhikevichCell (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      IzhikevichCell (const IzhikevichCell& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual IzhikevichCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IzhikevichCell&
      operator= (const IzhikevichCell& x);

      virtual 
      ~IzhikevichCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< V0Type > v0_;
      ::xsd::cxx::tree::one< ThreshType > thresh_;
      ::xsd::cxx::tree::one< AType > a_;
      ::xsd::cxx::tree::one< BType > b_;
      ::xsd::cxx::tree::one< CType > c_;
      ::xsd::cxx::tree::one< DType > d_;
    };

    class AdExIaFCell: public ::neurona::schema::BaseCell
    {
      public:
      // C
      //
      typedef ::neurona::schema::Nml2Quantity_capacitance CType;
      typedef ::xsd::cxx::tree::traits< CType, char > CTraits;

      const CType&
      c () const;

      CType&
      c ();

      void
      setC (const CType& x);

      void
      setC (::std::unique_ptr< CType > p);

      // gL
      //
      typedef ::neurona::schema::Nml2Quantity_conductance GLType;
      typedef ::xsd::cxx::tree::traits< GLType, char > GLTraits;

      const GLType&
      gL () const;

      GLType&
      gL ();

      void
      setGL (const GLType& x);

      void
      setGL (::std::unique_ptr< GLType > p);

      // EL
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ELType;
      typedef ::xsd::cxx::tree::traits< ELType, char > ELTraits;

      const ELType&
      eL () const;

      ELType&
      eL ();

      void
      setEL (const ELType& x);

      void
      setEL (::std::unique_ptr< ELType > p);

      // reset
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ResetType;
      typedef ::xsd::cxx::tree::traits< ResetType, char > ResetTraits;

      const ResetType&
      reset () const;

      ResetType&
      reset ();

      void
      setReset (const ResetType& x);

      void
      setReset (::std::unique_ptr< ResetType > p);

      // VT
      //
      typedef ::neurona::schema::Nml2Quantity_voltage VTType;
      typedef ::xsd::cxx::tree::traits< VTType, char > VTTraits;

      const VTType&
      vT () const;

      VTType&
      vT ();

      void
      setVT (const VTType& x);

      void
      setVT (::std::unique_ptr< VTType > p);

      // thresh
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ThreshType;
      typedef ::xsd::cxx::tree::traits< ThreshType, char > ThreshTraits;

      const ThreshType&
      thresh () const;

      ThreshType&
      thresh ();

      void
      setThresh (const ThreshType& x);

      void
      setThresh (::std::unique_ptr< ThreshType > p);

      // delT
      //
      typedef ::neurona::schema::Nml2Quantity_voltage DelTType;
      typedef ::xsd::cxx::tree::traits< DelTType, char > DelTTraits;

      const DelTType&
      delT () const;

      DelTType&
      delT ();

      void
      setDelT (const DelTType& x);

      void
      setDelT (::std::unique_ptr< DelTType > p);

      // tauw
      //
      typedef ::neurona::schema::Nml2Quantity_time TauwType;
      typedef ::xsd::cxx::tree::traits< TauwType, char > TauwTraits;

      const TauwType&
      tauw () const;

      TauwType&
      tauw ();

      void
      setTauw (const TauwType& x);

      void
      setTauw (::std::unique_ptr< TauwType > p);

      // refract
      //
      typedef ::neurona::schema::Nml2Quantity_time RefractType;
      typedef ::xsd::cxx::tree::traits< RefractType, char > RefractTraits;

      const RefractType&
      refract () const;

      RefractType&
      refract ();

      void
      setRefract (const RefractType& x);

      void
      setRefract (::std::unique_ptr< RefractType > p);

      // a
      //
      typedef ::neurona::schema::Nml2Quantity_conductance AType;
      typedef ::xsd::cxx::tree::traits< AType, char > ATraits;

      const AType&
      a () const;

      AType&
      a ();

      void
      setA (const AType& x);

      void
      setA (::std::unique_ptr< AType > p);

      // b
      //
      typedef ::neurona::schema::Nml2Quantity_current BType;
      typedef ::xsd::cxx::tree::traits< BType, char > BTraits;

      const BType&
      b () const;

      BType&
      b ();

      void
      setB (const BType& x);

      void
      setB (::std::unique_ptr< BType > p);

      // Constructors.
      //
      AdExIaFCell (const IdType&,
                   const CType&,
                   const GLType&,
                   const ELType&,
                   const ResetType&,
                   const VTType&,
                   const ThreshType&,
                   const DelTType&,
                   const TauwType&,
                   const RefractType&,
                   const AType&,
                   const BType&);

      AdExIaFCell (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      AdExIaFCell (const AdExIaFCell& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual AdExIaFCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      AdExIaFCell&
      operator= (const AdExIaFCell& x);

      virtual 
      ~AdExIaFCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< CType > C_;
      ::xsd::cxx::tree::one< GLType > gL_;
      ::xsd::cxx::tree::one< ELType > EL_;
      ::xsd::cxx::tree::one< ResetType > reset_;
      ::xsd::cxx::tree::one< VTType > VT_;
      ::xsd::cxx::tree::one< ThreshType > thresh_;
      ::xsd::cxx::tree::one< DelTType > delT_;
      ::xsd::cxx::tree::one< TauwType > tauw_;
      ::xsd::cxx::tree::one< RefractType > refract_;
      ::xsd::cxx::tree::one< AType > a_;
      ::xsd::cxx::tree::one< BType > b_;
    };

    class FitzHughNagumoCell: public ::neurona::schema::BaseCell
    {
      public:
      // I
      //
      typedef ::neurona::schema::Nml2Quantity_none IType;
      typedef ::xsd::cxx::tree::traits< IType, char > ITraits;

      const IType&
      i () const;

      IType&
      i ();

      void
      setI (const IType& x);

      void
      setI (::std::unique_ptr< IType > p);

      // Constructors.
      //
      FitzHughNagumoCell (const IdType&,
                          const IType&);

      FitzHughNagumoCell (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      FitzHughNagumoCell (const FitzHughNagumoCell& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual FitzHughNagumoCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      FitzHughNagumoCell&
      operator= (const FitzHughNagumoCell& x);

      virtual 
      ~FitzHughNagumoCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IType > I_;
    };

    class Cell: public ::neurona::schema::BaseCell
    {
      public:
      // morphology
      //
      typedef ::neurona::schema::Morphology MorphologyType;
      typedef ::xsd::cxx::tree::optional< MorphologyType > MorphologyOptional;
      typedef ::xsd::cxx::tree::traits< MorphologyType, char > MorphologyTraits;

      const MorphologyOptional&
      morphology () const;

      MorphologyOptional&
      morphology ();

      void
      setMorphology (const MorphologyType& x);

      void
      setMorphology (const MorphologyOptional& x);

      void
      setMorphology (::std::unique_ptr< MorphologyType > p);

      // biophysicalProperties
      //
      typedef ::neurona::schema::BiophysicalProperties BiophysicalPropertiesType;
      typedef ::xsd::cxx::tree::optional< BiophysicalPropertiesType > BiophysicalPropertiesOptional;
      typedef ::xsd::cxx::tree::traits< BiophysicalPropertiesType, char > BiophysicalPropertiesTraits;

      const BiophysicalPropertiesOptional&
      biophysicalProperties () const;

      BiophysicalPropertiesOptional&
      biophysicalProperties ();

      void
      setBiophysicalProperties (const BiophysicalPropertiesType& x);

      void
      setBiophysicalProperties (const BiophysicalPropertiesOptional& x);

      void
      setBiophysicalProperties (::std::unique_ptr< BiophysicalPropertiesType > p);

      // morphology
      //
      typedef ::neurona::schema::NmlId Morphology1Type;
      typedef ::xsd::cxx::tree::traits< Morphology1Type, char > Morphology1Traits;

      const Morphology1Type&
      morphology1 () const;

      Morphology1Type&
      morphology1 ();

      void
      setMorphology1 (const Morphology1Type& x);

      void
      setMorphology1 (::std::unique_ptr< Morphology1Type > p);

      static const Morphology1Type&
      morphology1DefaultValue ();

      // biophysicalProperties
      //
      typedef ::neurona::schema::NmlId BiophysicalProperties1Type;
      typedef ::xsd::cxx::tree::traits< BiophysicalProperties1Type, char > BiophysicalProperties1Traits;

      const BiophysicalProperties1Type&
      biophysicalProperties1 () const;

      BiophysicalProperties1Type&
      biophysicalProperties1 ();

      void
      setBiophysicalProperties1 (const BiophysicalProperties1Type& x);

      void
      setBiophysicalProperties1 (::std::unique_ptr< BiophysicalProperties1Type > p);

      static const BiophysicalProperties1Type&
      biophysicalProperties1DefaultValue ();

      // Constructors.
      //
      Cell (const IdType&);

      Cell (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      Cell (const Cell& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      virtual Cell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Cell&
      operator= (const Cell& x);

      virtual 
      ~Cell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      MorphologyOptional morphology_;
      BiophysicalPropertiesOptional biophysicalProperties_;
      ::xsd::cxx::tree::one< Morphology1Type > morphology1_;
      static const Morphology1Type morphology1_default_value_;
      ::xsd::cxx::tree::one< BiophysicalProperties1Type > biophysicalProperties1_;
      static const BiophysicalProperties1Type biophysicalProperties1_default_value_;
    };

    class Morphology: public ::neurona::schema::Standalone
    {
      public:
      // segment
      //
      typedef ::neurona::schema::Segment SegmentType;
      typedef ::xsd::cxx::tree::sequence< SegmentType > SegmentSequence;
      typedef SegmentSequence::iterator SegmentIterator;
      typedef SegmentSequence::const_iterator SegmentConstIterator;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentSequence&
      segments () const;

      SegmentSequence&
      segments ();

      void
      setSegments (const SegmentSequence& s);

      // segmentGroup
      //
      typedef ::neurona::schema::SegmentGroup SegmentGroupType;
      typedef ::xsd::cxx::tree::sequence< SegmentGroupType > SegmentGroupSequence;
      typedef SegmentGroupSequence::iterator SegmentGroupIterator;
      typedef SegmentGroupSequence::const_iterator SegmentGroupConstIterator;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupSequence&
      segmentGroups () const;

      SegmentGroupSequence&
      segmentGroups ();

      void
      setSegmentGroups (const SegmentGroupSequence& s);

      // Constructors.
      //
      Morphology (const IdType&);

      Morphology (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      Morphology (const Morphology& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual Morphology*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Morphology&
      operator= (const Morphology& x);

      virtual 
      ~Morphology ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SegmentSequence segment_;
      SegmentGroupSequence segmentGroup_;
    };

    class Segment: public ::neurona::schema::BaseWithoutId
    {
      public:
      // parent
      //
      typedef ::neurona::schema::SegmentParent ParentType;
      typedef ::xsd::cxx::tree::optional< ParentType > ParentOptional;
      typedef ::xsd::cxx::tree::traits< ParentType, char > ParentTraits;

      const ParentOptional&
      parent () const;

      ParentOptional&
      parent ();

      void
      setParent (const ParentType& x);

      void
      setParent (const ParentOptional& x);

      void
      setParent (::std::unique_ptr< ParentType > p);

      // proximal
      //
      typedef ::neurona::schema::Point3DWithDiam ProximalType;
      typedef ::xsd::cxx::tree::optional< ProximalType > ProximalOptional;
      typedef ::xsd::cxx::tree::traits< ProximalType, char > ProximalTraits;

      const ProximalOptional&
      proximal () const;

      ProximalOptional&
      proximal ();

      void
      setProximal (const ProximalType& x);

      void
      setProximal (const ProximalOptional& x);

      void
      setProximal (::std::unique_ptr< ProximalType > p);

      // distal
      //
      typedef ::neurona::schema::Point3DWithDiam DistalType;
      typedef ::xsd::cxx::tree::traits< DistalType, char > DistalTraits;

      const DistalType&
      distal () const;

      DistalType&
      distal ();

      void
      setDistal (const DistalType& x);

      void
      setDistal (::std::unique_ptr< DistalType > p);

      // id
      //
      typedef ::neurona::schema::SegmentId IdType;
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      const IdType&
      id () const;

      IdType&
      id ();

      void
      setId (const IdType& x);

      void
      setId (::std::unique_ptr< IdType > p);

      // name
      //
      typedef ::xml_schema::String NameType;
      typedef ::xsd::cxx::tree::optional< NameType > NameOptional;
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      const NameOptional&
      name () const;

      NameOptional&
      name ();

      void
      setName (const NameType& x);

      void
      setName (const NameOptional& x);

      void
      setName (::std::unique_ptr< NameType > p);

      // Constructors.
      //
      Segment (const DistalType&,
               const IdType&);

      Segment (::std::unique_ptr< DistalType >,
               const IdType&);

      Segment (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      Segment (const Segment& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual Segment*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Segment&
      operator= (const Segment& x);

      virtual 
      ~Segment ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ParentOptional parent_;
      ProximalOptional proximal_;
      ::xsd::cxx::tree::one< DistalType > distal_;
      ::xsd::cxx::tree::one< IdType > id_;
      NameOptional name_;
    };

    class SegmentParent: public ::xml_schema::Type
    {
      public:
      // segment
      //
      typedef ::neurona::schema::SegmentId SegmentType;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentType&
      segment () const;

      SegmentType&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // fractionAlong
      //
      typedef ::neurona::schema::ZeroToOne FractionAlongType;
      typedef ::xsd::cxx::tree::traits< FractionAlongType, char > FractionAlongTraits;

      const FractionAlongType&
      fractionAlong () const;

      FractionAlongType&
      fractionAlong ();

      void
      setFractionAlong (const FractionAlongType& x);

      void
      setFractionAlong (::std::unique_ptr< FractionAlongType > p);

      static FractionAlongType
      fractionAlongDefaultValue ();

      // Constructors.
      //
      SegmentParent (const SegmentType&);

      SegmentParent (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      SegmentParent (const SegmentParent& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual SegmentParent*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SegmentParent&
      operator= (const SegmentParent& x);

      virtual 
      ~SegmentParent ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SegmentType > segment_;
      ::xsd::cxx::tree::one< FractionAlongType > fractionAlong_;
    };

    class Point3DWithDiam: public ::xml_schema::Type
    {
      public:
      // x
      //
      typedef ::xml_schema::Double XType;
      typedef ::xsd::cxx::tree::traits< XType, char, ::xsd::cxx::tree::schema_type::double_ > XTraits;

      const XType&
      x () const;

      XType&
      x ();

      void
      setX (const XType& x);

      // y
      //
      typedef ::xml_schema::Double YType;
      typedef ::xsd::cxx::tree::traits< YType, char, ::xsd::cxx::tree::schema_type::double_ > YTraits;

      const YType&
      y () const;

      YType&
      y ();

      void
      setY (const YType& x);

      // z
      //
      typedef ::xml_schema::Double ZType;
      typedef ::xsd::cxx::tree::traits< ZType, char, ::xsd::cxx::tree::schema_type::double_ > ZTraits;

      const ZType&
      z () const;

      ZType&
      z ();

      void
      setZ (const ZType& x);

      // diameter
      //
      typedef ::xml_schema::Double DiameterType;
      typedef ::xsd::cxx::tree::traits< DiameterType, char, ::xsd::cxx::tree::schema_type::double_ > DiameterTraits;

      const DiameterType&
      diameter () const;

      DiameterType&
      diameter ();

      void
      setDiameter (const DiameterType& x);

      // Constructors.
      //
      Point3DWithDiam (const XType&,
                       const YType&,
                       const ZType&,
                       const DiameterType&);

      Point3DWithDiam (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      Point3DWithDiam (const Point3DWithDiam& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual Point3DWithDiam*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Point3DWithDiam&
      operator= (const Point3DWithDiam& x);

      virtual 
      ~Point3DWithDiam ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< XType > x_;
      ::xsd::cxx::tree::one< YType > y_;
      ::xsd::cxx::tree::one< ZType > z_;
      ::xsd::cxx::tree::one< DiameterType > diameter_;
    };

    class SegmentGroup: public ::neurona::schema::Base
    {
      public:
      // notes
      //
      typedef ::neurona::schema::Notes NotesType;
      typedef ::xsd::cxx::tree::optional< NotesType > NotesOptional;
      typedef ::xsd::cxx::tree::traits< NotesType, char > NotesTraits;

      const NotesOptional&
      notes () const;

      NotesOptional&
      notes ();

      void
      setNotes (const NotesType& x);

      void
      setNotes (const NotesOptional& x);

      void
      setNotes (::std::unique_ptr< NotesType > p);

      // annotation
      //
      typedef ::neurona::schema::Annotation AnnotationType;
      typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
      typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

      const AnnotationOptional&
      annotation () const;

      AnnotationOptional&
      annotation ();

      void
      setAnnotation (const AnnotationType& x);

      void
      setAnnotation (const AnnotationOptional& x);

      void
      setAnnotation (::std::unique_ptr< AnnotationType > p);

      // member
      //
      typedef ::neurona::schema::Member MemberType;
      typedef ::xsd::cxx::tree::sequence< MemberType > MemberSequence;
      typedef MemberSequence::iterator MemberIterator;
      typedef MemberSequence::const_iterator MemberConstIterator;
      typedef ::xsd::cxx::tree::traits< MemberType, char > MemberTraits;

      const MemberSequence&
      members () const;

      MemberSequence&
      members ();

      void
      setMembers (const MemberSequence& s);

      // include
      //
      typedef ::neurona::schema::Include IncludeType;
      typedef ::xsd::cxx::tree::sequence< IncludeType > IncludeSequence;
      typedef IncludeSequence::iterator IncludeIterator;
      typedef IncludeSequence::const_iterator IncludeConstIterator;
      typedef ::xsd::cxx::tree::traits< IncludeType, char > IncludeTraits;

      const IncludeSequence&
      includes () const;

      IncludeSequence&
      includes ();

      void
      setIncludes (const IncludeSequence& s);

      // path
      //
      typedef ::neurona::schema::Path PathType;
      typedef ::xsd::cxx::tree::sequence< PathType > PathSequence;
      typedef PathSequence::iterator PathIterator;
      typedef PathSequence::const_iterator PathConstIterator;
      typedef ::xsd::cxx::tree::traits< PathType, char > PathTraits;

      const PathSequence&
      paths () const;

      PathSequence&
      paths ();

      void
      setPaths (const PathSequence& s);

      // subTree
      //
      typedef ::neurona::schema::SubTree SubTreeType;
      typedef ::xsd::cxx::tree::sequence< SubTreeType > SubTreeSequence;
      typedef SubTreeSequence::iterator SubTreeIterator;
      typedef SubTreeSequence::const_iterator SubTreeConstIterator;
      typedef ::xsd::cxx::tree::traits< SubTreeType, char > SubTreeTraits;

      const SubTreeSequence&
      subTrees () const;

      SubTreeSequence&
      subTrees ();

      void
      setSubTrees (const SubTreeSequence& s);

      // inhomogeneousParameter
      //
      typedef ::neurona::schema::InhomogeneousParameter InhomogeneousParameterType;
      typedef ::xsd::cxx::tree::sequence< InhomogeneousParameterType > InhomogeneousParameterSequence;
      typedef InhomogeneousParameterSequence::iterator InhomogeneousParameterIterator;
      typedef InhomogeneousParameterSequence::const_iterator InhomogeneousParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< InhomogeneousParameterType, char > InhomogeneousParameterTraits;

      const InhomogeneousParameterSequence&
      inhomogeneousParameters () const;

      InhomogeneousParameterSequence&
      inhomogeneousParameters ();

      void
      setInhomogeneousParameters (const InhomogeneousParameterSequence& s);

      // Constructors.
      //
      SegmentGroup (const IdType&);

      SegmentGroup (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      SegmentGroup (const SegmentGroup& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual SegmentGroup*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SegmentGroup&
      operator= (const SegmentGroup& x);

      virtual 
      ~SegmentGroup ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NotesOptional notes_;
      AnnotationOptional annotation_;
      MemberSequence member_;
      IncludeSequence include_;
      PathSequence path_;
      SubTreeSequence subTree_;
      InhomogeneousParameterSequence inhomogeneousParameter_;
    };

    class InhomogeneousParameter: public ::neurona::schema::Base
    {
      public:
      // proximal
      //
      typedef ::neurona::schema::ProximalDetails ProximalType;
      typedef ::xsd::cxx::tree::optional< ProximalType > ProximalOptional;
      typedef ::xsd::cxx::tree::traits< ProximalType, char > ProximalTraits;

      const ProximalOptional&
      proximal () const;

      ProximalOptional&
      proximal ();

      void
      setProximal (const ProximalType& x);

      void
      setProximal (const ProximalOptional& x);

      void
      setProximal (::std::unique_ptr< ProximalType > p);

      // distal
      //
      typedef ::neurona::schema::DistalDetails DistalType;
      typedef ::xsd::cxx::tree::optional< DistalType > DistalOptional;
      typedef ::xsd::cxx::tree::traits< DistalType, char > DistalTraits;

      const DistalOptional&
      distal () const;

      DistalOptional&
      distal ();

      void
      setDistal (const DistalType& x);

      void
      setDistal (const DistalOptional& x);

      void
      setDistal (::std::unique_ptr< DistalType > p);

      // variable
      //
      typedef ::xml_schema::String VariableType;
      typedef ::xsd::cxx::tree::traits< VariableType, char > VariableTraits;

      const VariableType&
      variable () const;

      VariableType&
      variable ();

      void
      setVariable (const VariableType& x);

      void
      setVariable (::std::unique_ptr< VariableType > p);

      // metric
      //
      typedef ::neurona::schema::Metric MetricType;
      typedef ::xsd::cxx::tree::traits< MetricType, char > MetricTraits;

      const MetricType&
      metric () const;

      MetricType&
      metric ();

      void
      setMetric (const MetricType& x);

      void
      setMetric (::std::unique_ptr< MetricType > p);

      // Constructors.
      //
      InhomogeneousParameter (const IdType&,
                              const VariableType&,
                              const MetricType&);

      InhomogeneousParameter (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      InhomogeneousParameter (const InhomogeneousParameter& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      virtual InhomogeneousParameter*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      InhomogeneousParameter&
      operator= (const InhomogeneousParameter& x);

      virtual 
      ~InhomogeneousParameter ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ProximalOptional proximal_;
      DistalOptional distal_;
      ::xsd::cxx::tree::one< VariableType > variable_;
      ::xsd::cxx::tree::one< MetricType > metric_;
    };

    class Metric: public ::xml_schema::String
    {
      public:
      enum Value
      {
        Path_Length_from_root
      };

      Metric (Value v);

      Metric (const char* v);

      Metric (const ::std::string& v);

      Metric (const ::xml_schema::String& v);

      Metric (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      Metric (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      Metric (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      Metric (const Metric& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual Metric*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Metric&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_Metric_convert ();
      }

      protected:
      Value
      _xsd_Metric_convert () const;

      public:
      static const char* const _xsd_Metric_literals_[1];
      static const Value _xsd_Metric_indexes_[1];
    };

    class ProximalDetails: public ::xml_schema::Type
    {
      public:
      // translationStart
      //
      typedef ::xml_schema::Double TranslationStartType;
      typedef ::xsd::cxx::tree::traits< TranslationStartType, char, ::xsd::cxx::tree::schema_type::double_ > TranslationStartTraits;

      const TranslationStartType&
      translationStart () const;

      TranslationStartType&
      translationStart ();

      void
      setTranslationStart (const TranslationStartType& x);

      // Constructors.
      //
      ProximalDetails (const TranslationStartType&);

      ProximalDetails (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      ProximalDetails (const ProximalDetails& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual ProximalDetails*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ProximalDetails&
      operator= (const ProximalDetails& x);

      virtual 
      ~ProximalDetails ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TranslationStartType > translationStart_;
    };

    class DistalDetails: public ::xml_schema::Type
    {
      public:
      // normalizationEnd
      //
      typedef ::xml_schema::Double NormalizationEndType;
      typedef ::xsd::cxx::tree::traits< NormalizationEndType, char, ::xsd::cxx::tree::schema_type::double_ > NormalizationEndTraits;

      const NormalizationEndType&
      normalizationEnd () const;

      NormalizationEndType&
      normalizationEnd ();

      void
      setNormalizationEnd (const NormalizationEndType& x);

      // Constructors.
      //
      DistalDetails (const NormalizationEndType&);

      DistalDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      DistalDetails (const DistalDetails& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual DistalDetails*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      DistalDetails&
      operator= (const DistalDetails& x);

      virtual 
      ~DistalDetails ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NormalizationEndType > normalizationEnd_;
    };

    class Member: public ::xml_schema::Type
    {
      public:
      // segment
      //
      typedef ::neurona::schema::SegmentId SegmentType;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentType&
      segment () const;

      SegmentType&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // Constructors.
      //
      Member (const SegmentType&);

      Member (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      Member (const Member& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual Member*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Member&
      operator= (const Member& x);

      virtual 
      ~Member ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SegmentType > segment_;
    };

    class Include: public ::xml_schema::Type
    {
      public:
      // segmentGroup
      //
      typedef ::neurona::schema::NmlId SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      // Constructors.
      //
      Include (const SegmentGroupType&);

      Include (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      Include (const Include& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual Include*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Include&
      operator= (const Include& x);

      virtual 
      ~Include ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
    };

    class Path: public ::xml_schema::Type
    {
      public:
      // from
      //
      typedef ::neurona::schema::SegmentEndPoint FromType;
      typedef ::xsd::cxx::tree::optional< FromType > FromOptional;
      typedef ::xsd::cxx::tree::traits< FromType, char > FromTraits;

      const FromOptional&
      from () const;

      FromOptional&
      from ();

      void
      setFrom (const FromType& x);

      void
      setFrom (const FromOptional& x);

      void
      setFrom (::std::unique_ptr< FromType > p);

      // to
      //
      typedef ::neurona::schema::SegmentEndPoint ToType;
      typedef ::xsd::cxx::tree::optional< ToType > ToOptional;
      typedef ::xsd::cxx::tree::traits< ToType, char > ToTraits;

      const ToOptional&
      to () const;

      ToOptional&
      to ();

      void
      setTo (const ToType& x);

      void
      setTo (const ToOptional& x);

      void
      setTo (::std::unique_ptr< ToType > p);

      // Constructors.
      //
      Path ();

      Path (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      Path (const Path& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      virtual Path*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Path&
      operator= (const Path& x);

      virtual 
      ~Path ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      FromOptional from_;
      ToOptional to_;
    };

    class SubTree: public ::xml_schema::Type
    {
      public:
      // from
      //
      typedef ::neurona::schema::SegmentEndPoint FromType;
      typedef ::xsd::cxx::tree::optional< FromType > FromOptional;
      typedef ::xsd::cxx::tree::traits< FromType, char > FromTraits;

      const FromOptional&
      from () const;

      FromOptional&
      from ();

      void
      setFrom (const FromType& x);

      void
      setFrom (const FromOptional& x);

      void
      setFrom (::std::unique_ptr< FromType > p);

      // to
      //
      typedef ::neurona::schema::SegmentEndPoint ToType;
      typedef ::xsd::cxx::tree::optional< ToType > ToOptional;
      typedef ::xsd::cxx::tree::traits< ToType, char > ToTraits;

      const ToOptional&
      to () const;

      ToOptional&
      to ();

      void
      setTo (const ToType& x);

      void
      setTo (const ToOptional& x);

      void
      setTo (::std::unique_ptr< ToType > p);

      // Constructors.
      //
      SubTree ();

      SubTree (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      SubTree (const SubTree& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual SubTree*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SubTree&
      operator= (const SubTree& x);

      virtual 
      ~SubTree ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      FromOptional from_;
      ToOptional to_;
    };

    class SegmentEndPoint: public ::xml_schema::Type
    {
      public:
      // segment
      //
      typedef ::neurona::schema::SegmentId SegmentType;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentType&
      segment () const;

      SegmentType&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // Constructors.
      //
      SegmentEndPoint (const SegmentType&);

      SegmentEndPoint (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      SegmentEndPoint (const SegmentEndPoint& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual SegmentEndPoint*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SegmentEndPoint&
      operator= (const SegmentEndPoint& x);

      virtual 
      ~SegmentEndPoint ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SegmentType > segment_;
    };

    class BiophysicalProperties: public ::neurona::schema::Standalone
    {
      public:
      // membraneProperties
      //
      typedef ::neurona::schema::MembraneProperties MembranePropertiesType;
      typedef ::xsd::cxx::tree::traits< MembranePropertiesType, char > MembranePropertiesTraits;

      const MembranePropertiesType&
      membraneProperties () const;

      MembranePropertiesType&
      membraneProperties ();

      void
      setMembraneProperties (const MembranePropertiesType& x);

      void
      setMembraneProperties (::std::unique_ptr< MembranePropertiesType > p);

      // intracellularProperties
      //
      typedef ::neurona::schema::IntracellularProperties IntracellularPropertiesType;
      typedef ::xsd::cxx::tree::optional< IntracellularPropertiesType > IntracellularPropertiesOptional;
      typedef ::xsd::cxx::tree::traits< IntracellularPropertiesType, char > IntracellularPropertiesTraits;

      const IntracellularPropertiesOptional&
      intracellularProperties () const;

      IntracellularPropertiesOptional&
      intracellularProperties ();

      void
      setIntracellularProperties (const IntracellularPropertiesType& x);

      void
      setIntracellularProperties (const IntracellularPropertiesOptional& x);

      void
      setIntracellularProperties (::std::unique_ptr< IntracellularPropertiesType > p);

      // extracellularProperties
      //
      typedef ::neurona::schema::ExtracellularProperties ExtracellularPropertiesType;
      typedef ::xsd::cxx::tree::optional< ExtracellularPropertiesType > ExtracellularPropertiesOptional;
      typedef ::xsd::cxx::tree::traits< ExtracellularPropertiesType, char > ExtracellularPropertiesTraits;

      const ExtracellularPropertiesOptional&
      extracellularProperties () const;

      ExtracellularPropertiesOptional&
      extracellularProperties ();

      void
      setExtracellularProperties (const ExtracellularPropertiesType& x);

      void
      setExtracellularProperties (const ExtracellularPropertiesOptional& x);

      void
      setExtracellularProperties (::std::unique_ptr< ExtracellularPropertiesType > p);

      // Constructors.
      //
      BiophysicalProperties (const IdType&,
                             const MembranePropertiesType&);

      BiophysicalProperties (const IdType&,
                             ::std::unique_ptr< MembranePropertiesType >);

      BiophysicalProperties (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      BiophysicalProperties (const BiophysicalProperties& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      virtual BiophysicalProperties*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BiophysicalProperties&
      operator= (const BiophysicalProperties& x);

      virtual 
      ~BiophysicalProperties ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< MembranePropertiesType > membraneProperties_;
      IntracellularPropertiesOptional intracellularProperties_;
      ExtracellularPropertiesOptional extracellularProperties_;
    };

    class MembraneProperties: public ::xml_schema::Type
    {
      public:
      // channelPopulation
      //
      typedef ::neurona::schema::ChannelPopulation ChannelPopulationType;
      typedef ::xsd::cxx::tree::sequence< ChannelPopulationType > ChannelPopulationSequence;
      typedef ChannelPopulationSequence::iterator ChannelPopulationIterator;
      typedef ChannelPopulationSequence::const_iterator ChannelPopulationConstIterator;
      typedef ::xsd::cxx::tree::traits< ChannelPopulationType, char > ChannelPopulationTraits;

      const ChannelPopulationSequence&
      channelPopulations () const;

      ChannelPopulationSequence&
      channelPopulations ();

      void
      setChannelPopulations (const ChannelPopulationSequence& s);

      // channelDensity
      //
      typedef ::neurona::schema::ChannelDensity ChannelDensityType;
      typedef ::xsd::cxx::tree::sequence< ChannelDensityType > ChannelDensitySequence;
      typedef ChannelDensitySequence::iterator ChannelDensityIterator;
      typedef ChannelDensitySequence::const_iterator ChannelDensityConstIterator;
      typedef ::xsd::cxx::tree::traits< ChannelDensityType, char > ChannelDensityTraits;

      const ChannelDensitySequence&
      channelDensitys () const;

      ChannelDensitySequence&
      channelDensitys ();

      void
      setChannelDensitys (const ChannelDensitySequence& s);

      // channelDensityNernst
      //
      typedef ::neurona::schema::ChannelDensityNernst ChannelDensityNernstType;
      typedef ::xsd::cxx::tree::sequence< ChannelDensityNernstType > ChannelDensityNernstSequence;
      typedef ChannelDensityNernstSequence::iterator ChannelDensityNernstIterator;
      typedef ChannelDensityNernstSequence::const_iterator ChannelDensityNernstConstIterator;
      typedef ::xsd::cxx::tree::traits< ChannelDensityNernstType, char > ChannelDensityNernstTraits;

      const ChannelDensityNernstSequence&
      channelDensityNernsts () const;

      ChannelDensityNernstSequence&
      channelDensityNernsts ();

      void
      setChannelDensityNernsts (const ChannelDensityNernstSequence& s);

      // channelDensityGHK
      //
      typedef ::neurona::schema::ChannelDensityGHK ChannelDensityGHKType;
      typedef ::xsd::cxx::tree::sequence< ChannelDensityGHKType > ChannelDensityGHKSequence;
      typedef ChannelDensityGHKSequence::iterator ChannelDensityGHKIterator;
      typedef ChannelDensityGHKSequence::const_iterator ChannelDensityGHKConstIterator;
      typedef ::xsd::cxx::tree::traits< ChannelDensityGHKType, char > ChannelDensityGHKTraits;

      const ChannelDensityGHKSequence&
      channelDensityGHKs () const;

      ChannelDensityGHKSequence&
      channelDensityGHKs ();

      void
      setChannelDensityGHKs (const ChannelDensityGHKSequence& s);

      // channelDensityNonUniform
      //
      typedef ::neurona::schema::ChannelDensityNonUniform ChannelDensityNonUniformType;
      typedef ::xsd::cxx::tree::sequence< ChannelDensityNonUniformType > ChannelDensityNonUniformSequence;
      typedef ChannelDensityNonUniformSequence::iterator ChannelDensityNonUniformIterator;
      typedef ChannelDensityNonUniformSequence::const_iterator ChannelDensityNonUniformConstIterator;
      typedef ::xsd::cxx::tree::traits< ChannelDensityNonUniformType, char > ChannelDensityNonUniformTraits;

      const ChannelDensityNonUniformSequence&
      channelDensityNonUniforms () const;

      ChannelDensityNonUniformSequence&
      channelDensityNonUniforms ();

      void
      setChannelDensityNonUniforms (const ChannelDensityNonUniformSequence& s);

      // channelDensityNonUniformNernst
      //
      typedef ::neurona::schema::ChannelDensityNonUniformNernst ChannelDensityNonUniformNernstType;
      typedef ::xsd::cxx::tree::sequence< ChannelDensityNonUniformNernstType > ChannelDensityNonUniformNernstSequence;
      typedef ChannelDensityNonUniformNernstSequence::iterator ChannelDensityNonUniformNernstIterator;
      typedef ChannelDensityNonUniformNernstSequence::const_iterator ChannelDensityNonUniformNernstConstIterator;
      typedef ::xsd::cxx::tree::traits< ChannelDensityNonUniformNernstType, char > ChannelDensityNonUniformNernstTraits;

      const ChannelDensityNonUniformNernstSequence&
      channelDensityNonUniformNernsts () const;

      ChannelDensityNonUniformNernstSequence&
      channelDensityNonUniformNernsts ();

      void
      setChannelDensityNonUniformNernsts (const ChannelDensityNonUniformNernstSequence& s);

      // spikeThresh
      //
      typedef ::neurona::schema::SpikeThresh SpikeThreshType;
      typedef ::xsd::cxx::tree::sequence< SpikeThreshType > SpikeThreshSequence;
      typedef SpikeThreshSequence::iterator SpikeThreshIterator;
      typedef SpikeThreshSequence::const_iterator SpikeThreshConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeThreshType, char > SpikeThreshTraits;

      const SpikeThreshSequence&
      spikeThreshs () const;

      SpikeThreshSequence&
      spikeThreshs ();

      void
      setSpikeThreshs (const SpikeThreshSequence& s);

      // specificCapacitance
      //
      typedef ::neurona::schema::SpecificCapacitance SpecificCapacitanceType;
      typedef ::xsd::cxx::tree::sequence< SpecificCapacitanceType > SpecificCapacitanceSequence;
      typedef SpecificCapacitanceSequence::iterator SpecificCapacitanceIterator;
      typedef SpecificCapacitanceSequence::const_iterator SpecificCapacitanceConstIterator;
      typedef ::xsd::cxx::tree::traits< SpecificCapacitanceType, char > SpecificCapacitanceTraits;

      const SpecificCapacitanceSequence&
      specificCapacitances () const;

      SpecificCapacitanceSequence&
      specificCapacitances ();

      void
      setSpecificCapacitances (const SpecificCapacitanceSequence& s);

      // initMembPotential
      //
      typedef ::neurona::schema::InitMembPotential InitMembPotentialType;
      typedef ::xsd::cxx::tree::sequence< InitMembPotentialType > InitMembPotentialSequence;
      typedef InitMembPotentialSequence::iterator InitMembPotentialIterator;
      typedef InitMembPotentialSequence::const_iterator InitMembPotentialConstIterator;
      typedef ::xsd::cxx::tree::traits< InitMembPotentialType, char > InitMembPotentialTraits;

      const InitMembPotentialSequence&
      initMembPotentials () const;

      InitMembPotentialSequence&
      initMembPotentials ();

      void
      setInitMembPotentials (const InitMembPotentialSequence& s);

      // Constructors.
      //
      MembraneProperties ();

      MembraneProperties (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      MembraneProperties (const MembraneProperties& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual MembraneProperties*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      MembraneProperties&
      operator= (const MembraneProperties& x);

      virtual 
      ~MembraneProperties ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ChannelPopulationSequence channelPopulation_;
      ChannelDensitySequence channelDensity_;
      ChannelDensityNernstSequence channelDensityNernst_;
      ChannelDensityGHKSequence channelDensityGHK_;
      ChannelDensityNonUniformSequence channelDensityNonUniform_;
      ChannelDensityNonUniformNernstSequence channelDensityNonUniformNernst_;
      SpikeThreshSequence spikeThresh_;
      SpecificCapacitanceSequence specificCapacitance_;
      InitMembPotentialSequence initMembPotential_;
    };

    class ValueAcrossSegOrSegGroup: public ::xml_schema::Type
    {
      public:
      // value
      //
      typedef ::neurona::schema::Nml2Quantity ValueType;
      typedef ::xsd::cxx::tree::optional< ValueType > ValueOptional;
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      const ValueOptional&
      value () const;

      ValueOptional&
      value ();

      void
      setValue (const ValueType& x);

      void
      setValue (const ValueOptional& x);

      void
      setValue (::std::unique_ptr< ValueType > p);

      // segmentGroup
      //
      typedef ::neurona::schema::NmlId SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      static const SegmentGroupType&
      segmentGroupDefaultValue ();

      // segment
      //
      typedef ::neurona::schema::NmlId SegmentType;
      typedef ::xsd::cxx::tree::optional< SegmentType > SegmentOptional;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentOptional&
      segment () const;

      SegmentOptional&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (const SegmentOptional& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // Constructors.
      //
      ValueAcrossSegOrSegGroup ();

      ValueAcrossSegOrSegGroup (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      ValueAcrossSegOrSegGroup (const ValueAcrossSegOrSegGroup& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual ValueAcrossSegOrSegGroup*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ValueAcrossSegOrSegGroup&
      operator= (const ValueAcrossSegOrSegGroup& x);

      virtual 
      ~ValueAcrossSegOrSegGroup ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ValueOptional value_;
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
      static const SegmentGroupType segmentGroup_default_value_;
      SegmentOptional segment_;
    };

    class SpikeThresh: public ::neurona::schema::ValueAcrossSegOrSegGroup
    {
      public:
      // Constructors.
      //
      SpikeThresh ();

      SpikeThresh (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      SpikeThresh (const SpikeThresh& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual SpikeThresh*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~SpikeThresh ();
    };

    class SpecificCapacitance: public ::neurona::schema::ValueAcrossSegOrSegGroup
    {
      public:
      // Constructors.
      //
      SpecificCapacitance ();

      SpecificCapacitance (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      SpecificCapacitance (const SpecificCapacitance& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      virtual SpecificCapacitance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~SpecificCapacitance ();
    };

    class InitMembPotential: public ::neurona::schema::ValueAcrossSegOrSegGroup
    {
      public:
      // Constructors.
      //
      InitMembPotential ();

      InitMembPotential (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      InitMembPotential (const InitMembPotential& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual InitMembPotential*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~InitMembPotential ();
    };

    class Resistivity: public ::neurona::schema::ValueAcrossSegOrSegGroup
    {
      public:
      // Constructors.
      //
      Resistivity ();

      Resistivity (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      Resistivity (const Resistivity& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual Resistivity*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~Resistivity ();
    };

    class ChannelPopulation: public ::neurona::schema::Base
    {
      public:
      // variableParameter
      //
      typedef ::neurona::schema::VariableParameter VariableParameterType;
      typedef ::xsd::cxx::tree::sequence< VariableParameterType > VariableParameterSequence;
      typedef VariableParameterSequence::iterator VariableParameterIterator;
      typedef VariableParameterSequence::const_iterator VariableParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< VariableParameterType, char > VariableParameterTraits;

      const VariableParameterSequence&
      variableParameters () const;

      VariableParameterSequence&
      variableParameters ();

      void
      setVariableParameters (const VariableParameterSequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::NmlId IonChannelType;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelType&
      ionChannel () const;

      IonChannelType&
      ionChannel ();

      void
      setIonChannel (const IonChannelType& x);

      void
      setIonChannel (::std::unique_ptr< IonChannelType > p);

      // number
      //
      typedef ::xml_schema::NonNegativeInteger NumberType;
      typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

      const NumberType&
      number () const;

      NumberType&
      number ();

      void
      setNumber (const NumberType& x);

      // erev
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ErevType;
      typedef ::xsd::cxx::tree::traits< ErevType, char > ErevTraits;

      const ErevType&
      erev () const;

      ErevType&
      erev ();

      void
      setErev (const ErevType& x);

      void
      setErev (::std::unique_ptr< ErevType > p);

      // segmentGroup
      //
      typedef ::neurona::schema::NmlId SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      static const SegmentGroupType&
      segmentGroupDefaultValue ();

      // segment
      //
      typedef ::neurona::schema::NmlId SegmentType;
      typedef ::xsd::cxx::tree::optional< SegmentType > SegmentOptional;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentOptional&
      segment () const;

      SegmentOptional&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (const SegmentOptional& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // Constructors.
      //
      ChannelPopulation (const IdType&,
                         const IonChannelType&,
                         const NumberType&,
                         const ErevType&);

      ChannelPopulation (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      ChannelPopulation (const ChannelPopulation& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual ChannelPopulation*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelPopulation&
      operator= (const ChannelPopulation& x);

      virtual 
      ~ChannelPopulation ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      VariableParameterSequence variableParameter_;
      ::xsd::cxx::tree::one< IonChannelType > ionChannel_;
      ::xsd::cxx::tree::one< NumberType > number_;
      ::xsd::cxx::tree::one< ErevType > erev_;
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
      static const SegmentGroupType segmentGroup_default_value_;
      SegmentOptional segment_;
      IonOptional ion_;
    };

    class ChannelDensityNonUniform: public ::neurona::schema::Base
    {
      public:
      // variableParameter
      //
      typedef ::neurona::schema::VariableParameter VariableParameterType;
      typedef ::xsd::cxx::tree::sequence< VariableParameterType > VariableParameterSequence;
      typedef VariableParameterSequence::iterator VariableParameterIterator;
      typedef VariableParameterSequence::const_iterator VariableParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< VariableParameterType, char > VariableParameterTraits;

      const VariableParameterSequence&
      variableParameters () const;

      VariableParameterSequence&
      variableParameters ();

      void
      setVariableParameters (const VariableParameterSequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::NmlId IonChannelType;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelType&
      ionChannel () const;

      IonChannelType&
      ionChannel ();

      void
      setIonChannel (const IonChannelType& x);

      void
      setIonChannel (::std::unique_ptr< IonChannelType > p);

      // erev
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ErevType;
      typedef ::xsd::cxx::tree::traits< ErevType, char > ErevTraits;

      const ErevType&
      erev () const;

      ErevType&
      erev ();

      void
      setErev (const ErevType& x);

      void
      setErev (::std::unique_ptr< ErevType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // Constructors.
      //
      ChannelDensityNonUniform (const IdType&,
                                const IonChannelType&,
                                const ErevType&);

      ChannelDensityNonUniform (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      ChannelDensityNonUniform (const ChannelDensityNonUniform& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual ChannelDensityNonUniform*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelDensityNonUniform&
      operator= (const ChannelDensityNonUniform& x);

      virtual 
      ~ChannelDensityNonUniform ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      VariableParameterSequence variableParameter_;
      ::xsd::cxx::tree::one< IonChannelType > ionChannel_;
      ::xsd::cxx::tree::one< ErevType > erev_;
      IonOptional ion_;
    };

    class ChannelDensityNonUniformNernst: public ::neurona::schema::Base
    {
      public:
      // variableParameter
      //
      typedef ::neurona::schema::VariableParameter VariableParameterType;
      typedef ::xsd::cxx::tree::sequence< VariableParameterType > VariableParameterSequence;
      typedef VariableParameterSequence::iterator VariableParameterIterator;
      typedef VariableParameterSequence::const_iterator VariableParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< VariableParameterType, char > VariableParameterTraits;

      const VariableParameterSequence&
      variableParameters () const;

      VariableParameterSequence&
      variableParameters ();

      void
      setVariableParameters (const VariableParameterSequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::NmlId IonChannelType;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelType&
      ionChannel () const;

      IonChannelType&
      ionChannel ();

      void
      setIonChannel (const IonChannelType& x);

      void
      setIonChannel (::std::unique_ptr< IonChannelType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // Constructors.
      //
      ChannelDensityNonUniformNernst (const IdType&,
                                      const IonChannelType&);

      ChannelDensityNonUniformNernst (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

      ChannelDensityNonUniformNernst (const ChannelDensityNonUniformNernst& x,
                                      ::xml_schema::Flags f = 0,
                                      ::xml_schema::Container* c = 0);

      virtual ChannelDensityNonUniformNernst*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelDensityNonUniformNernst&
      operator= (const ChannelDensityNonUniformNernst& x);

      virtual 
      ~ChannelDensityNonUniformNernst ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      VariableParameterSequence variableParameter_;
      ::xsd::cxx::tree::one< IonChannelType > ionChannel_;
      IonOptional ion_;
    };

    class ChannelDensity: public ::neurona::schema::Base
    {
      public:
      // variableParameter
      //
      typedef ::neurona::schema::VariableParameter VariableParameterType;
      typedef ::xsd::cxx::tree::sequence< VariableParameterType > VariableParameterSequence;
      typedef VariableParameterSequence::iterator VariableParameterIterator;
      typedef VariableParameterSequence::const_iterator VariableParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< VariableParameterType, char > VariableParameterTraits;

      const VariableParameterSequence&
      variableParameters () const;

      VariableParameterSequence&
      variableParameters ();

      void
      setVariableParameters (const VariableParameterSequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::NmlId IonChannelType;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelType&
      ionChannel () const;

      IonChannelType&
      ionChannel ();

      void
      setIonChannel (const IonChannelType& x);

      void
      setIonChannel (::std::unique_ptr< IonChannelType > p);

      // condDensity
      //
      typedef ::neurona::schema::Nml2Quantity_conductanceDensity CondDensityType;
      typedef ::xsd::cxx::tree::optional< CondDensityType > CondDensityOptional;
      typedef ::xsd::cxx::tree::traits< CondDensityType, char > CondDensityTraits;

      const CondDensityOptional&
      condDensity () const;

      CondDensityOptional&
      condDensity ();

      void
      setCondDensity (const CondDensityType& x);

      void
      setCondDensity (const CondDensityOptional& x);

      void
      setCondDensity (::std::unique_ptr< CondDensityType > p);

      // erev
      //
      typedef ::neurona::schema::Nml2Quantity_voltage ErevType;
      typedef ::xsd::cxx::tree::traits< ErevType, char > ErevTraits;

      const ErevType&
      erev () const;

      ErevType&
      erev ();

      void
      setErev (const ErevType& x);

      void
      setErev (::std::unique_ptr< ErevType > p);

      // segmentGroup
      //
      typedef ::neurona::schema::NmlId SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      static const SegmentGroupType&
      segmentGroupDefaultValue ();

      // segment
      //
      typedef ::neurona::schema::NmlId SegmentType;
      typedef ::xsd::cxx::tree::optional< SegmentType > SegmentOptional;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentOptional&
      segment () const;

      SegmentOptional&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (const SegmentOptional& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // Constructors.
      //
      ChannelDensity (const IdType&,
                      const IonChannelType&,
                      const ErevType&);

      ChannelDensity (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      ChannelDensity (const ChannelDensity& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual ChannelDensity*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelDensity&
      operator= (const ChannelDensity& x);

      virtual 
      ~ChannelDensity ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      VariableParameterSequence variableParameter_;
      ::xsd::cxx::tree::one< IonChannelType > ionChannel_;
      CondDensityOptional condDensity_;
      ::xsd::cxx::tree::one< ErevType > erev_;
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
      static const SegmentGroupType segmentGroup_default_value_;
      SegmentOptional segment_;
      IonOptional ion_;
    };

    class ChannelDensityNernst: public ::neurona::schema::Base
    {
      public:
      // variableParameter
      //
      typedef ::neurona::schema::VariableParameter VariableParameterType;
      typedef ::xsd::cxx::tree::sequence< VariableParameterType > VariableParameterSequence;
      typedef VariableParameterSequence::iterator VariableParameterIterator;
      typedef VariableParameterSequence::const_iterator VariableParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< VariableParameterType, char > VariableParameterTraits;

      const VariableParameterSequence&
      variableParameters () const;

      VariableParameterSequence&
      variableParameters ();

      void
      setVariableParameters (const VariableParameterSequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::NmlId IonChannelType;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelType&
      ionChannel () const;

      IonChannelType&
      ionChannel ();

      void
      setIonChannel (const IonChannelType& x);

      void
      setIonChannel (::std::unique_ptr< IonChannelType > p);

      // condDensity
      //
      typedef ::neurona::schema::Nml2Quantity_conductanceDensity CondDensityType;
      typedef ::xsd::cxx::tree::optional< CondDensityType > CondDensityOptional;
      typedef ::xsd::cxx::tree::traits< CondDensityType, char > CondDensityTraits;

      const CondDensityOptional&
      condDensity () const;

      CondDensityOptional&
      condDensity ();

      void
      setCondDensity (const CondDensityType& x);

      void
      setCondDensity (const CondDensityOptional& x);

      void
      setCondDensity (::std::unique_ptr< CondDensityType > p);

      // segmentGroup
      //
      typedef ::neurona::schema::NmlId SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      static const SegmentGroupType&
      segmentGroupDefaultValue ();

      // segment
      //
      typedef ::neurona::schema::NmlId SegmentType;
      typedef ::xsd::cxx::tree::optional< SegmentType > SegmentOptional;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentOptional&
      segment () const;

      SegmentOptional&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (const SegmentOptional& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // Constructors.
      //
      ChannelDensityNernst (const IdType&,
                            const IonChannelType&);

      ChannelDensityNernst (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      ChannelDensityNernst (const ChannelDensityNernst& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      virtual ChannelDensityNernst*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelDensityNernst&
      operator= (const ChannelDensityNernst& x);

      virtual 
      ~ChannelDensityNernst ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      VariableParameterSequence variableParameter_;
      ::xsd::cxx::tree::one< IonChannelType > ionChannel_;
      CondDensityOptional condDensity_;
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
      static const SegmentGroupType segmentGroup_default_value_;
      SegmentOptional segment_;
      IonOptional ion_;
    };

    class ChannelDensityGHK: public ::neurona::schema::Base
    {
      public:
      // variableParameter
      //
      typedef ::neurona::schema::VariableParameter VariableParameterType;
      typedef ::xsd::cxx::tree::sequence< VariableParameterType > VariableParameterSequence;
      typedef VariableParameterSequence::iterator VariableParameterIterator;
      typedef VariableParameterSequence::const_iterator VariableParameterConstIterator;
      typedef ::xsd::cxx::tree::traits< VariableParameterType, char > VariableParameterTraits;

      const VariableParameterSequence&
      variableParameters () const;

      VariableParameterSequence&
      variableParameters ();

      void
      setVariableParameters (const VariableParameterSequence& s);

      // ionChannel
      //
      typedef ::neurona::schema::NmlId IonChannelType;
      typedef ::xsd::cxx::tree::traits< IonChannelType, char > IonChannelTraits;

      const IonChannelType&
      ionChannel () const;

      IonChannelType&
      ionChannel ();

      void
      setIonChannel (const IonChannelType& x);

      void
      setIonChannel (::std::unique_ptr< IonChannelType > p);

      // permeability
      //
      typedef ::neurona::schema::Nml2Quantity_permeability PermeabilityType;
      typedef ::xsd::cxx::tree::traits< PermeabilityType, char > PermeabilityTraits;

      const PermeabilityType&
      permeability () const;

      PermeabilityType&
      permeability ();

      void
      setPermeability (const PermeabilityType& x);

      void
      setPermeability (::std::unique_ptr< PermeabilityType > p);

      // segmentGroup
      //
      typedef ::neurona::schema::NmlId SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      static const SegmentGroupType&
      segmentGroupDefaultValue ();

      // segment
      //
      typedef ::neurona::schema::NmlId SegmentType;
      typedef ::xsd::cxx::tree::optional< SegmentType > SegmentOptional;
      typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

      const SegmentOptional&
      segment () const;

      SegmentOptional&
      segment ();

      void
      setSegment (const SegmentType& x);

      void
      setSegment (const SegmentOptional& x);

      void
      setSegment (::std::unique_ptr< SegmentType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // Constructors.
      //
      ChannelDensityGHK (const IdType&,
                         const IonChannelType&,
                         const PermeabilityType&);

      ChannelDensityGHK (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      ChannelDensityGHK (const ChannelDensityGHK& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual ChannelDensityGHK*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ChannelDensityGHK&
      operator= (const ChannelDensityGHK& x);

      virtual 
      ~ChannelDensityGHK ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      VariableParameterSequence variableParameter_;
      ::xsd::cxx::tree::one< IonChannelType > ionChannel_;
      ::xsd::cxx::tree::one< PermeabilityType > permeability_;
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
      static const SegmentGroupType segmentGroup_default_value_;
      SegmentOptional segment_;
      IonOptional ion_;
    };

    class VariableParameter: public ::xml_schema::Type
    {
      public:
      // inhomogeneousValue
      //
      typedef ::neurona::schema::InhomogeneousValue InhomogeneousValueType;
      typedef ::xsd::cxx::tree::optional< InhomogeneousValueType > InhomogeneousValueOptional;
      typedef ::xsd::cxx::tree::traits< InhomogeneousValueType, char > InhomogeneousValueTraits;

      const InhomogeneousValueOptional&
      inhomogeneousValue () const;

      InhomogeneousValueOptional&
      inhomogeneousValue ();

      void
      setInhomogeneousValue (const InhomogeneousValueType& x);

      void
      setInhomogeneousValue (const InhomogeneousValueOptional& x);

      void
      setInhomogeneousValue (::std::unique_ptr< InhomogeneousValueType > p);

      // parameter
      //
      typedef ::xml_schema::String ParameterType;
      typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

      const ParameterType&
      parameter () const;

      ParameterType&
      parameter ();

      void
      setParameter (const ParameterType& x);

      void
      setParameter (::std::unique_ptr< ParameterType > p);

      // segmentGroup
      //
      typedef ::xml_schema::String SegmentGroupType;
      typedef ::xsd::cxx::tree::traits< SegmentGroupType, char > SegmentGroupTraits;

      const SegmentGroupType&
      segmentGroup () const;

      SegmentGroupType&
      segmentGroup ();

      void
      setSegmentGroup (const SegmentGroupType& x);

      void
      setSegmentGroup (::std::unique_ptr< SegmentGroupType > p);

      // Constructors.
      //
      VariableParameter (const ParameterType&,
                         const SegmentGroupType&);

      VariableParameter (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      VariableParameter (const VariableParameter& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      virtual VariableParameter*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      VariableParameter&
      operator= (const VariableParameter& x);

      virtual 
      ~VariableParameter ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      InhomogeneousValueOptional inhomogeneousValue_;
      ::xsd::cxx::tree::one< ParameterType > parameter_;
      ::xsd::cxx::tree::one< SegmentGroupType > segmentGroup_;
    };

    class InhomogeneousValue: public ::xml_schema::Type
    {
      public:
      // inhomogeneousParameter
      //
      typedef ::xml_schema::String InhomogeneousParameterType;
      typedef ::xsd::cxx::tree::traits< InhomogeneousParameterType, char > InhomogeneousParameterTraits;

      const InhomogeneousParameterType&
      inhomogeneousParameter () const;

      InhomogeneousParameterType&
      inhomogeneousParameter ();

      void
      setInhomogeneousParameter (const InhomogeneousParameterType& x);

      void
      setInhomogeneousParameter (::std::unique_ptr< InhomogeneousParameterType > p);

      // value
      //
      typedef ::xml_schema::String ValueType;
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      const ValueType&
      value () const;

      ValueType&
      value ();

      void
      setValue (const ValueType& x);

      void
      setValue (::std::unique_ptr< ValueType > p);

      // Constructors.
      //
      InhomogeneousValue (const InhomogeneousParameterType&,
                          const ValueType&);

      InhomogeneousValue (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      InhomogeneousValue (const InhomogeneousValue& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual InhomogeneousValue*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      InhomogeneousValue&
      operator= (const InhomogeneousValue& x);

      virtual 
      ~InhomogeneousValue ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< InhomogeneousParameterType > inhomogeneousParameter_;
      ::xsd::cxx::tree::one< ValueType > value_;
    };

    class Species: public ::neurona::schema::ValueAcrossSegOrSegGroup
    {
      public:
      // id
      //
      typedef ::neurona::schema::NmlId IdType;
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      const IdType&
      id () const;

      IdType&
      id ();

      void
      setId (const IdType& x);

      void
      setId (::std::unique_ptr< IdType > p);

      // concentrationModel
      //
      typedef ::neurona::schema::NmlId ConcentrationModelType;
      typedef ::xsd::cxx::tree::traits< ConcentrationModelType, char > ConcentrationModelTraits;

      const ConcentrationModelType&
      concentrationModel () const;

      ConcentrationModelType&
      concentrationModel ();

      void
      setConcentrationModel (const ConcentrationModelType& x);

      void
      setConcentrationModel (::std::unique_ptr< ConcentrationModelType > p);

      // ion
      //
      typedef ::neurona::schema::NmlId IonType;
      typedef ::xsd::cxx::tree::optional< IonType > IonOptional;
      typedef ::xsd::cxx::tree::traits< IonType, char > IonTraits;

      const IonOptional&
      ion () const;

      IonOptional&
      ion ();

      void
      setIon (const IonType& x);

      void
      setIon (const IonOptional& x);

      void
      setIon (::std::unique_ptr< IonType > p);

      // initialConcentration
      //
      typedef ::neurona::schema::Nml2Quantity_concentration InitialConcentrationType;
      typedef ::xsd::cxx::tree::traits< InitialConcentrationType, char > InitialConcentrationTraits;

      const InitialConcentrationType&
      initialConcentration () const;

      InitialConcentrationType&
      initialConcentration ();

      void
      setInitialConcentration (const InitialConcentrationType& x);

      void
      setInitialConcentration (::std::unique_ptr< InitialConcentrationType > p);

      // initialExtConcentration
      //
      typedef ::neurona::schema::Nml2Quantity_concentration InitialExtConcentrationType;
      typedef ::xsd::cxx::tree::traits< InitialExtConcentrationType, char > InitialExtConcentrationTraits;

      const InitialExtConcentrationType&
      initialExtConcentration () const;

      InitialExtConcentrationType&
      initialExtConcentration ();

      void
      setInitialExtConcentration (const InitialExtConcentrationType& x);

      void
      setInitialExtConcentration (::std::unique_ptr< InitialExtConcentrationType > p);

      // Constructors.
      //
      Species (const IdType&,
               const ConcentrationModelType&,
               const InitialConcentrationType&,
               const InitialExtConcentrationType&);

      Species (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      Species (const Species& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual Species*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Species&
      operator= (const Species& x);

      virtual 
      ~Species ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      ::xsd::cxx::tree::one< ConcentrationModelType > concentrationModel_;
      IonOptional ion_;
      ::xsd::cxx::tree::one< InitialConcentrationType > initialConcentration_;
      ::xsd::cxx::tree::one< InitialExtConcentrationType > initialExtConcentration_;
    };

    class ConcentrationModel_D: public ::neurona::schema::DecayingPoolConcentrationModel
    {
      public:
      // type
      //
      typedef ::xml_schema::SimpleType TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      static const TypeType&
      typeDefaultValue ();

      // Constructors.
      //
      ConcentrationModel_D (const IdType&,
                            const IonType&,
                            const RestingConcType&,
                            const DecayConstantType&,
                            const ShellThicknessType&);

      ConcentrationModel_D (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      ConcentrationModel_D (const ConcentrationModel_D& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      virtual ConcentrationModel_D*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ConcentrationModel_D&
      operator= (const ConcentrationModel_D& x);

      virtual 
      ~ConcentrationModel_D ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TypeType > type_;
      static const TypeType type_default_value_;
    };

    class IntracellularProperties: public ::xml_schema::Type
    {
      public:
      // species
      //
      typedef ::neurona::schema::Species SpeciesType;
      typedef ::xsd::cxx::tree::sequence< SpeciesType > SpeciesSequence;
      typedef SpeciesSequence::iterator SpeciesIterator;
      typedef SpeciesSequence::const_iterator SpeciesConstIterator;
      typedef ::xsd::cxx::tree::traits< SpeciesType, char > SpeciesTraits;

      const SpeciesSequence&
      speciess () const;

      SpeciesSequence&
      speciess ();

      void
      setSpeciess (const SpeciesSequence& s);

      // resistivity
      //
      typedef ::neurona::schema::Resistivity ResistivityType;
      typedef ::xsd::cxx::tree::sequence< ResistivityType > ResistivitySequence;
      typedef ResistivitySequence::iterator ResistivityIterator;
      typedef ResistivitySequence::const_iterator ResistivityConstIterator;
      typedef ::xsd::cxx::tree::traits< ResistivityType, char > ResistivityTraits;

      const ResistivitySequence&
      resistivitys () const;

      ResistivitySequence&
      resistivitys ();

      void
      setResistivitys (const ResistivitySequence& s);

      // Constructors.
      //
      IntracellularProperties ();

      IntracellularProperties (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      IntracellularProperties (const IntracellularProperties& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      virtual IntracellularProperties*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      IntracellularProperties&
      operator= (const IntracellularProperties& x);

      virtual 
      ~IntracellularProperties ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SpeciesSequence species_;
      ResistivitySequence resistivity_;
    };

    class ExtracellularProperties: public ::neurona::schema::Base
    {
      public:
      // species
      //
      typedef ::neurona::schema::Species SpeciesType;
      typedef ::xsd::cxx::tree::sequence< SpeciesType > SpeciesSequence;
      typedef SpeciesSequence::iterator SpeciesIterator;
      typedef SpeciesSequence::const_iterator SpeciesConstIterator;
      typedef ::xsd::cxx::tree::traits< SpeciesType, char > SpeciesTraits;

      const SpeciesSequence&
      speciess () const;

      SpeciesSequence&
      speciess ();

      void
      setSpeciess (const SpeciesSequence& s);

      // Constructors.
      //
      ExtracellularProperties (const IdType&);

      ExtracellularProperties (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      ExtracellularProperties (const ExtracellularProperties& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

      virtual ExtracellularProperties*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ExtracellularProperties&
      operator= (const ExtracellularProperties& x);

      virtual 
      ~ExtracellularProperties ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SpeciesSequence species_;
    };

    class ExtracellularPropertiesLocal: public ::xml_schema::Type
    {
      public:
      // species
      //
      typedef ::neurona::schema::Species SpeciesType;
      typedef ::xsd::cxx::tree::sequence< SpeciesType > SpeciesSequence;
      typedef SpeciesSequence::iterator SpeciesIterator;
      typedef SpeciesSequence::const_iterator SpeciesConstIterator;
      typedef ::xsd::cxx::tree::traits< SpeciesType, char > SpeciesTraits;

      const SpeciesSequence&
      speciess () const;

      SpeciesSequence&
      speciess ();

      void
      setSpeciess (const SpeciesSequence& s);

      // Constructors.
      //
      ExtracellularPropertiesLocal ();

      ExtracellularPropertiesLocal (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      ExtracellularPropertiesLocal (const ExtracellularPropertiesLocal& x,
                                    ::xml_schema::Flags f = 0,
                                    ::xml_schema::Container* c = 0);

      virtual ExtracellularPropertiesLocal*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ExtracellularPropertiesLocal&
      operator= (const ExtracellularPropertiesLocal& x);

      virtual 
      ~ExtracellularPropertiesLocal ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SpeciesSequence species_;
    };

    class ReactionScheme: public ::neurona::schema::Base
    {
      public:
      // source
      //
      typedef ::xml_schema::String SourceType;
      typedef ::xsd::cxx::tree::traits< SourceType, char > SourceTraits;

      const SourceType&
      source () const;

      SourceType&
      source ();

      void
      setSource (const SourceType& x);

      void
      setSource (::std::unique_ptr< SourceType > p);

      // type
      //
      typedef ::xml_schema::String TypeType;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeType&
      type () const;

      TypeType&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // Constructors.
      //
      ReactionScheme (const IdType&,
                      const SourceType&,
                      const TypeType&);

      ReactionScheme (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      ReactionScheme (const ReactionScheme& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual ReactionScheme*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ReactionScheme&
      operator= (const ReactionScheme& x);

      virtual 
      ~ReactionScheme ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SourceType > source_;
      ::xsd::cxx::tree::one< TypeType > type_;
    };

    class PulseGenerator: public ::neurona::schema::Standalone
    {
      public:
      // delay
      //
      typedef ::neurona::schema::Nml2Quantity_time DelayType;
      typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

      const DelayType&
      delay () const;

      DelayType&
      delay ();

      void
      setDelay (const DelayType& x);

      void
      setDelay (::std::unique_ptr< DelayType > p);

      // duration
      //
      typedef ::neurona::schema::Nml2Quantity_time DurationType;
      typedef ::xsd::cxx::tree::traits< DurationType, char > DurationTraits;

      const DurationType&
      duration () const;

      DurationType&
      duration ();

      void
      setDuration (const DurationType& x);

      void
      setDuration (::std::unique_ptr< DurationType > p);

      // amplitude
      //
      typedef ::neurona::schema::Nml2Quantity_current AmplitudeType;
      typedef ::xsd::cxx::tree::traits< AmplitudeType, char > AmplitudeTraits;

      const AmplitudeType&
      amplitude () const;

      AmplitudeType&
      amplitude ();

      void
      setAmplitude (const AmplitudeType& x);

      void
      setAmplitude (::std::unique_ptr< AmplitudeType > p);

      // Constructors.
      //
      PulseGenerator (const IdType&,
                      const DelayType&,
                      const DurationType&,
                      const AmplitudeType&);

      PulseGenerator (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      PulseGenerator (const PulseGenerator& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual PulseGenerator*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      PulseGenerator&
      operator= (const PulseGenerator& x);

      virtual 
      ~PulseGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DelayType > delay_;
      ::xsd::cxx::tree::one< DurationType > duration_;
      ::xsd::cxx::tree::one< AmplitudeType > amplitude_;
    };

    class SineGenerator: public ::neurona::schema::Standalone
    {
      public:
      // delay
      //
      typedef ::neurona::schema::Nml2Quantity_time DelayType;
      typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

      const DelayType&
      delay () const;

      DelayType&
      delay ();

      void
      setDelay (const DelayType& x);

      void
      setDelay (::std::unique_ptr< DelayType > p);

      // phase
      //
      typedef ::neurona::schema::Nml2Quantity_none PhaseType;
      typedef ::xsd::cxx::tree::traits< PhaseType, char > PhaseTraits;

      const PhaseType&
      phase () const;

      PhaseType&
      phase ();

      void
      setPhase (const PhaseType& x);

      void
      setPhase (::std::unique_ptr< PhaseType > p);

      // duration
      //
      typedef ::neurona::schema::Nml2Quantity_time DurationType;
      typedef ::xsd::cxx::tree::traits< DurationType, char > DurationTraits;

      const DurationType&
      duration () const;

      DurationType&
      duration ();

      void
      setDuration (const DurationType& x);

      void
      setDuration (::std::unique_ptr< DurationType > p);

      // amplitude
      //
      typedef ::neurona::schema::Nml2Quantity_current AmplitudeType;
      typedef ::xsd::cxx::tree::traits< AmplitudeType, char > AmplitudeTraits;

      const AmplitudeType&
      amplitude () const;

      AmplitudeType&
      amplitude ();

      void
      setAmplitude (const AmplitudeType& x);

      void
      setAmplitude (::std::unique_ptr< AmplitudeType > p);

      // period
      //
      typedef ::neurona::schema::Nml2Quantity_time PeriodType;
      typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

      const PeriodType&
      period () const;

      PeriodType&
      period ();

      void
      setPeriod (const PeriodType& x);

      void
      setPeriod (::std::unique_ptr< PeriodType > p);

      // Constructors.
      //
      SineGenerator (const IdType&,
                     const DelayType&,
                     const PhaseType&,
                     const DurationType&,
                     const AmplitudeType&,
                     const PeriodType&);

      SineGenerator (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      SineGenerator (const SineGenerator& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual SineGenerator*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SineGenerator&
      operator= (const SineGenerator& x);

      virtual 
      ~SineGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DelayType > delay_;
      ::xsd::cxx::tree::one< PhaseType > phase_;
      ::xsd::cxx::tree::one< DurationType > duration_;
      ::xsd::cxx::tree::one< AmplitudeType > amplitude_;
      ::xsd::cxx::tree::one< PeriodType > period_;
    };

    class RampGenerator: public ::neurona::schema::Standalone
    {
      public:
      // delay
      //
      typedef ::neurona::schema::Nml2Quantity_time DelayType;
      typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

      const DelayType&
      delay () const;

      DelayType&
      delay ();

      void
      setDelay (const DelayType& x);

      void
      setDelay (::std::unique_ptr< DelayType > p);

      // duration
      //
      typedef ::neurona::schema::Nml2Quantity_time DurationType;
      typedef ::xsd::cxx::tree::traits< DurationType, char > DurationTraits;

      const DurationType&
      duration () const;

      DurationType&
      duration ();

      void
      setDuration (const DurationType& x);

      void
      setDuration (::std::unique_ptr< DurationType > p);

      // startAmplitude
      //
      typedef ::neurona::schema::Nml2Quantity_current StartAmplitudeType;
      typedef ::xsd::cxx::tree::traits< StartAmplitudeType, char > StartAmplitudeTraits;

      const StartAmplitudeType&
      startAmplitude () const;

      StartAmplitudeType&
      startAmplitude ();

      void
      setStartAmplitude (const StartAmplitudeType& x);

      void
      setStartAmplitude (::std::unique_ptr< StartAmplitudeType > p);

      // finishAmplitude
      //
      typedef ::neurona::schema::Nml2Quantity_current FinishAmplitudeType;
      typedef ::xsd::cxx::tree::traits< FinishAmplitudeType, char > FinishAmplitudeTraits;

      const FinishAmplitudeType&
      finishAmplitude () const;

      FinishAmplitudeType&
      finishAmplitude ();

      void
      setFinishAmplitude (const FinishAmplitudeType& x);

      void
      setFinishAmplitude (::std::unique_ptr< FinishAmplitudeType > p);

      // baselineAmplitude
      //
      typedef ::neurona::schema::Nml2Quantity_current BaselineAmplitudeType;
      typedef ::xsd::cxx::tree::traits< BaselineAmplitudeType, char > BaselineAmplitudeTraits;

      const BaselineAmplitudeType&
      baselineAmplitude () const;

      BaselineAmplitudeType&
      baselineAmplitude ();

      void
      setBaselineAmplitude (const BaselineAmplitudeType& x);

      void
      setBaselineAmplitude (::std::unique_ptr< BaselineAmplitudeType > p);

      // Constructors.
      //
      RampGenerator (const IdType&,
                     const DelayType&,
                     const DurationType&,
                     const StartAmplitudeType&,
                     const FinishAmplitudeType&,
                     const BaselineAmplitudeType&);

      RampGenerator (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      RampGenerator (const RampGenerator& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual RampGenerator*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      RampGenerator&
      operator= (const RampGenerator& x);

      virtual 
      ~RampGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DelayType > delay_;
      ::xsd::cxx::tree::one< DurationType > duration_;
      ::xsd::cxx::tree::one< StartAmplitudeType > startAmplitude_;
      ::xsd::cxx::tree::one< FinishAmplitudeType > finishAmplitude_;
      ::xsd::cxx::tree::one< BaselineAmplitudeType > baselineAmplitude_;
    };

    class VoltageClamp: public ::neurona::schema::Standalone
    {
      public:
      // delay
      //
      typedef ::neurona::schema::Nml2Quantity_time DelayType;
      typedef ::xsd::cxx::tree::traits< DelayType, char > DelayTraits;

      const DelayType&
      delay () const;

      DelayType&
      delay ();

      void
      setDelay (const DelayType& x);

      void
      setDelay (::std::unique_ptr< DelayType > p);

      // duration
      //
      typedef ::neurona::schema::Nml2Quantity_time DurationType;
      typedef ::xsd::cxx::tree::traits< DurationType, char > DurationTraits;

      const DurationType&
      duration () const;

      DurationType&
      duration ();

      void
      setDuration (const DurationType& x);

      void
      setDuration (::std::unique_ptr< DurationType > p);

      // targetVoltage
      //
      typedef ::neurona::schema::Nml2Quantity_voltage TargetVoltageType;
      typedef ::xsd::cxx::tree::traits< TargetVoltageType, char > TargetVoltageTraits;

      const TargetVoltageType&
      targetVoltage () const;

      TargetVoltageType&
      targetVoltage ();

      void
      setTargetVoltage (const TargetVoltageType& x);

      void
      setTargetVoltage (::std::unique_ptr< TargetVoltageType > p);

      // simpleSeriesResistance
      //
      typedef ::neurona::schema::Nml2Quantity_resistance SimpleSeriesResistanceType;
      typedef ::xsd::cxx::tree::traits< SimpleSeriesResistanceType, char > SimpleSeriesResistanceTraits;

      const SimpleSeriesResistanceType&
      simpleSeriesResistance () const;

      SimpleSeriesResistanceType&
      simpleSeriesResistance ();

      void
      setSimpleSeriesResistance (const SimpleSeriesResistanceType& x);

      void
      setSimpleSeriesResistance (::std::unique_ptr< SimpleSeriesResistanceType > p);

      // Constructors.
      //
      VoltageClamp (const IdType&,
                    const DelayType&,
                    const DurationType&,
                    const TargetVoltageType&,
                    const SimpleSeriesResistanceType&);

      VoltageClamp (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      VoltageClamp (const VoltageClamp& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual VoltageClamp*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      VoltageClamp&
      operator= (const VoltageClamp& x);

      virtual 
      ~VoltageClamp ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DelayType > delay_;
      ::xsd::cxx::tree::one< DurationType > duration_;
      ::xsd::cxx::tree::one< TargetVoltageType > targetVoltage_;
      ::xsd::cxx::tree::one< SimpleSeriesResistanceType > simpleSeriesResistance_;
    };

    class Spike: public ::neurona::schema::Standalone
    {
      public:
      // time
      //
      typedef ::neurona::schema::Nml2Quantity_time TimeType;
      typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

      const TimeType&
      time () const;

      TimeType&
      time ();

      void
      setTime (const TimeType& x);

      void
      setTime (::std::unique_ptr< TimeType > p);

      // Constructors.
      //
      Spike (const IdType&,
             const TimeType&);

      Spike (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      Spike (const Spike& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual Spike*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Spike&
      operator= (const Spike& x);

      virtual 
      ~Spike ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< TimeType > time_;
    };

    class SpikeArray: public ::neurona::schema::Standalone
    {
      public:
      // spike
      //
      typedef ::neurona::schema::Spike SpikeType;
      typedef ::xsd::cxx::tree::sequence< SpikeType > SpikeSequence;
      typedef SpikeSequence::iterator SpikeIterator;
      typedef SpikeSequence::const_iterator SpikeConstIterator;
      typedef ::xsd::cxx::tree::traits< SpikeType, char > SpikeTraits;

      const SpikeSequence&
      spikes () const;

      SpikeSequence&
      spikes ();

      void
      setSpikes (const SpikeSequence& s);

      // Constructors.
      //
      SpikeArray (const IdType&);

      SpikeArray (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      SpikeArray (const SpikeArray& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual SpikeArray*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SpikeArray&
      operator= (const SpikeArray& x);

      virtual 
      ~SpikeArray ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SpikeSequence spike_;
    };

    class SpikeGenerator: public ::neurona::schema::Standalone
    {
      public:
      // period
      //
      typedef ::neurona::schema::Nml2Quantity_time PeriodType;
      typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

      const PeriodType&
      period () const;

      PeriodType&
      period ();

      void
      setPeriod (const PeriodType& x);

      void
      setPeriod (::std::unique_ptr< PeriodType > p);

      // Constructors.
      //
      SpikeGenerator (const IdType&,
                      const PeriodType&);

      SpikeGenerator (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      SpikeGenerator (const SpikeGenerator& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual SpikeGenerator*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SpikeGenerator&
      operator= (const SpikeGenerator& x);

      virtual 
      ~SpikeGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< PeriodType > period_;
    };

    class SpikeGeneratorRandom: public ::neurona::schema::Standalone
    {
      public:
      // maxISI
      //
      typedef ::neurona::schema::Nml2Quantity_time MaxISIType;
      typedef ::xsd::cxx::tree::traits< MaxISIType, char > MaxISITraits;

      const MaxISIType&
      maxISI () const;

      MaxISIType&
      maxISI ();

      void
      setMaxISI (const MaxISIType& x);

      void
      setMaxISI (::std::unique_ptr< MaxISIType > p);

      // minISI
      //
      typedef ::neurona::schema::Nml2Quantity_time MinISIType;
      typedef ::xsd::cxx::tree::traits< MinISIType, char > MinISITraits;

      const MinISIType&
      minISI () const;

      MinISIType&
      minISI ();

      void
      setMinISI (const MinISIType& x);

      void
      setMinISI (::std::unique_ptr< MinISIType > p);

      // Constructors.
      //
      SpikeGeneratorRandom (const IdType&,
                            const MaxISIType&,
                            const MinISIType&);

      SpikeGeneratorRandom (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      SpikeGeneratorRandom (const SpikeGeneratorRandom& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      virtual SpikeGeneratorRandom*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SpikeGeneratorRandom&
      operator= (const SpikeGeneratorRandom& x);

      virtual 
      ~SpikeGeneratorRandom ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< MaxISIType > maxISI_;
      ::xsd::cxx::tree::one< MinISIType > minISI_;
    };

    class SpikeGeneratorPoisson: public ::neurona::schema::Standalone
    {
      public:
      // averageRate
      //
      typedef ::neurona::schema::Nml2Quantity_pertime AverageRateType;
      typedef ::xsd::cxx::tree::traits< AverageRateType, char > AverageRateTraits;

      const AverageRateType&
      averageRate () const;

      AverageRateType&
      averageRate ();

      void
      setAverageRate (const AverageRateType& x);

      void
      setAverageRate (::std::unique_ptr< AverageRateType > p);

      // Constructors.
      //
      SpikeGeneratorPoisson (const IdType&,
                             const AverageRateType&);

      SpikeGeneratorPoisson (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      SpikeGeneratorPoisson (const SpikeGeneratorPoisson& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      virtual SpikeGeneratorPoisson*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SpikeGeneratorPoisson&
      operator= (const SpikeGeneratorPoisson& x);

      virtual 
      ~SpikeGeneratorPoisson ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< AverageRateType > averageRate_;
    };

    class Network: public ::neurona::schema::Standalone
    {
      public:
      // space
      //
      typedef ::neurona::schema::Space SpaceType;
      typedef ::xsd::cxx::tree::sequence< SpaceType > SpaceSequence;
      typedef SpaceSequence::iterator SpaceIterator;
      typedef SpaceSequence::const_iterator SpaceConstIterator;
      typedef ::xsd::cxx::tree::traits< SpaceType, char > SpaceTraits;

      const SpaceSequence&
      spaces () const;

      SpaceSequence&
      spaces ();

      void
      setSpaces (const SpaceSequence& s);

      // region
      //
      typedef ::neurona::schema::Region RegionType;
      typedef ::xsd::cxx::tree::sequence< RegionType > RegionSequence;
      typedef RegionSequence::iterator RegionIterator;
      typedef RegionSequence::const_iterator RegionConstIterator;
      typedef ::xsd::cxx::tree::traits< RegionType, char > RegionTraits;

      const RegionSequence&
      regions () const;

      RegionSequence&
      regions ();

      void
      setRegions (const RegionSequence& s);

      // extracellularProperties
      //
      typedef ::neurona::schema::ExtracellularPropertiesLocal ExtracellularPropertiesType;
      typedef ::xsd::cxx::tree::sequence< ExtracellularPropertiesType > ExtracellularPropertiesSequence;
      typedef ExtracellularPropertiesSequence::iterator ExtracellularPropertiesIterator;
      typedef ExtracellularPropertiesSequence::const_iterator ExtracellularPropertiesConstIterator;
      typedef ::xsd::cxx::tree::traits< ExtracellularPropertiesType, char > ExtracellularPropertiesTraits;

      const ExtracellularPropertiesSequence&
      extracellularPropertiess () const;

      ExtracellularPropertiesSequence&
      extracellularPropertiess ();

      void
      setExtracellularPropertiess (const ExtracellularPropertiesSequence& s);

      // population
      //
      typedef ::neurona::schema::Population PopulationType;
      typedef ::xsd::cxx::tree::sequence< PopulationType > PopulationSequence;
      typedef PopulationSequence::iterator PopulationIterator;
      typedef PopulationSequence::const_iterator PopulationConstIterator;
      typedef ::xsd::cxx::tree::traits< PopulationType, char > PopulationTraits;

      const PopulationSequence&
      populations () const;

      PopulationSequence&
      populations ();

      void
      setPopulations (const PopulationSequence& s);

      // cellSet
      //
      typedef ::neurona::schema::CellSet CellSetType;
      typedef ::xsd::cxx::tree::sequence< CellSetType > CellSetSequence;
      typedef CellSetSequence::iterator CellSetIterator;
      typedef CellSetSequence::const_iterator CellSetConstIterator;
      typedef ::xsd::cxx::tree::traits< CellSetType, char > CellSetTraits;

      const CellSetSequence&
      cellSets () const;

      CellSetSequence&
      cellSets ();

      void
      setCellSets (const CellSetSequence& s);

      // synapticConnection
      //
      typedef ::neurona::schema::SynapticConnection SynapticConnectionType;
      typedef ::xsd::cxx::tree::sequence< SynapticConnectionType > SynapticConnectionSequence;
      typedef SynapticConnectionSequence::iterator SynapticConnectionIterator;
      typedef SynapticConnectionSequence::const_iterator SynapticConnectionConstIterator;
      typedef ::xsd::cxx::tree::traits< SynapticConnectionType, char > SynapticConnectionTraits;

      const SynapticConnectionSequence&
      synapticConnections () const;

      SynapticConnectionSequence&
      synapticConnections ();

      void
      setSynapticConnections (const SynapticConnectionSequence& s);

      // projection
      //
      typedef ::neurona::schema::Projection ProjectionType;
      typedef ::xsd::cxx::tree::sequence< ProjectionType > ProjectionSequence;
      typedef ProjectionSequence::iterator ProjectionIterator;
      typedef ProjectionSequence::const_iterator ProjectionConstIterator;
      typedef ::xsd::cxx::tree::traits< ProjectionType, char > ProjectionTraits;

      const ProjectionSequence&
      projections () const;

      ProjectionSequence&
      projections ();

      void
      setProjections (const ProjectionSequence& s);

      // explicitInput
      //
      typedef ::neurona::schema::ExplicitInput ExplicitInputType;
      typedef ::xsd::cxx::tree::sequence< ExplicitInputType > ExplicitInputSequence;
      typedef ExplicitInputSequence::iterator ExplicitInputIterator;
      typedef ExplicitInputSequence::const_iterator ExplicitInputConstIterator;
      typedef ::xsd::cxx::tree::traits< ExplicitInputType, char > ExplicitInputTraits;

      const ExplicitInputSequence&
      explicitInputs () const;

      ExplicitInputSequence&
      explicitInputs ();

      void
      setExplicitInputs (const ExplicitInputSequence& s);

      // inputList
      //
      typedef ::neurona::schema::InputList InputListType;
      typedef ::xsd::cxx::tree::sequence< InputListType > InputListSequence;
      typedef InputListSequence::iterator InputListIterator;
      typedef InputListSequence::const_iterator InputListConstIterator;
      typedef ::xsd::cxx::tree::traits< InputListType, char > InputListTraits;

      const InputListSequence&
      inputLists () const;

      InputListSequence&
      inputLists ();

      void
      setInputLists (const InputListSequence& s);

      // type
      //
      typedef ::neurona::schema::NetworkTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // temperature
      //
      typedef ::neurona::schema::Nml2Quantity_temperature TemperatureType;
      typedef ::xsd::cxx::tree::optional< TemperatureType > TemperatureOptional;
      typedef ::xsd::cxx::tree::traits< TemperatureType, char > TemperatureTraits;

      const TemperatureOptional&
      temperature () const;

      TemperatureOptional&
      temperature ();

      void
      setTemperature (const TemperatureType& x);

      void
      setTemperature (const TemperatureOptional& x);

      void
      setTemperature (::std::unique_ptr< TemperatureType > p);

      // Constructors.
      //
      Network (const IdType&);

      Network (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      Network (const Network& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual Network*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Network&
      operator= (const Network& x);

      virtual 
      ~Network ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SpaceSequence space_;
      RegionSequence region_;
      ExtracellularPropertiesSequence extracellularProperties_;
      PopulationSequence population_;
      CellSetSequence cellSet_;
      SynapticConnectionSequence synapticConnection_;
      ProjectionSequence projection_;
      ExplicitInputSequence explicitInput_;
      InputListSequence inputList_;
      TypeOptional type_;
      TemperatureOptional temperature_;
    };

    class NetworkTypes: public ::xml_schema::String
    {
      public:
      enum Value
      {
        network,
        networkWithTemperature
      };

      NetworkTypes (Value v);

      NetworkTypes (const char* v);

      NetworkTypes (const ::std::string& v);

      NetworkTypes (const ::xml_schema::String& v);

      NetworkTypes (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      NetworkTypes (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      NetworkTypes (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      NetworkTypes (const NetworkTypes& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual NetworkTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      NetworkTypes&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_NetworkTypes_convert ();
      }

      protected:
      Value
      _xsd_NetworkTypes_convert () const;

      public:
      static const char* const _xsd_NetworkTypes_literals_[2];
      static const Value _xsd_NetworkTypes_indexes_[2];
    };

    class Space: public ::neurona::schema::Base
    {
      public:
      // structure
      //
      typedef ::neurona::schema::SpaceStructure StructureType;
      typedef ::xsd::cxx::tree::optional< StructureType > StructureOptional;
      typedef ::xsd::cxx::tree::traits< StructureType, char > StructureTraits;

      const StructureOptional&
      structure () const;

      StructureOptional&
      structure ();

      void
      setStructure (const StructureType& x);

      void
      setStructure (const StructureOptional& x);

      void
      setStructure (::std::unique_ptr< StructureType > p);

      // basedOn
      //
      typedef ::neurona::schema::AllowedSpaces BasedOnType;
      typedef ::xsd::cxx::tree::optional< BasedOnType > BasedOnOptional;
      typedef ::xsd::cxx::tree::traits< BasedOnType, char > BasedOnTraits;

      const BasedOnOptional&
      basedOn () const;

      BasedOnOptional&
      basedOn ();

      void
      setBasedOn (const BasedOnType& x);

      void
      setBasedOn (const BasedOnOptional& x);

      void
      setBasedOn (::std::unique_ptr< BasedOnType > p);

      // Constructors.
      //
      Space (const IdType&);

      Space (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      Space (const Space& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual Space*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Space&
      operator= (const Space& x);

      virtual 
      ~Space ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      StructureOptional structure_;
      BasedOnOptional basedOn_;
    };

    class SpaceStructure: public ::xml_schema::Type
    {
      public:
      // xSpacing
      //
      typedef ::xml_schema::Float XSpacingType;
      typedef ::xsd::cxx::tree::optional< XSpacingType > XSpacingOptional;
      typedef ::xsd::cxx::tree::traits< XSpacingType, char > XSpacingTraits;

      const XSpacingOptional&
      xSpacing () const;

      XSpacingOptional&
      xSpacing ();

      void
      setXSpacing (const XSpacingType& x);

      void
      setXSpacing (const XSpacingOptional& x);

      // ySpacing
      //
      typedef ::xml_schema::Float YSpacingType;
      typedef ::xsd::cxx::tree::optional< YSpacingType > YSpacingOptional;
      typedef ::xsd::cxx::tree::traits< YSpacingType, char > YSpacingTraits;

      const YSpacingOptional&
      ySpacing () const;

      YSpacingOptional&
      ySpacing ();

      void
      setYSpacing (const YSpacingType& x);

      void
      setYSpacing (const YSpacingOptional& x);

      // zSpacing
      //
      typedef ::xml_schema::Float ZSpacingType;
      typedef ::xsd::cxx::tree::optional< ZSpacingType > ZSpacingOptional;
      typedef ::xsd::cxx::tree::traits< ZSpacingType, char > ZSpacingTraits;

      const ZSpacingOptional&
      zSpacing () const;

      ZSpacingOptional&
      zSpacing ();

      void
      setZSpacing (const ZSpacingType& x);

      void
      setZSpacing (const ZSpacingOptional& x);

      // xStart
      //
      typedef ::xml_schema::Float XStartType;
      typedef ::xsd::cxx::tree::traits< XStartType, char > XStartTraits;

      const XStartType&
      xStart () const;

      XStartType&
      xStart ();

      void
      setXStart (const XStartType& x);

      static XStartType
      xStartDefaultValue ();

      // yStart
      //
      typedef ::xml_schema::Float YStartType;
      typedef ::xsd::cxx::tree::traits< YStartType, char > YStartTraits;

      const YStartType&
      yStart () const;

      YStartType&
      yStart ();

      void
      setYStart (const YStartType& x);

      static YStartType
      yStartDefaultValue ();

      // zStart
      //
      typedef ::xml_schema::Float ZStartType;
      typedef ::xsd::cxx::tree::traits< ZStartType, char > ZStartTraits;

      const ZStartType&
      zStart () const;

      ZStartType&
      zStart ();

      void
      setZStart (const ZStartType& x);

      static ZStartType
      zStartDefaultValue ();

      // Constructors.
      //
      SpaceStructure ();

      SpaceStructure (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      SpaceStructure (const SpaceStructure& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual SpaceStructure*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SpaceStructure&
      operator= (const SpaceStructure& x);

      virtual 
      ~SpaceStructure ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      XSpacingOptional xSpacing_;
      YSpacingOptional ySpacing_;
      ZSpacingOptional zSpacing_;
      ::xsd::cxx::tree::one< XStartType > xStart_;
      ::xsd::cxx::tree::one< YStartType > yStart_;
      ::xsd::cxx::tree::one< ZStartType > zStart_;
    };

    class AllowedSpaces: public ::xml_schema::String
    {
      public:
      enum Value
      {
        Euclidean_1D,
        Euclidean_2D,
        Euclidean_3D,
        Grid_1D,
        Grid_2D,
        Grid_3D
      };

      AllowedSpaces (Value v);

      AllowedSpaces (const char* v);

      AllowedSpaces (const ::std::string& v);

      AllowedSpaces (const ::xml_schema::String& v);

      AllowedSpaces (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      AllowedSpaces (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      AllowedSpaces (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      AllowedSpaces (const AllowedSpaces& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual AllowedSpaces*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      AllowedSpaces&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_AllowedSpaces_convert ();
      }

      protected:
      Value
      _xsd_AllowedSpaces_convert () const;

      public:
      static const char* const _xsd_AllowedSpaces_literals_[6];
      static const Value _xsd_AllowedSpaces_indexes_[6];
    };

    class Region: public ::neurona::schema::Base
    {
      public:
      // space
      //
      typedef ::neurona::schema::NmlId SpaceType;
      typedef ::xsd::cxx::tree::optional< SpaceType > SpaceOptional;
      typedef ::xsd::cxx::tree::traits< SpaceType, char > SpaceTraits;

      const SpaceOptional&
      space () const;

      SpaceOptional&
      space ();

      void
      setSpace (const SpaceType& x);

      void
      setSpace (const SpaceOptional& x);

      void
      setSpace (::std::unique_ptr< SpaceType > p);

      // Constructors.
      //
      Region (const IdType&);

      Region (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      Region (const Region& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual Region*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Region&
      operator= (const Region& x);

      virtual 
      ~Region ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      SpaceOptional space_;
    };

    class Population: public ::neurona::schema::Standalone
    {
      public:
      // layout
      //
      typedef ::neurona::schema::Layout LayoutType;
      typedef ::xsd::cxx::tree::optional< LayoutType > LayoutOptional;
      typedef ::xsd::cxx::tree::traits< LayoutType, char > LayoutTraits;

      const LayoutOptional&
      layout () const;

      LayoutOptional&
      layout ();

      void
      setLayout (const LayoutType& x);

      void
      setLayout (const LayoutOptional& x);

      void
      setLayout (::std::unique_ptr< LayoutType > p);

      // instance
      //
      typedef ::neurona::schema::Instance InstanceType;
      typedef ::xsd::cxx::tree::sequence< InstanceType > InstanceSequence;
      typedef InstanceSequence::iterator InstanceIterator;
      typedef InstanceSequence::const_iterator InstanceConstIterator;
      typedef ::xsd::cxx::tree::traits< InstanceType, char > InstanceTraits;

      const InstanceSequence&
      instances () const;

      InstanceSequence&
      instances ();

      void
      setInstances (const InstanceSequence& s);

      // cell
      //
      typedef ::neurona::schema::NmlId CellType;
      typedef ::xsd::cxx::tree::optional< CellType > CellOptional;
      typedef ::xsd::cxx::tree::traits< CellType, char > CellTraits;

      const CellOptional&
      cell () const;

      CellOptional&
      cell ();

      void
      setCell (const CellType& x);

      void
      setCell (const CellOptional& x);

      void
      setCell (::std::unique_ptr< CellType > p);

      // network
      //
      typedef ::neurona::schema::NmlId NetworkType;
      typedef ::xsd::cxx::tree::optional< NetworkType > NetworkOptional;
      typedef ::xsd::cxx::tree::traits< NetworkType, char > NetworkTraits;

      const NetworkOptional&
      network () const;

      NetworkOptional&
      network ();

      void
      setNetwork (const NetworkType& x);

      void
      setNetwork (const NetworkOptional& x);

      void
      setNetwork (::std::unique_ptr< NetworkType > p);

      // component
      //
      typedef ::neurona::schema::NmlId ComponentType;
      typedef ::xsd::cxx::tree::optional< ComponentType > ComponentOptional;
      typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

      const ComponentOptional&
      component () const;

      ComponentOptional&
      component ();

      void
      setComponent (const ComponentType& x);

      void
      setComponent (const ComponentOptional& x);

      void
      setComponent (::std::unique_ptr< ComponentType > p);

      // size
      //
      typedef ::xml_schema::Integer SizeType;
      typedef ::xsd::cxx::tree::optional< SizeType > SizeOptional;
      typedef ::xsd::cxx::tree::traits< SizeType, char > SizeTraits;

      const SizeOptional&
      size () const;

      SizeOptional&
      size ();

      void
      setSize (const SizeType& x);

      void
      setSize (const SizeOptional& x);

      // type
      //
      typedef ::neurona::schema::PopulationTypes TypeType;
      typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
      typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

      const TypeOptional&
      type () const;

      TypeOptional&
      type ();

      void
      setType (const TypeType& x);

      void
      setType (const TypeOptional& x);

      void
      setType (::std::unique_ptr< TypeType > p);

      // extracellularProperties
      //
      typedef ::neurona::schema::NmlId ExtracellularPropertiesType;
      typedef ::xsd::cxx::tree::optional< ExtracellularPropertiesType > ExtracellularPropertiesOptional;
      typedef ::xsd::cxx::tree::traits< ExtracellularPropertiesType, char > ExtracellularPropertiesTraits;

      const ExtracellularPropertiesOptional&
      extracellularProperties () const;

      ExtracellularPropertiesOptional&
      extracellularProperties ();

      void
      setExtracellularProperties (const ExtracellularPropertiesType& x);

      void
      setExtracellularProperties (const ExtracellularPropertiesOptional& x);

      void
      setExtracellularProperties (::std::unique_ptr< ExtracellularPropertiesType > p);

      // Constructors.
      //
      Population (const IdType&);

      Population (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      Population (const Population& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual Population*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Population&
      operator= (const Population& x);

      virtual 
      ~Population ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      LayoutOptional layout_;
      InstanceSequence instance_;
      CellOptional cell_;
      NetworkOptional network_;
      ComponentOptional component_;
      SizeOptional size_;
      TypeOptional type_;
      ExtracellularPropertiesOptional extracellularProperties_;
    };

    class PopulationTypes: public ::xml_schema::String
    {
      public:
      enum Value
      {
        population,
        populationList
      };

      PopulationTypes (Value v);

      PopulationTypes (const char* v);

      PopulationTypes (const ::std::string& v);

      PopulationTypes (const ::xml_schema::String& v);

      PopulationTypes (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      PopulationTypes (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      PopulationTypes (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      PopulationTypes (const PopulationTypes& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual PopulationTypes*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      PopulationTypes&
      operator= (Value v);

      virtual
      operator Value () const
      {
        return _xsd_PopulationTypes_convert ();
      }

      protected:
      Value
      _xsd_PopulationTypes_convert () const;

      public:
      static const char* const _xsd_PopulationTypes_literals_[2];
      static const Value _xsd_PopulationTypes_indexes_[2];
    };

    class Layout: public ::xml_schema::Type
    {
      public:
      // random
      //
      typedef ::neurona::schema::RandomLayout RandomType;
      typedef ::xsd::cxx::tree::optional< RandomType > RandomOptional;
      typedef ::xsd::cxx::tree::traits< RandomType, char > RandomTraits;

      const RandomOptional&
      random () const;

      RandomOptional&
      random ();

      void
      setRandom (const RandomType& x);

      void
      setRandom (const RandomOptional& x);

      void
      setRandom (::std::unique_ptr< RandomType > p);

      // grid
      //
      typedef ::neurona::schema::GridLayout GridType;
      typedef ::xsd::cxx::tree::optional< GridType > GridOptional;
      typedef ::xsd::cxx::tree::traits< GridType, char > GridTraits;

      const GridOptional&
      grid () const;

      GridOptional&
      grid ();

      void
      setGrid (const GridType& x);

      void
      setGrid (const GridOptional& x);

      void
      setGrid (::std::unique_ptr< GridType > p);

      // unstructured
      //
      typedef ::neurona::schema::UnstructuredLayout UnstructuredType;
      typedef ::xsd::cxx::tree::optional< UnstructuredType > UnstructuredOptional;
      typedef ::xsd::cxx::tree::traits< UnstructuredType, char > UnstructuredTraits;

      const UnstructuredOptional&
      unstructured () const;

      UnstructuredOptional&
      unstructured ();

      void
      setUnstructured (const UnstructuredType& x);

      void
      setUnstructured (const UnstructuredOptional& x);

      void
      setUnstructured (::std::unique_ptr< UnstructuredType > p);

      // space
      //
      typedef ::neurona::schema::NmlId SpaceType;
      typedef ::xsd::cxx::tree::optional< SpaceType > SpaceOptional;
      typedef ::xsd::cxx::tree::traits< SpaceType, char > SpaceTraits;

      const SpaceOptional&
      space () const;

      SpaceOptional&
      space ();

      void
      setSpace (const SpaceType& x);

      void
      setSpace (const SpaceOptional& x);

      void
      setSpace (::std::unique_ptr< SpaceType > p);

      // Constructors.
      //
      Layout ();

      Layout (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      Layout (const Layout& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      virtual Layout*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Layout&
      operator= (const Layout& x);

      virtual 
      ~Layout ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      RandomOptional random_;
      GridOptional grid_;
      UnstructuredOptional unstructured_;
      SpaceOptional space_;
    };

    class UnstructuredLayout: public ::xml_schema::Type
    {
      public:
      // number
      //
      typedef ::xml_schema::NonNegativeInteger NumberType;
      typedef ::xsd::cxx::tree::optional< NumberType > NumberOptional;
      typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

      const NumberOptional&
      number () const;

      NumberOptional&
      number ();

      void
      setNumber (const NumberType& x);

      void
      setNumber (const NumberOptional& x);

      // Constructors.
      //
      UnstructuredLayout ();

      UnstructuredLayout (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      UnstructuredLayout (const UnstructuredLayout& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual UnstructuredLayout*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      UnstructuredLayout&
      operator= (const UnstructuredLayout& x);

      virtual 
      ~UnstructuredLayout ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NumberOptional number_;
    };

    class RandomLayout: public ::xml_schema::Type
    {
      public:
      // number
      //
      typedef ::xml_schema::NonNegativeInteger NumberType;
      typedef ::xsd::cxx::tree::optional< NumberType > NumberOptional;
      typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

      const NumberOptional&
      number () const;

      NumberOptional&
      number ();

      void
      setNumber (const NumberType& x);

      void
      setNumber (const NumberOptional& x);

      // region
      //
      typedef ::neurona::schema::NmlId RegionType;
      typedef ::xsd::cxx::tree::optional< RegionType > RegionOptional;
      typedef ::xsd::cxx::tree::traits< RegionType, char > RegionTraits;

      const RegionOptional&
      region () const;

      RegionOptional&
      region ();

      void
      setRegion (const RegionType& x);

      void
      setRegion (const RegionOptional& x);

      void
      setRegion (::std::unique_ptr< RegionType > p);

      // Constructors.
      //
      RandomLayout ();

      RandomLayout (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      RandomLayout (const RandomLayout& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual RandomLayout*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      RandomLayout&
      operator= (const RandomLayout& x);

      virtual 
      ~RandomLayout ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      NumberOptional number_;
      RegionOptional region_;
    };

    class GridLayout: public ::xml_schema::Type
    {
      public:
      // xSize
      //
      typedef ::xml_schema::NonNegativeInteger XSizeType;
      typedef ::xsd::cxx::tree::optional< XSizeType > XSizeOptional;
      typedef ::xsd::cxx::tree::traits< XSizeType, char > XSizeTraits;

      const XSizeOptional&
      xSize () const;

      XSizeOptional&
      xSize ();

      void
      setXSize (const XSizeType& x);

      void
      setXSize (const XSizeOptional& x);

      // ySize
      //
      typedef ::xml_schema::NonNegativeInteger YSizeType;
      typedef ::xsd::cxx::tree::optional< YSizeType > YSizeOptional;
      typedef ::xsd::cxx::tree::traits< YSizeType, char > YSizeTraits;

      const YSizeOptional&
      ySize () const;

      YSizeOptional&
      ySize ();

      void
      setYSize (const YSizeType& x);

      void
      setYSize (const YSizeOptional& x);

      // zSize
      //
      typedef ::xml_schema::NonNegativeInteger ZSizeType;
      typedef ::xsd::cxx::tree::optional< ZSizeType > ZSizeOptional;
      typedef ::xsd::cxx::tree::traits< ZSizeType, char > ZSizeTraits;

      const ZSizeOptional&
      zSize () const;

      ZSizeOptional&
      zSize ();

      void
      setZSize (const ZSizeType& x);

      void
      setZSize (const ZSizeOptional& x);

      // Constructors.
      //
      GridLayout ();

      GridLayout (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      GridLayout (const GridLayout& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual GridLayout*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      GridLayout&
      operator= (const GridLayout& x);

      virtual 
      ~GridLayout ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      XSizeOptional xSize_;
      YSizeOptional ySize_;
      ZSizeOptional zSize_;
    };

    class Instance: public ::xml_schema::Type
    {
      public:
      // location
      //
      typedef ::neurona::schema::Location LocationType;
      typedef ::xsd::cxx::tree::traits< LocationType, char > LocationTraits;

      const LocationType&
      location () const;

      LocationType&
      location ();

      void
      setLocation (const LocationType& x);

      void
      setLocation (::std::unique_ptr< LocationType > p);

      // id
      //
      typedef ::xml_schema::NonNegativeInteger IdType;
      typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      const IdOptional&
      id () const;

      IdOptional&
      id ();

      void
      setId (const IdType& x);

      void
      setId (const IdOptional& x);

      // i
      //
      typedef ::xml_schema::NonNegativeInteger IType;
      typedef ::xsd::cxx::tree::optional< IType > IOptional;
      typedef ::xsd::cxx::tree::traits< IType, char > ITraits;

      const IOptional&
      i () const;

      IOptional&
      i ();

      void
      setI (const IType& x);

      void
      setI (const IOptional& x);

      // j
      //
      typedef ::xml_schema::NonNegativeInteger JType;
      typedef ::xsd::cxx::tree::optional< JType > JOptional;
      typedef ::xsd::cxx::tree::traits< JType, char > JTraits;

      const JOptional&
      j () const;

      JOptional&
      j ();

      void
      setJ (const JType& x);

      void
      setJ (const JOptional& x);

      // k
      //
      typedef ::xml_schema::NonNegativeInteger KType;
      typedef ::xsd::cxx::tree::optional< KType > KOptional;
      typedef ::xsd::cxx::tree::traits< KType, char > KTraits;

      const KOptional&
      k () const;

      KOptional&
      k ();

      void
      setK (const KType& x);

      void
      setK (const KOptional& x);

      // Constructors.
      //
      Instance (const LocationType&);

      Instance (::std::unique_ptr< LocationType >);

      Instance (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      Instance (const Instance& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual Instance*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Instance&
      operator= (const Instance& x);

      virtual 
      ~Instance ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< LocationType > location_;
      IdOptional id_;
      IOptional i_;
      JOptional j_;
      KOptional k_;
    };

    class Location: public ::xml_schema::Type
    {
      public:
      // x
      //
      typedef ::xml_schema::Float XType;
      typedef ::xsd::cxx::tree::optional< XType > XOptional;
      typedef ::xsd::cxx::tree::traits< XType, char > XTraits;

      const XOptional&
      x () const;

      XOptional&
      x ();

      void
      setX (const XType& x);

      void
      setX (const XOptional& x);

      // y
      //
      typedef ::xml_schema::Float YType;
      typedef ::xsd::cxx::tree::optional< YType > YOptional;
      typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

      const YOptional&
      y () const;

      YOptional&
      y ();

      void
      setY (const YType& x);

      void
      setY (const YOptional& x);

      // z
      //
      typedef ::xml_schema::Float ZType;
      typedef ::xsd::cxx::tree::optional< ZType > ZOptional;
      typedef ::xsd::cxx::tree::traits< ZType, char > ZTraits;

      const ZOptional&
      z () const;

      ZOptional&
      z ();

      void
      setZ (const ZType& x);

      void
      setZ (const ZOptional& x);

      // Constructors.
      //
      Location ();

      Location (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      Location (const Location& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      virtual Location*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Location&
      operator= (const Location& x);

      virtual 
      ~Location ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      XOptional x_;
      YOptional y_;
      ZOptional z_;
    };

    class CellSet: public ::neurona::schema::Base
    {
      public:
      // select
      //
      typedef ::xml_schema::String SelectType;
      typedef ::xsd::cxx::tree::traits< SelectType, char > SelectTraits;

      const SelectType&
      select () const;

      SelectType&
      select ();

      void
      setSelect (const SelectType& x);

      void
      setSelect (::std::unique_ptr< SelectType > p);

      // Constructors.
      //
      CellSet (const IdType&,
               const SelectType&);

      CellSet (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      CellSet (const CellSet& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      virtual CellSet*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      CellSet&
      operator= (const CellSet& x);

      virtual 
      ~CellSet ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< SelectType > select_;
    };

    class SynapticConnection: public ::xml_schema::Type
    {
      public:
      // from
      //
      typedef ::xml_schema::String FromType;
      typedef ::xsd::cxx::tree::optional< FromType > FromOptional;
      typedef ::xsd::cxx::tree::traits< FromType, char > FromTraits;

      const FromOptional&
      from () const;

      FromOptional&
      from ();

      void
      setFrom (const FromType& x);

      void
      setFrom (const FromOptional& x);

      void
      setFrom (::std::unique_ptr< FromType > p);

      // to
      //
      typedef ::xml_schema::String ToType;
      typedef ::xsd::cxx::tree::optional< ToType > ToOptional;
      typedef ::xsd::cxx::tree::traits< ToType, char > ToTraits;

      const ToOptional&
      to () const;

      ToOptional&
      to ();

      void
      setTo (const ToType& x);

      void
      setTo (const ToOptional& x);

      void
      setTo (::std::unique_ptr< ToType > p);

      // synapse
      //
      typedef ::xml_schema::String SynapseType;
      typedef ::xsd::cxx::tree::optional< SynapseType > SynapseOptional;
      typedef ::xsd::cxx::tree::traits< SynapseType, char > SynapseTraits;

      const SynapseOptional&
      synapse () const;

      SynapseOptional&
      synapse ();

      void
      setSynapse (const SynapseType& x);

      void
      setSynapse (const SynapseOptional& x);

      void
      setSynapse (::std::unique_ptr< SynapseType > p);

      // destination
      //
      typedef ::neurona::schema::NmlId DestinationType;
      typedef ::xsd::cxx::tree::optional< DestinationType > DestinationOptional;
      typedef ::xsd::cxx::tree::traits< DestinationType, char > DestinationTraits;

      const DestinationOptional&
      destination () const;

      DestinationOptional&
      destination ();

      void
      setDestination (const DestinationType& x);

      void
      setDestination (const DestinationOptional& x);

      void
      setDestination (::std::unique_ptr< DestinationType > p);

      // Constructors.
      //
      SynapticConnection ();

      SynapticConnection (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      SynapticConnection (const SynapticConnection& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual SynapticConnection*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SynapticConnection&
      operator= (const SynapticConnection& x);

      virtual 
      ~SynapticConnection ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      FromOptional from_;
      ToOptional to_;
      SynapseOptional synapse_;
      DestinationOptional destination_;
    };

    class Projection: public ::neurona::schema::Base
    {
      public:
      // connection
      //
      typedef ::neurona::schema::Connection ConnectionType;
      typedef ::xsd::cxx::tree::sequence< ConnectionType > ConnectionSequence;
      typedef ConnectionSequence::iterator ConnectionIterator;
      typedef ConnectionSequence::const_iterator ConnectionConstIterator;
      typedef ::xsd::cxx::tree::traits< ConnectionType, char > ConnectionTraits;

      const ConnectionSequence&
      connections () const;

      ConnectionSequence&
      connections ();

      void
      setConnections (const ConnectionSequence& s);

      // presynapticPopulation
      //
      typedef ::neurona::schema::NmlId PresynapticPopulationType;
      typedef ::xsd::cxx::tree::optional< PresynapticPopulationType > PresynapticPopulationOptional;
      typedef ::xsd::cxx::tree::traits< PresynapticPopulationType, char > PresynapticPopulationTraits;

      const PresynapticPopulationOptional&
      presynapticPopulation () const;

      PresynapticPopulationOptional&
      presynapticPopulation ();

      void
      setPresynapticPopulation (const PresynapticPopulationType& x);

      void
      setPresynapticPopulation (const PresynapticPopulationOptional& x);

      void
      setPresynapticPopulation (::std::unique_ptr< PresynapticPopulationType > p);

      // postsynapticPopulation
      //
      typedef ::neurona::schema::NmlId PostsynapticPopulationType;
      typedef ::xsd::cxx::tree::optional< PostsynapticPopulationType > PostsynapticPopulationOptional;
      typedef ::xsd::cxx::tree::traits< PostsynapticPopulationType, char > PostsynapticPopulationTraits;

      const PostsynapticPopulationOptional&
      postsynapticPopulation () const;

      PostsynapticPopulationOptional&
      postsynapticPopulation ();

      void
      setPostsynapticPopulation (const PostsynapticPopulationType& x);

      void
      setPostsynapticPopulation (const PostsynapticPopulationOptional& x);

      void
      setPostsynapticPopulation (::std::unique_ptr< PostsynapticPopulationType > p);

      // synapse
      //
      typedef ::neurona::schema::NmlId SynapseType;
      typedef ::xsd::cxx::tree::optional< SynapseType > SynapseOptional;
      typedef ::xsd::cxx::tree::traits< SynapseType, char > SynapseTraits;

      const SynapseOptional&
      synapse () const;

      SynapseOptional&
      synapse ();

      void
      setSynapse (const SynapseType& x);

      void
      setSynapse (const SynapseOptional& x);

      void
      setSynapse (::std::unique_ptr< SynapseType > p);

      // Constructors.
      //
      Projection (const IdType&);

      Projection (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      Projection (const Projection& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual Projection*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Projection&
      operator= (const Projection& x);

      virtual 
      ~Projection ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ConnectionSequence connection_;
      PresynapticPopulationOptional presynapticPopulation_;
      PostsynapticPopulationOptional postsynapticPopulation_;
      SynapseOptional synapse_;
    };

    class Connection: public ::xml_schema::Type
    {
      public:
      // id
      //
      typedef ::xml_schema::NonNegativeInteger IdType;
      typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      const IdOptional&
      id () const;

      IdOptional&
      id ();

      void
      setId (const IdType& x);

      void
      setId (const IdOptional& x);

      // preCellId
      //
      typedef ::xml_schema::String PreCellIdType;
      typedef ::xsd::cxx::tree::optional< PreCellIdType > PreCellIdOptional;
      typedef ::xsd::cxx::tree::traits< PreCellIdType, char > PreCellIdTraits;

      const PreCellIdOptional&
      preCellId () const;

      PreCellIdOptional&
      preCellId ();

      void
      setPreCellId (const PreCellIdType& x);

      void
      setPreCellId (const PreCellIdOptional& x);

      void
      setPreCellId (::std::unique_ptr< PreCellIdType > p);

      // preSegmentId
      //
      typedef ::neurona::schema::SegmentId PreSegmentIdType;
      typedef ::xsd::cxx::tree::optional< PreSegmentIdType > PreSegmentIdOptional;
      typedef ::xsd::cxx::tree::traits< PreSegmentIdType, char > PreSegmentIdTraits;

      const PreSegmentIdOptional&
      preSegmentId () const;

      PreSegmentIdOptional&
      preSegmentId ();

      void
      setPreSegmentId (const PreSegmentIdType& x);

      void
      setPreSegmentId (const PreSegmentIdOptional& x);

      void
      setPreSegmentId (::std::unique_ptr< PreSegmentIdType > p);

      // preFractionAlong
      //
      typedef ::neurona::schema::ZeroToOne PreFractionAlongType;
      typedef ::xsd::cxx::tree::optional< PreFractionAlongType > PreFractionAlongOptional;
      typedef ::xsd::cxx::tree::traits< PreFractionAlongType, char > PreFractionAlongTraits;

      const PreFractionAlongOptional&
      preFractionAlong () const;

      PreFractionAlongOptional&
      preFractionAlong ();

      void
      setPreFractionAlong (const PreFractionAlongType& x);

      void
      setPreFractionAlong (const PreFractionAlongOptional& x);

      void
      setPreFractionAlong (::std::unique_ptr< PreFractionAlongType > p);

      // postCellId
      //
      typedef ::xml_schema::String PostCellIdType;
      typedef ::xsd::cxx::tree::optional< PostCellIdType > PostCellIdOptional;
      typedef ::xsd::cxx::tree::traits< PostCellIdType, char > PostCellIdTraits;

      const PostCellIdOptional&
      postCellId () const;

      PostCellIdOptional&
      postCellId ();

      void
      setPostCellId (const PostCellIdType& x);

      void
      setPostCellId (const PostCellIdOptional& x);

      void
      setPostCellId (::std::unique_ptr< PostCellIdType > p);

      // postSegmentId
      //
      typedef ::neurona::schema::SegmentId PostSegmentIdType;
      typedef ::xsd::cxx::tree::optional< PostSegmentIdType > PostSegmentIdOptional;
      typedef ::xsd::cxx::tree::traits< PostSegmentIdType, char > PostSegmentIdTraits;

      const PostSegmentIdOptional&
      postSegmentId () const;

      PostSegmentIdOptional&
      postSegmentId ();

      void
      setPostSegmentId (const PostSegmentIdType& x);

      void
      setPostSegmentId (const PostSegmentIdOptional& x);

      void
      setPostSegmentId (::std::unique_ptr< PostSegmentIdType > p);

      // postFractionAlong
      //
      typedef ::neurona::schema::ZeroToOne PostFractionAlongType;
      typedef ::xsd::cxx::tree::optional< PostFractionAlongType > PostFractionAlongOptional;
      typedef ::xsd::cxx::tree::traits< PostFractionAlongType, char > PostFractionAlongTraits;

      const PostFractionAlongOptional&
      postFractionAlong () const;

      PostFractionAlongOptional&
      postFractionAlong ();

      void
      setPostFractionAlong (const PostFractionAlongType& x);

      void
      setPostFractionAlong (const PostFractionAlongOptional& x);

      void
      setPostFractionAlong (::std::unique_ptr< PostFractionAlongType > p);

      // Constructors.
      //
      Connection ();

      Connection (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      Connection (const Connection& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

      virtual Connection*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Connection&
      operator= (const Connection& x);

      virtual 
      ~Connection ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      IdOptional id_;
      PreCellIdOptional preCellId_;
      PreSegmentIdOptional preSegmentId_;
      PreFractionAlongOptional preFractionAlong_;
      PostCellIdOptional postCellId_;
      PostSegmentIdOptional postSegmentId_;
      PostFractionAlongOptional postFractionAlong_;
    };

    class ExplicitInput: public ::xml_schema::Type
    {
      public:
      // target
      //
      typedef ::xml_schema::String TargetType;
      typedef ::xsd::cxx::tree::optional< TargetType > TargetOptional;
      typedef ::xsd::cxx::tree::traits< TargetType, char > TargetTraits;

      const TargetOptional&
      target () const;

      TargetOptional&
      target ();

      void
      setTarget (const TargetType& x);

      void
      setTarget (const TargetOptional& x);

      void
      setTarget (::std::unique_ptr< TargetType > p);

      // input
      //
      typedef ::xml_schema::String InputType;
      typedef ::xsd::cxx::tree::optional< InputType > InputOptional;
      typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

      const InputOptional&
      input () const;

      InputOptional&
      input ();

      void
      setInput (const InputType& x);

      void
      setInput (const InputOptional& x);

      void
      setInput (::std::unique_ptr< InputType > p);

      // destination
      //
      typedef ::xml_schema::String DestinationType;
      typedef ::xsd::cxx::tree::optional< DestinationType > DestinationOptional;
      typedef ::xsd::cxx::tree::traits< DestinationType, char > DestinationTraits;

      const DestinationOptional&
      destination () const;

      DestinationOptional&
      destination ();

      void
      setDestination (const DestinationType& x);

      void
      setDestination (const DestinationOptional& x);

      void
      setDestination (::std::unique_ptr< DestinationType > p);

      // Constructors.
      //
      ExplicitInput ();

      ExplicitInput (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      ExplicitInput (const ExplicitInput& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual ExplicitInput*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ExplicitInput&
      operator= (const ExplicitInput& x);

      virtual 
      ~ExplicitInput ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      TargetOptional target_;
      InputOptional input_;
      DestinationOptional destination_;
    };

    class InputList: public ::neurona::schema::Base
    {
      public:
      // input
      //
      typedef ::neurona::schema::Input InputType;
      typedef ::xsd::cxx::tree::sequence< InputType > InputSequence;
      typedef InputSequence::iterator InputIterator;
      typedef InputSequence::const_iterator InputConstIterator;
      typedef ::xsd::cxx::tree::traits< InputType, char > InputTraits;

      const InputSequence&
      inputs () const;

      InputSequence&
      inputs ();

      void
      setInputs (const InputSequence& s);

      // population
      //
      typedef ::neurona::schema::NmlId PopulationType;
      typedef ::xsd::cxx::tree::optional< PopulationType > PopulationOptional;
      typedef ::xsd::cxx::tree::traits< PopulationType, char > PopulationTraits;

      const PopulationOptional&
      population () const;

      PopulationOptional&
      population ();

      void
      setPopulation (const PopulationType& x);

      void
      setPopulation (const PopulationOptional& x);

      void
      setPopulation (::std::unique_ptr< PopulationType > p);

      // component
      //
      typedef ::neurona::schema::NmlId ComponentType;
      typedef ::xsd::cxx::tree::optional< ComponentType > ComponentOptional;
      typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

      const ComponentOptional&
      component () const;

      ComponentOptional&
      component ();

      void
      setComponent (const ComponentType& x);

      void
      setComponent (const ComponentOptional& x);

      void
      setComponent (::std::unique_ptr< ComponentType > p);

      // Constructors.
      //
      InputList (const IdType&);

      InputList (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      InputList (const InputList& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      virtual InputList*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      InputList&
      operator= (const InputList& x);

      virtual 
      ~InputList ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      InputSequence input_;
      PopulationOptional population_;
      ComponentOptional component_;
    };

    class Input: public ::xml_schema::Type
    {
      public:
      // id
      //
      typedef ::xml_schema::NonNegativeInteger IdType;
      typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      const IdOptional&
      id () const;

      IdOptional&
      id ();

      void
      setId (const IdType& x);

      void
      setId (const IdOptional& x);

      // target
      //
      typedef ::xml_schema::String TargetType;
      typedef ::xsd::cxx::tree::optional< TargetType > TargetOptional;
      typedef ::xsd::cxx::tree::traits< TargetType, char > TargetTraits;

      const TargetOptional&
      target () const;

      TargetOptional&
      target ();

      void
      setTarget (const TargetType& x);

      void
      setTarget (const TargetOptional& x);

      void
      setTarget (::std::unique_ptr< TargetType > p);

      // destination
      //
      typedef ::neurona::schema::NmlId DestinationType;
      typedef ::xsd::cxx::tree::optional< DestinationType > DestinationOptional;
      typedef ::xsd::cxx::tree::traits< DestinationType, char > DestinationTraits;

      const DestinationOptional&
      destination () const;

      DestinationOptional&
      destination ();

      void
      setDestination (const DestinationType& x);

      void
      setDestination (const DestinationOptional& x);

      void
      setDestination (::std::unique_ptr< DestinationType > p);

      // segmentId
      //
      typedef ::neurona::schema::SegmentId SegmentIdType;
      typedef ::xsd::cxx::tree::optional< SegmentIdType > SegmentIdOptional;
      typedef ::xsd::cxx::tree::traits< SegmentIdType, char > SegmentIdTraits;

      const SegmentIdOptional&
      segmentId () const;

      SegmentIdOptional&
      segmentId ();

      void
      setSegmentId (const SegmentIdType& x);

      void
      setSegmentId (const SegmentIdOptional& x);

      void
      setSegmentId (::std::unique_ptr< SegmentIdType > p);

      // fractionAlong
      //
      typedef ::neurona::schema::ZeroToOne FractionAlongType;
      typedef ::xsd::cxx::tree::optional< FractionAlongType > FractionAlongOptional;
      typedef ::xsd::cxx::tree::traits< FractionAlongType, char > FractionAlongTraits;

      const FractionAlongOptional&
      fractionAlong () const;

      FractionAlongOptional&
      fractionAlong ();

      void
      setFractionAlong (const FractionAlongType& x);

      void
      setFractionAlong (const FractionAlongOptional& x);

      void
      setFractionAlong (::std::unique_ptr< FractionAlongType > p);

      // Constructors.
      //
      Input ();

      Input (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      Input (const Input& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      virtual Input*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      Input&
      operator= (const Input& x);

      virtual 
      ~Input ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      IdOptional id_;
      TargetOptional target_;
      DestinationOptional destination_;
      SegmentIdOptional segmentId_;
      FractionAlongOptional fractionAlong_;
    };

    class BasePyNNCell: public ::neurona::schema::BaseCell
    {
      public:
      // cm
      //
      typedef ::xml_schema::Double CmType;
      typedef ::xsd::cxx::tree::optional< CmType > CmOptional;
      typedef ::xsd::cxx::tree::traits< CmType, char, ::xsd::cxx::tree::schema_type::double_ > CmTraits;

      const CmOptional&
      cm () const;

      CmOptional&
      cm ();

      void
      setCm (const CmType& x);

      void
      setCm (const CmOptional& x);

      // i_offset
      //
      typedef ::xml_schema::Double I_offsetType;
      typedef ::xsd::cxx::tree::optional< I_offsetType > I_offsetOptional;
      typedef ::xsd::cxx::tree::traits< I_offsetType, char, ::xsd::cxx::tree::schema_type::double_ > I_offsetTraits;

      const I_offsetOptional&
      i_offset () const;

      I_offsetOptional&
      i_offset ();

      void
      setI_offset (const I_offsetType& x);

      void
      setI_offset (const I_offsetOptional& x);

      // tau_syn_E
      //
      typedef ::xml_schema::Double Tau_syn_EType;
      typedef ::xsd::cxx::tree::optional< Tau_syn_EType > Tau_syn_EOptional;
      typedef ::xsd::cxx::tree::traits< Tau_syn_EType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_syn_ETraits;

      const Tau_syn_EOptional&
      tau_syn_E () const;

      Tau_syn_EOptional&
      tau_syn_E ();

      void
      setTau_syn_E (const Tau_syn_EType& x);

      void
      setTau_syn_E (const Tau_syn_EOptional& x);

      // tau_syn_I
      //
      typedef ::xml_schema::Double Tau_syn_IType;
      typedef ::xsd::cxx::tree::optional< Tau_syn_IType > Tau_syn_IOptional;
      typedef ::xsd::cxx::tree::traits< Tau_syn_IType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_syn_ITraits;

      const Tau_syn_IOptional&
      tau_syn_I () const;

      Tau_syn_IOptional&
      tau_syn_I ();

      void
      setTau_syn_I (const Tau_syn_IType& x);

      void
      setTau_syn_I (const Tau_syn_IOptional& x);

      // v_init
      //
      typedef ::xml_schema::Double V_initType;
      typedef ::xsd::cxx::tree::optional< V_initType > V_initOptional;
      typedef ::xsd::cxx::tree::traits< V_initType, char, ::xsd::cxx::tree::schema_type::double_ > V_initTraits;

      const V_initOptional&
      v_init () const;

      V_initOptional&
      v_init ();

      void
      setV_init (const V_initType& x);

      void
      setV_init (const V_initOptional& x);

      // Constructors.
      //
      BasePyNNCell (const IdType&);

      BasePyNNCell (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      BasePyNNCell (const BasePyNNCell& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      virtual BasePyNNCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BasePyNNCell&
      operator= (const BasePyNNCell& x);

      virtual 
      ~BasePyNNCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      CmOptional cm_;
      I_offsetOptional i_offset_;
      Tau_syn_EOptional tau_syn_E_;
      Tau_syn_IOptional tau_syn_I_;
      V_initOptional v_init_;
    };

    class BasePyNNIaFCell: public ::neurona::schema::BasePyNNCell
    {
      public:
      // tau_m
      //
      typedef ::xml_schema::Double Tau_mType;
      typedef ::xsd::cxx::tree::optional< Tau_mType > Tau_mOptional;
      typedef ::xsd::cxx::tree::traits< Tau_mType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_mTraits;

      const Tau_mOptional&
      tau_m () const;

      Tau_mOptional&
      tau_m ();

      void
      setTau_m (const Tau_mType& x);

      void
      setTau_m (const Tau_mOptional& x);

      // tau_refrac
      //
      typedef ::xml_schema::Double Tau_refracType;
      typedef ::xsd::cxx::tree::optional< Tau_refracType > Tau_refracOptional;
      typedef ::xsd::cxx::tree::traits< Tau_refracType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_refracTraits;

      const Tau_refracOptional&
      tau_refrac () const;

      Tau_refracOptional&
      tau_refrac ();

      void
      setTau_refrac (const Tau_refracType& x);

      void
      setTau_refrac (const Tau_refracOptional& x);

      // v_reset
      //
      typedef ::xml_schema::Double V_resetType;
      typedef ::xsd::cxx::tree::optional< V_resetType > V_resetOptional;
      typedef ::xsd::cxx::tree::traits< V_resetType, char, ::xsd::cxx::tree::schema_type::double_ > V_resetTraits;

      const V_resetOptional&
      v_reset () const;

      V_resetOptional&
      v_reset ();

      void
      setV_reset (const V_resetType& x);

      void
      setV_reset (const V_resetOptional& x);

      // v_rest
      //
      typedef ::xml_schema::Double V_restType;
      typedef ::xsd::cxx::tree::optional< V_restType > V_restOptional;
      typedef ::xsd::cxx::tree::traits< V_restType, char, ::xsd::cxx::tree::schema_type::double_ > V_restTraits;

      const V_restOptional&
      v_rest () const;

      V_restOptional&
      v_rest ();

      void
      setV_rest (const V_restType& x);

      void
      setV_rest (const V_restOptional& x);

      // v_thresh
      //
      typedef ::xml_schema::Double V_threshType;
      typedef ::xsd::cxx::tree::optional< V_threshType > V_threshOptional;
      typedef ::xsd::cxx::tree::traits< V_threshType, char, ::xsd::cxx::tree::schema_type::double_ > V_threshTraits;

      const V_threshOptional&
      v_thresh () const;

      V_threshOptional&
      v_thresh ();

      void
      setV_thresh (const V_threshType& x);

      void
      setV_thresh (const V_threshOptional& x);

      // Constructors.
      //
      BasePyNNIaFCell (const IdType&);

      BasePyNNIaFCell (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      BasePyNNIaFCell (const BasePyNNIaFCell& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual BasePyNNIaFCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BasePyNNIaFCell&
      operator= (const BasePyNNIaFCell& x);

      virtual 
      ~BasePyNNIaFCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      Tau_mOptional tau_m_;
      Tau_refracOptional tau_refrac_;
      V_resetOptional v_reset_;
      V_restOptional v_rest_;
      V_threshOptional v_thresh_;
    };

    class BasePyNNIaFCondCell: public ::neurona::schema::BasePyNNIaFCell
    {
      public:
      // e_rev_E
      //
      typedef ::xml_schema::Double E_rev_EType;
      typedef ::xsd::cxx::tree::optional< E_rev_EType > E_rev_EOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_EType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_ETraits;

      const E_rev_EOptional&
      e_rev_E () const;

      E_rev_EOptional&
      e_rev_E ();

      void
      setE_rev_E (const E_rev_EType& x);

      void
      setE_rev_E (const E_rev_EOptional& x);

      // e_rev_I
      //
      typedef ::xml_schema::Double E_rev_IType;
      typedef ::xsd::cxx::tree::optional< E_rev_IType > E_rev_IOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_IType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_ITraits;

      const E_rev_IOptional&
      e_rev_I () const;

      E_rev_IOptional&
      e_rev_I ();

      void
      setE_rev_I (const E_rev_IType& x);

      void
      setE_rev_I (const E_rev_IOptional& x);

      // Constructors.
      //
      BasePyNNIaFCondCell (const IdType&);

      BasePyNNIaFCondCell (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      BasePyNNIaFCondCell (const BasePyNNIaFCondCell& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

      virtual BasePyNNIaFCondCell*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BasePyNNIaFCondCell&
      operator= (const BasePyNNIaFCondCell& x);

      virtual 
      ~BasePyNNIaFCondCell ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      E_rev_EOptional e_rev_E_;
      E_rev_IOptional e_rev_I_;
    };

    class IF_curr_alpha: public ::neurona::schema::BasePyNNIaFCell
    {
      public:
      // Constructors.
      //
      IF_curr_alpha (const IdType&);

      IF_curr_alpha (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      IF_curr_alpha (const IF_curr_alpha& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual IF_curr_alpha*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~IF_curr_alpha ();
    };

    class IF_curr_exp: public ::neurona::schema::BasePyNNIaFCell
    {
      public:
      // Constructors.
      //
      IF_curr_exp (const IdType&);

      IF_curr_exp (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      IF_curr_exp (const IF_curr_exp& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual IF_curr_exp*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~IF_curr_exp ();
    };

    class IF_cond_alpha: public ::neurona::schema::BasePyNNIaFCondCell
    {
      public:
      // Constructors.
      //
      IF_cond_alpha (const IdType&);

      IF_cond_alpha (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      IF_cond_alpha (const IF_cond_alpha& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

      virtual IF_cond_alpha*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~IF_cond_alpha ();
    };

    class IF_cond_exp: public ::neurona::schema::BasePyNNIaFCondCell
    {
      public:
      // Constructors.
      //
      IF_cond_exp (const IdType&);

      IF_cond_exp (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      IF_cond_exp (const IF_cond_exp& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual IF_cond_exp*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~IF_cond_exp ();
    };

    class EIF_cond_exp_isfa_ista: public ::neurona::schema::BasePyNNIaFCondCell
    {
      public:
      // a
      //
      typedef ::xml_schema::Double AType;
      typedef ::xsd::cxx::tree::optional< AType > AOptional;
      typedef ::xsd::cxx::tree::traits< AType, char, ::xsd::cxx::tree::schema_type::double_ > ATraits;

      const AOptional&
      a () const;

      AOptional&
      a ();

      void
      setA (const AType& x);

      void
      setA (const AOptional& x);

      // b
      //
      typedef ::xml_schema::Double BType;
      typedef ::xsd::cxx::tree::optional< BType > BOptional;
      typedef ::xsd::cxx::tree::traits< BType, char, ::xsd::cxx::tree::schema_type::double_ > BTraits;

      const BOptional&
      b () const;

      BOptional&
      b ();

      void
      setB (const BType& x);

      void
      setB (const BOptional& x);

      // delta_T
      //
      typedef ::xml_schema::Double Delta_TType;
      typedef ::xsd::cxx::tree::optional< Delta_TType > Delta_TOptional;
      typedef ::xsd::cxx::tree::traits< Delta_TType, char, ::xsd::cxx::tree::schema_type::double_ > Delta_TTraits;

      const Delta_TOptional&
      delta_T () const;

      Delta_TOptional&
      delta_T ();

      void
      setDelta_T (const Delta_TType& x);

      void
      setDelta_T (const Delta_TOptional& x);

      // tau_w
      //
      typedef ::xml_schema::Double Tau_wType;
      typedef ::xsd::cxx::tree::optional< Tau_wType > Tau_wOptional;
      typedef ::xsd::cxx::tree::traits< Tau_wType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_wTraits;

      const Tau_wOptional&
      tau_w () const;

      Tau_wOptional&
      tau_w ();

      void
      setTau_w (const Tau_wType& x);

      void
      setTau_w (const Tau_wOptional& x);

      // v_spike
      //
      typedef ::xml_schema::Double V_spikeType;
      typedef ::xsd::cxx::tree::optional< V_spikeType > V_spikeOptional;
      typedef ::xsd::cxx::tree::traits< V_spikeType, char, ::xsd::cxx::tree::schema_type::double_ > V_spikeTraits;

      const V_spikeOptional&
      v_spike () const;

      V_spikeOptional&
      v_spike ();

      void
      setV_spike (const V_spikeType& x);

      void
      setV_spike (const V_spikeOptional& x);

      // Constructors.
      //
      EIF_cond_exp_isfa_ista (const IdType&);

      EIF_cond_exp_isfa_ista (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      EIF_cond_exp_isfa_ista (const EIF_cond_exp_isfa_ista& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      virtual EIF_cond_exp_isfa_ista*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      EIF_cond_exp_isfa_ista&
      operator= (const EIF_cond_exp_isfa_ista& x);

      virtual 
      ~EIF_cond_exp_isfa_ista ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      AOptional a_;
      BOptional b_;
      Delta_TOptional delta_T_;
      Tau_wOptional tau_w_;
      V_spikeOptional v_spike_;
    };

    class EIF_cond_alpha_isfa_ista: public ::neurona::schema::BasePyNNIaFCondCell
    {
      public:
      // a
      //
      typedef ::xml_schema::Double AType;
      typedef ::xsd::cxx::tree::optional< AType > AOptional;
      typedef ::xsd::cxx::tree::traits< AType, char, ::xsd::cxx::tree::schema_type::double_ > ATraits;

      const AOptional&
      a () const;

      AOptional&
      a ();

      void
      setA (const AType& x);

      void
      setA (const AOptional& x);

      // b
      //
      typedef ::xml_schema::Double BType;
      typedef ::xsd::cxx::tree::optional< BType > BOptional;
      typedef ::xsd::cxx::tree::traits< BType, char, ::xsd::cxx::tree::schema_type::double_ > BTraits;

      const BOptional&
      b () const;

      BOptional&
      b ();

      void
      setB (const BType& x);

      void
      setB (const BOptional& x);

      // delta_T
      //
      typedef ::xml_schema::Double Delta_TType;
      typedef ::xsd::cxx::tree::optional< Delta_TType > Delta_TOptional;
      typedef ::xsd::cxx::tree::traits< Delta_TType, char, ::xsd::cxx::tree::schema_type::double_ > Delta_TTraits;

      const Delta_TOptional&
      delta_T () const;

      Delta_TOptional&
      delta_T ();

      void
      setDelta_T (const Delta_TType& x);

      void
      setDelta_T (const Delta_TOptional& x);

      // tau_w
      //
      typedef ::xml_schema::Double Tau_wType;
      typedef ::xsd::cxx::tree::optional< Tau_wType > Tau_wOptional;
      typedef ::xsd::cxx::tree::traits< Tau_wType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_wTraits;

      const Tau_wOptional&
      tau_w () const;

      Tau_wOptional&
      tau_w ();

      void
      setTau_w (const Tau_wType& x);

      void
      setTau_w (const Tau_wOptional& x);

      // v_spike
      //
      typedef ::xml_schema::Double V_spikeType;
      typedef ::xsd::cxx::tree::optional< V_spikeType > V_spikeOptional;
      typedef ::xsd::cxx::tree::traits< V_spikeType, char, ::xsd::cxx::tree::schema_type::double_ > V_spikeTraits;

      const V_spikeOptional&
      v_spike () const;

      V_spikeOptional&
      v_spike ();

      void
      setV_spike (const V_spikeType& x);

      void
      setV_spike (const V_spikeOptional& x);

      // Constructors.
      //
      EIF_cond_alpha_isfa_ista (const IdType&);

      EIF_cond_alpha_isfa_ista (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      EIF_cond_alpha_isfa_ista (const EIF_cond_alpha_isfa_ista& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

      virtual EIF_cond_alpha_isfa_ista*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      EIF_cond_alpha_isfa_ista&
      operator= (const EIF_cond_alpha_isfa_ista& x);

      virtual 
      ~EIF_cond_alpha_isfa_ista ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      AOptional a_;
      BOptional b_;
      Delta_TOptional delta_T_;
      Tau_wOptional tau_w_;
      V_spikeOptional v_spike_;
    };

    class HH_cond_exp: public ::neurona::schema::BasePyNNCell
    {
      public:
      // v_offset
      //
      typedef ::xml_schema::Double V_offsetType;
      typedef ::xsd::cxx::tree::optional< V_offsetType > V_offsetOptional;
      typedef ::xsd::cxx::tree::traits< V_offsetType, char, ::xsd::cxx::tree::schema_type::double_ > V_offsetTraits;

      const V_offsetOptional&
      v_offset () const;

      V_offsetOptional&
      v_offset ();

      void
      setV_offset (const V_offsetType& x);

      void
      setV_offset (const V_offsetOptional& x);

      // e_rev_E
      //
      typedef ::xml_schema::Double E_rev_EType;
      typedef ::xsd::cxx::tree::optional< E_rev_EType > E_rev_EOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_EType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_ETraits;

      const E_rev_EOptional&
      e_rev_E () const;

      E_rev_EOptional&
      e_rev_E ();

      void
      setE_rev_E (const E_rev_EType& x);

      void
      setE_rev_E (const E_rev_EOptional& x);

      // e_rev_I
      //
      typedef ::xml_schema::Double E_rev_IType;
      typedef ::xsd::cxx::tree::optional< E_rev_IType > E_rev_IOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_IType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_ITraits;

      const E_rev_IOptional&
      e_rev_I () const;

      E_rev_IOptional&
      e_rev_I ();

      void
      setE_rev_I (const E_rev_IType& x);

      void
      setE_rev_I (const E_rev_IOptional& x);

      // e_rev_K
      //
      typedef ::xml_schema::Double E_rev_KType;
      typedef ::xsd::cxx::tree::optional< E_rev_KType > E_rev_KOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_KType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_KTraits;

      const E_rev_KOptional&
      e_rev_K () const;

      E_rev_KOptional&
      e_rev_K ();

      void
      setE_rev_K (const E_rev_KType& x);

      void
      setE_rev_K (const E_rev_KOptional& x);

      // e_rev_Na
      //
      typedef ::xml_schema::Double E_rev_NaType;
      typedef ::xsd::cxx::tree::optional< E_rev_NaType > E_rev_NaOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_NaType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_NaTraits;

      const E_rev_NaOptional&
      e_rev_Na () const;

      E_rev_NaOptional&
      e_rev_Na ();

      void
      setE_rev_Na (const E_rev_NaType& x);

      void
      setE_rev_Na (const E_rev_NaOptional& x);

      // e_rev_leak
      //
      typedef ::xml_schema::Double E_rev_leakType;
      typedef ::xsd::cxx::tree::optional< E_rev_leakType > E_rev_leakOptional;
      typedef ::xsd::cxx::tree::traits< E_rev_leakType, char, ::xsd::cxx::tree::schema_type::double_ > E_rev_leakTraits;

      const E_rev_leakOptional&
      e_rev_leak () const;

      E_rev_leakOptional&
      e_rev_leak ();

      void
      setE_rev_leak (const E_rev_leakType& x);

      void
      setE_rev_leak (const E_rev_leakOptional& x);

      // g_leak
      //
      typedef ::xml_schema::Double G_leakType;
      typedef ::xsd::cxx::tree::optional< G_leakType > G_leakOptional;
      typedef ::xsd::cxx::tree::traits< G_leakType, char, ::xsd::cxx::tree::schema_type::double_ > G_leakTraits;

      const G_leakOptional&
      g_leak () const;

      G_leakOptional&
      g_leak ();

      void
      setG_leak (const G_leakType& x);

      void
      setG_leak (const G_leakOptional& x);

      // gbar_K
      //
      typedef ::xml_schema::Double Gbar_KType;
      typedef ::xsd::cxx::tree::optional< Gbar_KType > Gbar_KOptional;
      typedef ::xsd::cxx::tree::traits< Gbar_KType, char, ::xsd::cxx::tree::schema_type::double_ > Gbar_KTraits;

      const Gbar_KOptional&
      gbar_K () const;

      Gbar_KOptional&
      gbar_K ();

      void
      setGbar_K (const Gbar_KType& x);

      void
      setGbar_K (const Gbar_KOptional& x);

      // gbar_Na
      //
      typedef ::xml_schema::Double Gbar_NaType;
      typedef ::xsd::cxx::tree::optional< Gbar_NaType > Gbar_NaOptional;
      typedef ::xsd::cxx::tree::traits< Gbar_NaType, char, ::xsd::cxx::tree::schema_type::double_ > Gbar_NaTraits;

      const Gbar_NaOptional&
      gbar_Na () const;

      Gbar_NaOptional&
      gbar_Na ();

      void
      setGbar_Na (const Gbar_NaType& x);

      void
      setGbar_Na (const Gbar_NaOptional& x);

      // Constructors.
      //
      HH_cond_exp (const IdType&);

      HH_cond_exp (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      HH_cond_exp (const HH_cond_exp& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      virtual HH_cond_exp*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      HH_cond_exp&
      operator= (const HH_cond_exp& x);

      virtual 
      ~HH_cond_exp ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      V_offsetOptional v_offset_;
      E_rev_EOptional e_rev_E_;
      E_rev_IOptional e_rev_I_;
      E_rev_KOptional e_rev_K_;
      E_rev_NaOptional e_rev_Na_;
      E_rev_leakOptional e_rev_leak_;
      G_leakOptional g_leak_;
      Gbar_KOptional gbar_K_;
      Gbar_NaOptional gbar_Na_;
    };

    class BasePynnSynapse: public ::neurona::schema::BaseSynapse
    {
      public:
      // tau_syn
      //
      typedef ::xml_schema::Double Tau_synType;
      typedef ::xsd::cxx::tree::optional< Tau_synType > Tau_synOptional;
      typedef ::xsd::cxx::tree::traits< Tau_synType, char, ::xsd::cxx::tree::schema_type::double_ > Tau_synTraits;

      const Tau_synOptional&
      tau_syn () const;

      Tau_synOptional&
      tau_syn ();

      void
      setTau_syn (const Tau_synType& x);

      void
      setTau_syn (const Tau_synOptional& x);

      // Constructors.
      //
      BasePynnSynapse (const IdType&);

      BasePynnSynapse (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      BasePynnSynapse (const BasePynnSynapse& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

      virtual BasePynnSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      BasePynnSynapse&
      operator= (const BasePynnSynapse& x);

      virtual 
      ~BasePynnSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      Tau_synOptional tau_syn_;
    };

    class ExpCondSynapse: public ::neurona::schema::BasePynnSynapse
    {
      public:
      // e_rev
      //
      typedef ::xml_schema::Double E_revType;
      typedef ::xsd::cxx::tree::optional< E_revType > E_revOptional;
      typedef ::xsd::cxx::tree::traits< E_revType, char, ::xsd::cxx::tree::schema_type::double_ > E_revTraits;

      const E_revOptional&
      e_rev () const;

      E_revOptional&
      e_rev ();

      void
      setE_rev (const E_revType& x);

      void
      setE_rev (const E_revOptional& x);

      // Constructors.
      //
      ExpCondSynapse (const IdType&);

      ExpCondSynapse (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      ExpCondSynapse (const ExpCondSynapse& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual ExpCondSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      ExpCondSynapse&
      operator= (const ExpCondSynapse& x);

      virtual 
      ~ExpCondSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      E_revOptional e_rev_;
    };

    class AlphaCondSynapse: public ::neurona::schema::BasePynnSynapse
    {
      public:
      // e_rev
      //
      typedef ::xml_schema::Double E_revType;
      typedef ::xsd::cxx::tree::optional< E_revType > E_revOptional;
      typedef ::xsd::cxx::tree::traits< E_revType, char, ::xsd::cxx::tree::schema_type::double_ > E_revTraits;

      const E_revOptional&
      e_rev () const;

      E_revOptional&
      e_rev ();

      void
      setE_rev (const E_revType& x);

      void
      setE_rev (const E_revOptional& x);

      // Constructors.
      //
      AlphaCondSynapse (const IdType&);

      AlphaCondSynapse (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      AlphaCondSynapse (const AlphaCondSynapse& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      virtual AlphaCondSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      AlphaCondSynapse&
      operator= (const AlphaCondSynapse& x);

      virtual 
      ~AlphaCondSynapse ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      E_revOptional e_rev_;
    };

    class ExpCurrSynapse: public ::neurona::schema::BasePynnSynapse
    {
      public:
      // Constructors.
      //
      ExpCurrSynapse (const IdType&);

      ExpCurrSynapse (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      ExpCurrSynapse (const ExpCurrSynapse& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      virtual ExpCurrSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~ExpCurrSynapse ();
    };

    class AlphaCurrSynapse: public ::neurona::schema::BasePynnSynapse
    {
      public:
      // Constructors.
      //
      AlphaCurrSynapse (const IdType&);

      AlphaCurrSynapse (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      AlphaCurrSynapse (const AlphaCurrSynapse& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      virtual AlphaCurrSynapse*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      virtual 
      ~AlphaCurrSynapse ();
    };

    class SpikeSourcePoisson: public ::neurona::schema::Standalone
    {
      public:
      // start
      //
      typedef ::neurona::schema::Nml2Quantity_time StartType;
      typedef ::xsd::cxx::tree::traits< StartType, char > StartTraits;

      const StartType&
      start () const;

      StartType&
      start ();

      void
      setStart (const StartType& x);

      void
      setStart (::std::unique_ptr< StartType > p);

      // duration
      //
      typedef ::neurona::schema::Nml2Quantity_time DurationType;
      typedef ::xsd::cxx::tree::traits< DurationType, char > DurationTraits;

      const DurationType&
      duration () const;

      DurationType&
      duration ();

      void
      setDuration (const DurationType& x);

      void
      setDuration (::std::unique_ptr< DurationType > p);

      // rate
      //
      typedef ::neurona::schema::Nml2Quantity_pertime RateType;
      typedef ::xsd::cxx::tree::traits< RateType, char > RateTraits;

      const RateType&
      rate () const;

      RateType&
      rate ();

      void
      setRate (const RateType& x);

      void
      setRate (::std::unique_ptr< RateType > p);

      // Constructors.
      //
      SpikeSourcePoisson (const IdType&,
                          const StartType&,
                          const DurationType&,
                          const RateType&);

      SpikeSourcePoisson (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      SpikeSourcePoisson (const SpikeSourcePoisson& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      virtual SpikeSourcePoisson*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      SpikeSourcePoisson&
      operator= (const SpikeSourcePoisson& x);

      virtual 
      ~SpikeSourcePoisson ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< StartType > start_;
      ::xsd::cxx::tree::one< DurationType > duration_;
      ::xsd::cxx::tree::one< RateType > rate_;
    };
  }
}

#include <iosfwd>

namespace neurona
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream&, const NmlId&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_none&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_voltage&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_length&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_resistance&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_conductance&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_conductanceDensity&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_permeability&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_time&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_pertime&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_capacitance&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_specificCapacitance&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_concentration&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_current&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_temperature&);

    ::std::ostream&
    operator<< (::std::ostream&, const Nml2Quantity_rhoFactor&);

    ::std::ostream&
    operator<< (::std::ostream&, const MetaId&);

    ::std::ostream&
    operator<< (::std::ostream&, const NeuroLexId&);

    ::std::ostream&
    operator<< (::std::ostream&, const SegmentId&);

    ::std::ostream&
    operator<< (::std::ostream&, const Notes&);

    ::std::ostream&
    operator<< (::std::ostream&, const Property&);

    ::std::ostream&
    operator<< (::std::ostream&, const Annotation&);

    ::std::ostream&
    operator<< (::std::ostream&, const ComponentType&);

    ::std::ostream&
    operator<< (::std::ostream&, const ZeroToOne&);

    ::std::ostream&
    operator<< (::std::ostream&, const BaseWithoutId&);

    ::std::ostream&
    operator<< (::std::ostream&, const Base&);

    ::std::ostream&
    operator<< (::std::ostream&, const Standalone&);

    ::std::ostream&
    operator<< (::std::ostream&, const NeuroMLDocument&);

    ::std::ostream&
    operator<< (::std::ostream&, const IncludeType&);

    ::std::ostream&
    operator<< (::std::ostream&, const IonChannel&);

    ::std::ostream&
    operator<< (::std::ostream&, const IonChannelHH&);

    ::std::ostream&
    operator<< (::std::ostream&, ChannelTypes::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelTypes&);

    ::std::ostream&
    operator<< (::std::ostream&, GateTypes::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const GateTypes&);

    ::std::ostream&
    operator<< (::std::ostream&, const GateHHUndetermined&);

    ::std::ostream&
    operator<< (::std::ostream&, const GateHHRates&);

    ::std::ostream&
    operator<< (::std::ostream&, const GateHHTauInf&);

    ::std::ostream&
    operator<< (::std::ostream&, const GateHHRatesTauInf&);

    ::std::ostream&
    operator<< (::std::ostream&, const GateHHRatesTau&);

    ::std::ostream&
    operator<< (::std::ostream&, const GateHHRatesInf&);

    ::std::ostream&
    operator<< (::std::ostream&, const Q10Settings&);

    ::std::ostream&
    operator<< (::std::ostream&, const HHRate&);

    ::std::ostream&
    operator<< (::std::ostream&, const HHVariable&);

    ::std::ostream&
    operator<< (::std::ostream&, const HHTime&);

    ::std::ostream&
    operator<< (::std::ostream&, const DecayingPoolConcentrationModel&);

    ::std::ostream&
    operator<< (::std::ostream&, const FixedFactorConcentrationModel&);

    ::std::ostream&
    operator<< (::std::ostream&, const BaseSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const BaseConductanceBasedSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExpOneSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExpTwoSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const BlockingPlasticSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, BlockTypes::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const BlockTypes&);

    ::std::ostream&
    operator<< (::std::ostream&, const BlockMechanism&);

    ::std::ostream&
    operator<< (::std::ostream&, PlasticityTypes::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const PlasticityTypes&);

    ::std::ostream&
    operator<< (::std::ostream&, const PlasticityMechanism&);

    ::std::ostream&
    operator<< (::std::ostream&, const BaseCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const IafTauCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const IafTauRefCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const IafCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const IafRefCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const IzhikevichCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const AdExIaFCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const FitzHughNagumoCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const Cell&);

    ::std::ostream&
    operator<< (::std::ostream&, const Morphology&);

    ::std::ostream&
    operator<< (::std::ostream&, const Segment&);

    ::std::ostream&
    operator<< (::std::ostream&, const SegmentParent&);

    ::std::ostream&
    operator<< (::std::ostream&, const Point3DWithDiam&);

    ::std::ostream&
    operator<< (::std::ostream&, const SegmentGroup&);

    ::std::ostream&
    operator<< (::std::ostream&, const InhomogeneousParameter&);

    ::std::ostream&
    operator<< (::std::ostream&, Metric::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const Metric&);

    ::std::ostream&
    operator<< (::std::ostream&, const ProximalDetails&);

    ::std::ostream&
    operator<< (::std::ostream&, const DistalDetails&);

    ::std::ostream&
    operator<< (::std::ostream&, const Member&);

    ::std::ostream&
    operator<< (::std::ostream&, const Include&);

    ::std::ostream&
    operator<< (::std::ostream&, const Path&);

    ::std::ostream&
    operator<< (::std::ostream&, const SubTree&);

    ::std::ostream&
    operator<< (::std::ostream&, const SegmentEndPoint&);

    ::std::ostream&
    operator<< (::std::ostream&, const BiophysicalProperties&);

    ::std::ostream&
    operator<< (::std::ostream&, const MembraneProperties&);

    ::std::ostream&
    operator<< (::std::ostream&, const ValueAcrossSegOrSegGroup&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpikeThresh&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpecificCapacitance&);

    ::std::ostream&
    operator<< (::std::ostream&, const InitMembPotential&);

    ::std::ostream&
    operator<< (::std::ostream&, const Resistivity&);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelPopulation&);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelDensityNonUniform&);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelDensityNonUniformNernst&);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelDensity&);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelDensityNernst&);

    ::std::ostream&
    operator<< (::std::ostream&, const ChannelDensityGHK&);

    ::std::ostream&
    operator<< (::std::ostream&, const VariableParameter&);

    ::std::ostream&
    operator<< (::std::ostream&, const InhomogeneousValue&);

    ::std::ostream&
    operator<< (::std::ostream&, const Species&);

    ::std::ostream&
    operator<< (::std::ostream&, const ConcentrationModel_D&);

    ::std::ostream&
    operator<< (::std::ostream&, const IntracellularProperties&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExtracellularProperties&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExtracellularPropertiesLocal&);

    ::std::ostream&
    operator<< (::std::ostream&, const ReactionScheme&);

    ::std::ostream&
    operator<< (::std::ostream&, const PulseGenerator&);

    ::std::ostream&
    operator<< (::std::ostream&, const SineGenerator&);

    ::std::ostream&
    operator<< (::std::ostream&, const RampGenerator&);

    ::std::ostream&
    operator<< (::std::ostream&, const VoltageClamp&);

    ::std::ostream&
    operator<< (::std::ostream&, const Spike&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpikeArray&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpikeGenerator&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpikeGeneratorRandom&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpikeGeneratorPoisson&);

    ::std::ostream&
    operator<< (::std::ostream&, const Network&);

    ::std::ostream&
    operator<< (::std::ostream&, NetworkTypes::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const NetworkTypes&);

    ::std::ostream&
    operator<< (::std::ostream&, const Space&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpaceStructure&);

    ::std::ostream&
    operator<< (::std::ostream&, AllowedSpaces::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const AllowedSpaces&);

    ::std::ostream&
    operator<< (::std::ostream&, const Region&);

    ::std::ostream&
    operator<< (::std::ostream&, const Population&);

    ::std::ostream&
    operator<< (::std::ostream&, PopulationTypes::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const PopulationTypes&);

    ::std::ostream&
    operator<< (::std::ostream&, const Layout&);

    ::std::ostream&
    operator<< (::std::ostream&, const UnstructuredLayout&);

    ::std::ostream&
    operator<< (::std::ostream&, const RandomLayout&);

    ::std::ostream&
    operator<< (::std::ostream&, const GridLayout&);

    ::std::ostream&
    operator<< (::std::ostream&, const Instance&);

    ::std::ostream&
    operator<< (::std::ostream&, const Location&);

    ::std::ostream&
    operator<< (::std::ostream&, const CellSet&);

    ::std::ostream&
    operator<< (::std::ostream&, const SynapticConnection&);

    ::std::ostream&
    operator<< (::std::ostream&, const Projection&);

    ::std::ostream&
    operator<< (::std::ostream&, const Connection&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExplicitInput&);

    ::std::ostream&
    operator<< (::std::ostream&, const InputList&);

    ::std::ostream&
    operator<< (::std::ostream&, const Input&);

    ::std::ostream&
    operator<< (::std::ostream&, const BasePyNNCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const BasePyNNIaFCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const BasePyNNIaFCondCell&);

    ::std::ostream&
    operator<< (::std::ostream&, const IF_curr_alpha&);

    ::std::ostream&
    operator<< (::std::ostream&, const IF_curr_exp&);

    ::std::ostream&
    operator<< (::std::ostream&, const IF_cond_alpha&);

    ::std::ostream&
    operator<< (::std::ostream&, const IF_cond_exp&);

    ::std::ostream&
    operator<< (::std::ostream&, const EIF_cond_exp_isfa_ista&);

    ::std::ostream&
    operator<< (::std::ostream&, const EIF_cond_alpha_isfa_ista&);

    ::std::ostream&
    operator<< (::std::ostream&, const HH_cond_exp&);

    ::std::ostream&
    operator<< (::std::ostream&, const BasePynnSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExpCondSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const AlphaCondSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const ExpCurrSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const AlphaCurrSynapse&);

    ::std::ostream&
    operator<< (::std::ostream&, const SpikeSourcePoisson&);
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace neurona
{
  namespace schema
  {
    // Parse a URI or a local file.
    //

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::std::string& uri,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::std::string& uri,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::std::string& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    // Parse std::istream.
    //

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             const ::std::string& id,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             const ::std::string& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    // Parse xercesc::InputSource.
    //

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xercesc::InputSource& is,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xercesc::InputSource& is,
             ::xml_schema::ErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::xercesc::DOMDocument& d,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f = 0,
             const ::xml_schema::Properties& p = ::xml_schema::Properties ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX___SCHEMAS_NEURO_ML2_NEURO_ML_V2BETA3_H
