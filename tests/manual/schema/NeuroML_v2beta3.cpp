// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "NeuroML_v2beta3.h"

namespace neurona
{
  namespace schema
  {
    // NmlId
    // 


    // Nml2Quantity
    // 


    // Nml2Quantity_none
    // 


    // Nml2Quantity_voltage
    // 


    // Nml2Quantity_length
    // 


    // Nml2Quantity_resistance
    // 


    // Nml2Quantity_conductance
    // 


    // Nml2Quantity_conductanceDensity
    // 


    // Nml2Quantity_permeability
    // 


    // Nml2Quantity_time
    // 


    // Nml2Quantity_pertime
    // 


    // Nml2Quantity_capacitance
    // 


    // Nml2Quantity_specificCapacitance
    // 


    // Nml2Quantity_concentration
    // 


    // Nml2Quantity_current
    // 


    // Nml2Quantity_temperature
    // 


    // Nml2Quantity_rhoFactor
    // 


    // MetaId
    // 


    // NeuroLexId
    // 


    // SegmentId
    // 


    // Notes
    // 


    // Property
    // 

    const Property::TagType& Property::
    tag () const
    {
      return this->tag_.get ();
    }

    Property::TagType& Property::
    tag ()
    {
      return this->tag_.get ();
    }

    void Property::
    setTag (const TagType& x)
    {
      this->tag_.set (x);
    }

    void Property::
    setTag (::std::unique_ptr< TagType > x)
    {
      this->tag_.set (std::move (x));
    }

    const Property::ValueType& Property::
    value () const
    {
      return this->value_.get ();
    }

    Property::ValueType& Property::
    value ()
    {
      return this->value_.get ();
    }

    void Property::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }

    void Property::
    setValue (::std::unique_ptr< ValueType > x)
    {
      this->value_.set (std::move (x));
    }


    // Annotation
    // 


    // ComponentType
    // 

    const ComponentType::NameType& ComponentType::
    name () const
    {
      return this->name_.get ();
    }

    ComponentType::NameType& ComponentType::
    name ()
    {
      return this->name_.get ();
    }

    void ComponentType::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void ComponentType::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const ComponentType::ExtendsOptional& ComponentType::
    extends () const
    {
      return this->extends_;
    }

    ComponentType::ExtendsOptional& ComponentType::
    extends ()
    {
      return this->extends_;
    }

    void ComponentType::
    setExtends (const ExtendsType& x)
    {
      this->extends_.set (x);
    }

    void ComponentType::
    setExtends (const ExtendsOptional& x)
    {
      this->extends_ = x;
    }

    void ComponentType::
    setExtends (::std::unique_ptr< ExtendsType > x)
    {
      this->extends_.set (std::move (x));
    }

    const ComponentType::DescriptionOptional& ComponentType::
    description () const
    {
      return this->description_;
    }

    ComponentType::DescriptionOptional& ComponentType::
    description ()
    {
      return this->description_;
    }

    void ComponentType::
    setDescription (const DescriptionType& x)
    {
      this->description_.set (x);
    }

    void ComponentType::
    setDescription (const DescriptionOptional& x)
    {
      this->description_ = x;
    }

    void ComponentType::
    setDescription (::std::unique_ptr< DescriptionType > x)
    {
      this->description_.set (std::move (x));
    }


    // ZeroToOne
    // 


    // BaseWithoutId
    // 

    const BaseWithoutId::NeuroLexIdOptional& BaseWithoutId::
    neuroLexId () const
    {
      return this->neuroLexId_;
    }

    BaseWithoutId::NeuroLexIdOptional& BaseWithoutId::
    neuroLexId ()
    {
      return this->neuroLexId_;
    }

    void BaseWithoutId::
    setNeuroLexId (const NeuroLexIdType& x)
    {
      this->neuroLexId_.set (x);
    }

    void BaseWithoutId::
    setNeuroLexId (const NeuroLexIdOptional& x)
    {
      this->neuroLexId_ = x;
    }

    void BaseWithoutId::
    setNeuroLexId (::std::unique_ptr< NeuroLexIdType > x)
    {
      this->neuroLexId_.set (std::move (x));
    }


    // Base
    // 

    const Base::IdType& Base::
    id () const
    {
      return this->id_.get ();
    }

    Base::IdType& Base::
    id ()
    {
      return this->id_.get ();
    }

    void Base::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Base::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }


    // Standalone
    // 

    const Standalone::NotesOptional& Standalone::
    notes () const
    {
      return this->notes_;
    }

    Standalone::NotesOptional& Standalone::
    notes ()
    {
      return this->notes_;
    }

    void Standalone::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void Standalone::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void Standalone::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const Standalone::AnnotationOptional& Standalone::
    annotation () const
    {
      return this->annotation_;
    }

    Standalone::AnnotationOptional& Standalone::
    annotation ()
    {
      return this->annotation_;
    }

    void Standalone::
    setAnnotation (const AnnotationType& x)
    {
      this->annotation_.set (x);
    }

    void Standalone::
    setAnnotation (const AnnotationOptional& x)
    {
      this->annotation_ = x;
    }

    void Standalone::
    setAnnotation (::std::unique_ptr< AnnotationType > x)
    {
      this->annotation_.set (std::move (x));
    }

    const Standalone::MetaidOptional& Standalone::
    metaid () const
    {
      return this->metaid_;
    }

    Standalone::MetaidOptional& Standalone::
    metaid ()
    {
      return this->metaid_;
    }

    void Standalone::
    setMetaid (const MetaidType& x)
    {
      this->metaid_.set (x);
    }

    void Standalone::
    setMetaid (const MetaidOptional& x)
    {
      this->metaid_ = x;
    }

    void Standalone::
    setMetaid (::std::unique_ptr< MetaidType > x)
    {
      this->metaid_.set (std::move (x));
    }


    // NeuroMLDocument
    // 

    const NeuroMLDocument::IncludeSequence& NeuroMLDocument::
    includes () const
    {
      return this->include_;
    }

    NeuroMLDocument::IncludeSequence& NeuroMLDocument::
    includes ()
    {
      return this->include_;
    }

    void NeuroMLDocument::
    setIncludes (const IncludeSequence& s)
    {
      this->include_ = s;
    }

    const NeuroMLDocument::ExtracellularPropertiesSequence& NeuroMLDocument::
    extracellularPropertiess () const
    {
      return this->extracellularProperties_;
    }

    NeuroMLDocument::ExtracellularPropertiesSequence& NeuroMLDocument::
    extracellularPropertiess ()
    {
      return this->extracellularProperties_;
    }

    void NeuroMLDocument::
    setExtracellularPropertiess (const ExtracellularPropertiesSequence& s)
    {
      this->extracellularProperties_ = s;
    }

    const NeuroMLDocument::IntracellularPropertiesSequence& NeuroMLDocument::
    intracellularPropertiess () const
    {
      return this->intracellularProperties_;
    }

    NeuroMLDocument::IntracellularPropertiesSequence& NeuroMLDocument::
    intracellularPropertiess ()
    {
      return this->intracellularProperties_;
    }

    void NeuroMLDocument::
    setIntracellularPropertiess (const IntracellularPropertiesSequence& s)
    {
      this->intracellularProperties_ = s;
    }

    const NeuroMLDocument::MorphologySequence& NeuroMLDocument::
    morphologys () const
    {
      return this->morphology_;
    }

    NeuroMLDocument::MorphologySequence& NeuroMLDocument::
    morphologys ()
    {
      return this->morphology_;
    }

    void NeuroMLDocument::
    setMorphologys (const MorphologySequence& s)
    {
      this->morphology_ = s;
    }

    const NeuroMLDocument::IonChannelSequence& NeuroMLDocument::
    ionChannels () const
    {
      return this->ionChannel_;
    }

    NeuroMLDocument::IonChannelSequence& NeuroMLDocument::
    ionChannels ()
    {
      return this->ionChannel_;
    }

    void NeuroMLDocument::
    setIonChannels (const IonChannelSequence& s)
    {
      this->ionChannel_ = s;
    }

    const NeuroMLDocument::IonChannelHHSequence& NeuroMLDocument::
    ionChannelHHs () const
    {
      return this->ionChannelHH_;
    }

    NeuroMLDocument::IonChannelHHSequence& NeuroMLDocument::
    ionChannelHHs ()
    {
      return this->ionChannelHH_;
    }

    void NeuroMLDocument::
    setIonChannelHHs (const IonChannelHHSequence& s)
    {
      this->ionChannelHH_ = s;
    }

    const NeuroMLDocument::DecayingPoolConcentrationModelSequence& NeuroMLDocument::
    decayingPoolConcentrationModels () const
    {
      return this->decayingPoolConcentrationModel_;
    }

    NeuroMLDocument::DecayingPoolConcentrationModelSequence& NeuroMLDocument::
    decayingPoolConcentrationModels ()
    {
      return this->decayingPoolConcentrationModel_;
    }

    void NeuroMLDocument::
    setDecayingPoolConcentrationModels (const DecayingPoolConcentrationModelSequence& s)
    {
      this->decayingPoolConcentrationModel_ = s;
    }

    const NeuroMLDocument::FixedFactorConcentrationModelSequence& NeuroMLDocument::
    fixedFactorConcentrationModels () const
    {
      return this->fixedFactorConcentrationModel_;
    }

    NeuroMLDocument::FixedFactorConcentrationModelSequence& NeuroMLDocument::
    fixedFactorConcentrationModels ()
    {
      return this->fixedFactorConcentrationModel_;
    }

    void NeuroMLDocument::
    setFixedFactorConcentrationModels (const FixedFactorConcentrationModelSequence& s)
    {
      this->fixedFactorConcentrationModel_ = s;
    }

    const NeuroMLDocument::ExpOneSynapseSequence& NeuroMLDocument::
    expOneSynapses () const
    {
      return this->expOneSynapse_;
    }

    NeuroMLDocument::ExpOneSynapseSequence& NeuroMLDocument::
    expOneSynapses ()
    {
      return this->expOneSynapse_;
    }

    void NeuroMLDocument::
    setExpOneSynapses (const ExpOneSynapseSequence& s)
    {
      this->expOneSynapse_ = s;
    }

    const NeuroMLDocument::ExpTwoSynapseSequence& NeuroMLDocument::
    expTwoSynapses () const
    {
      return this->expTwoSynapse_;
    }

    NeuroMLDocument::ExpTwoSynapseSequence& NeuroMLDocument::
    expTwoSynapses ()
    {
      return this->expTwoSynapse_;
    }

    void NeuroMLDocument::
    setExpTwoSynapses (const ExpTwoSynapseSequence& s)
    {
      this->expTwoSynapse_ = s;
    }

    const NeuroMLDocument::BlockingPlasticSynapseSequence& NeuroMLDocument::
    blockingPlasticSynapses () const
    {
      return this->blockingPlasticSynapse_;
    }

    NeuroMLDocument::BlockingPlasticSynapseSequence& NeuroMLDocument::
    blockingPlasticSynapses ()
    {
      return this->blockingPlasticSynapse_;
    }

    void NeuroMLDocument::
    setBlockingPlasticSynapses (const BlockingPlasticSynapseSequence& s)
    {
      this->blockingPlasticSynapse_ = s;
    }

    const NeuroMLDocument::BiophysicalPropertiesSequence& NeuroMLDocument::
    biophysicalPropertiess () const
    {
      return this->biophysicalProperties_;
    }

    NeuroMLDocument::BiophysicalPropertiesSequence& NeuroMLDocument::
    biophysicalPropertiess ()
    {
      return this->biophysicalProperties_;
    }

    void NeuroMLDocument::
    setBiophysicalPropertiess (const BiophysicalPropertiesSequence& s)
    {
      this->biophysicalProperties_ = s;
    }

    const NeuroMLDocument::CellSequence& NeuroMLDocument::
    cells () const
    {
      return this->cell_;
    }

    NeuroMLDocument::CellSequence& NeuroMLDocument::
    cells ()
    {
      return this->cell_;
    }

    void NeuroMLDocument::
    setCells (const CellSequence& s)
    {
      this->cell_ = s;
    }

    const NeuroMLDocument::BaseCellSequence& NeuroMLDocument::
    baseCells () const
    {
      return this->baseCell_;
    }

    NeuroMLDocument::BaseCellSequence& NeuroMLDocument::
    baseCells ()
    {
      return this->baseCell_;
    }

    void NeuroMLDocument::
    setBaseCells (const BaseCellSequence& s)
    {
      this->baseCell_ = s;
    }

    const NeuroMLDocument::IafTauCellSequence& NeuroMLDocument::
    iafTauCells () const
    {
      return this->iafTauCell_;
    }

    NeuroMLDocument::IafTauCellSequence& NeuroMLDocument::
    iafTauCells ()
    {
      return this->iafTauCell_;
    }

    void NeuroMLDocument::
    setIafTauCells (const IafTauCellSequence& s)
    {
      this->iafTauCell_ = s;
    }

    const NeuroMLDocument::IafTauRefCellSequence& NeuroMLDocument::
    iafTauRefCells () const
    {
      return this->iafTauRefCell_;
    }

    NeuroMLDocument::IafTauRefCellSequence& NeuroMLDocument::
    iafTauRefCells ()
    {
      return this->iafTauRefCell_;
    }

    void NeuroMLDocument::
    setIafTauRefCells (const IafTauRefCellSequence& s)
    {
      this->iafTauRefCell_ = s;
    }

    const NeuroMLDocument::IafCellSequence& NeuroMLDocument::
    iafCells () const
    {
      return this->iafCell_;
    }

    NeuroMLDocument::IafCellSequence& NeuroMLDocument::
    iafCells ()
    {
      return this->iafCell_;
    }

    void NeuroMLDocument::
    setIafCells (const IafCellSequence& s)
    {
      this->iafCell_ = s;
    }

    const NeuroMLDocument::IafRefCellSequence& NeuroMLDocument::
    iafRefCells () const
    {
      return this->iafRefCell_;
    }

    NeuroMLDocument::IafRefCellSequence& NeuroMLDocument::
    iafRefCells ()
    {
      return this->iafRefCell_;
    }

    void NeuroMLDocument::
    setIafRefCells (const IafRefCellSequence& s)
    {
      this->iafRefCell_ = s;
    }

    const NeuroMLDocument::IzhikevichCellSequence& NeuroMLDocument::
    izhikevichCells () const
    {
      return this->izhikevichCell_;
    }

    NeuroMLDocument::IzhikevichCellSequence& NeuroMLDocument::
    izhikevichCells ()
    {
      return this->izhikevichCell_;
    }

    void NeuroMLDocument::
    setIzhikevichCells (const IzhikevichCellSequence& s)
    {
      this->izhikevichCell_ = s;
    }

    const NeuroMLDocument::AdExIaFCellSequence& NeuroMLDocument::
    adExIaFCells () const
    {
      return this->adExIaFCell_;
    }

    NeuroMLDocument::AdExIaFCellSequence& NeuroMLDocument::
    adExIaFCells ()
    {
      return this->adExIaFCell_;
    }

    void NeuroMLDocument::
    setAdExIaFCells (const AdExIaFCellSequence& s)
    {
      this->adExIaFCell_ = s;
    }

    const NeuroMLDocument::FitzHughNagumoCellSequence& NeuroMLDocument::
    fitzHughNagumoCells () const
    {
      return this->fitzHughNagumoCell_;
    }

    NeuroMLDocument::FitzHughNagumoCellSequence& NeuroMLDocument::
    fitzHughNagumoCells ()
    {
      return this->fitzHughNagumoCell_;
    }

    void NeuroMLDocument::
    setFitzHughNagumoCells (const FitzHughNagumoCellSequence& s)
    {
      this->fitzHughNagumoCell_ = s;
    }

    const NeuroMLDocument::PulseGeneratorSequence& NeuroMLDocument::
    pulseGenerators () const
    {
      return this->pulseGenerator_;
    }

    NeuroMLDocument::PulseGeneratorSequence& NeuroMLDocument::
    pulseGenerators ()
    {
      return this->pulseGenerator_;
    }

    void NeuroMLDocument::
    setPulseGenerators (const PulseGeneratorSequence& s)
    {
      this->pulseGenerator_ = s;
    }

    const NeuroMLDocument::SineGeneratorSequence& NeuroMLDocument::
    sineGenerators () const
    {
      return this->sineGenerator_;
    }

    NeuroMLDocument::SineGeneratorSequence& NeuroMLDocument::
    sineGenerators ()
    {
      return this->sineGenerator_;
    }

    void NeuroMLDocument::
    setSineGenerators (const SineGeneratorSequence& s)
    {
      this->sineGenerator_ = s;
    }

    const NeuroMLDocument::RampGeneratorSequence& NeuroMLDocument::
    rampGenerators () const
    {
      return this->rampGenerator_;
    }

    NeuroMLDocument::RampGeneratorSequence& NeuroMLDocument::
    rampGenerators ()
    {
      return this->rampGenerator_;
    }

    void NeuroMLDocument::
    setRampGenerators (const RampGeneratorSequence& s)
    {
      this->rampGenerator_ = s;
    }

    const NeuroMLDocument::VoltageClampSequence& NeuroMLDocument::
    voltageClamps () const
    {
      return this->voltageClamp_;
    }

    NeuroMLDocument::VoltageClampSequence& NeuroMLDocument::
    voltageClamps ()
    {
      return this->voltageClamp_;
    }

    void NeuroMLDocument::
    setVoltageClamps (const VoltageClampSequence& s)
    {
      this->voltageClamp_ = s;
    }

    const NeuroMLDocument::SpikeArraySequence& NeuroMLDocument::
    spikeArrays () const
    {
      return this->spikeArray_;
    }

    NeuroMLDocument::SpikeArraySequence& NeuroMLDocument::
    spikeArrays ()
    {
      return this->spikeArray_;
    }

    void NeuroMLDocument::
    setSpikeArrays (const SpikeArraySequence& s)
    {
      this->spikeArray_ = s;
    }

    const NeuroMLDocument::SpikeGeneratorSequence& NeuroMLDocument::
    spikeGenerators () const
    {
      return this->spikeGenerator_;
    }

    NeuroMLDocument::SpikeGeneratorSequence& NeuroMLDocument::
    spikeGenerators ()
    {
      return this->spikeGenerator_;
    }

    void NeuroMLDocument::
    setSpikeGenerators (const SpikeGeneratorSequence& s)
    {
      this->spikeGenerator_ = s;
    }

    const NeuroMLDocument::SpikeGeneratorRandomSequence& NeuroMLDocument::
    spikeGeneratorRandoms () const
    {
      return this->spikeGeneratorRandom_;
    }

    NeuroMLDocument::SpikeGeneratorRandomSequence& NeuroMLDocument::
    spikeGeneratorRandoms ()
    {
      return this->spikeGeneratorRandom_;
    }

    void NeuroMLDocument::
    setSpikeGeneratorRandoms (const SpikeGeneratorRandomSequence& s)
    {
      this->spikeGeneratorRandom_ = s;
    }

    const NeuroMLDocument::SpikeGeneratorPoissonSequence& NeuroMLDocument::
    spikeGeneratorPoissons () const
    {
      return this->spikeGeneratorPoisson_;
    }

    NeuroMLDocument::SpikeGeneratorPoissonSequence& NeuroMLDocument::
    spikeGeneratorPoissons ()
    {
      return this->spikeGeneratorPoisson_;
    }

    void NeuroMLDocument::
    setSpikeGeneratorPoissons (const SpikeGeneratorPoissonSequence& s)
    {
      this->spikeGeneratorPoisson_ = s;
    }

    const NeuroMLDocument::IF_curr_alphaSequence& NeuroMLDocument::
    IF_curr_alphas () const
    {
      return this->IF_curr_alpha_;
    }

    NeuroMLDocument::IF_curr_alphaSequence& NeuroMLDocument::
    IF_curr_alphas ()
    {
      return this->IF_curr_alpha_;
    }

    void NeuroMLDocument::
    setIF_curr_alphas (const IF_curr_alphaSequence& s)
    {
      this->IF_curr_alpha_ = s;
    }

    const NeuroMLDocument::IF_curr_expSequence& NeuroMLDocument::
    IF_curr_exps () const
    {
      return this->IF_curr_exp_;
    }

    NeuroMLDocument::IF_curr_expSequence& NeuroMLDocument::
    IF_curr_exps ()
    {
      return this->IF_curr_exp_;
    }

    void NeuroMLDocument::
    setIF_curr_exps (const IF_curr_expSequence& s)
    {
      this->IF_curr_exp_ = s;
    }

    const NeuroMLDocument::IF_cond_alphaSequence& NeuroMLDocument::
    IF_cond_alphas () const
    {
      return this->IF_cond_alpha_;
    }

    NeuroMLDocument::IF_cond_alphaSequence& NeuroMLDocument::
    IF_cond_alphas ()
    {
      return this->IF_cond_alpha_;
    }

    void NeuroMLDocument::
    setIF_cond_alphas (const IF_cond_alphaSequence& s)
    {
      this->IF_cond_alpha_ = s;
    }

    const NeuroMLDocument::IF_cond_expSequence& NeuroMLDocument::
    IF_cond_exps () const
    {
      return this->IF_cond_exp_;
    }

    NeuroMLDocument::IF_cond_expSequence& NeuroMLDocument::
    IF_cond_exps ()
    {
      return this->IF_cond_exp_;
    }

    void NeuroMLDocument::
    setIF_cond_exps (const IF_cond_expSequence& s)
    {
      this->IF_cond_exp_ = s;
    }

    const NeuroMLDocument::EIF_cond_exp_isfa_istaSequence& NeuroMLDocument::
    EIF_cond_exp_isfa_istas () const
    {
      return this->EIF_cond_exp_isfa_ista_;
    }

    NeuroMLDocument::EIF_cond_exp_isfa_istaSequence& NeuroMLDocument::
    EIF_cond_exp_isfa_istas ()
    {
      return this->EIF_cond_exp_isfa_ista_;
    }

    void NeuroMLDocument::
    setEIF_cond_exp_isfa_istas (const EIF_cond_exp_isfa_istaSequence& s)
    {
      this->EIF_cond_exp_isfa_ista_ = s;
    }

    const NeuroMLDocument::EIF_cond_alpha_isfa_istaSequence& NeuroMLDocument::
    EIF_cond_alpha_isfa_istas () const
    {
      return this->EIF_cond_alpha_isfa_ista_;
    }

    NeuroMLDocument::EIF_cond_alpha_isfa_istaSequence& NeuroMLDocument::
    EIF_cond_alpha_isfa_istas ()
    {
      return this->EIF_cond_alpha_isfa_ista_;
    }

    void NeuroMLDocument::
    setEIF_cond_alpha_isfa_istas (const EIF_cond_alpha_isfa_istaSequence& s)
    {
      this->EIF_cond_alpha_isfa_ista_ = s;
    }

    const NeuroMLDocument::HH_cond_expSequence& NeuroMLDocument::
    HH_cond_exps () const
    {
      return this->HH_cond_exp_;
    }

    NeuroMLDocument::HH_cond_expSequence& NeuroMLDocument::
    HH_cond_exps ()
    {
      return this->HH_cond_exp_;
    }

    void NeuroMLDocument::
    setHH_cond_exps (const HH_cond_expSequence& s)
    {
      this->HH_cond_exp_ = s;
    }

    const NeuroMLDocument::ExpCondSynapseSequence& NeuroMLDocument::
    expCondSynapses () const
    {
      return this->expCondSynapse_;
    }

    NeuroMLDocument::ExpCondSynapseSequence& NeuroMLDocument::
    expCondSynapses ()
    {
      return this->expCondSynapse_;
    }

    void NeuroMLDocument::
    setExpCondSynapses (const ExpCondSynapseSequence& s)
    {
      this->expCondSynapse_ = s;
    }

    const NeuroMLDocument::AlphaCondSynapseSequence& NeuroMLDocument::
    alphaCondSynapses () const
    {
      return this->alphaCondSynapse_;
    }

    NeuroMLDocument::AlphaCondSynapseSequence& NeuroMLDocument::
    alphaCondSynapses ()
    {
      return this->alphaCondSynapse_;
    }

    void NeuroMLDocument::
    setAlphaCondSynapses (const AlphaCondSynapseSequence& s)
    {
      this->alphaCondSynapse_ = s;
    }

    const NeuroMLDocument::ExpCurrSynapseSequence& NeuroMLDocument::
    expCurrSynapses () const
    {
      return this->expCurrSynapse_;
    }

    NeuroMLDocument::ExpCurrSynapseSequence& NeuroMLDocument::
    expCurrSynapses ()
    {
      return this->expCurrSynapse_;
    }

    void NeuroMLDocument::
    setExpCurrSynapses (const ExpCurrSynapseSequence& s)
    {
      this->expCurrSynapse_ = s;
    }

    const NeuroMLDocument::AlphaCurrSynapseSequence& NeuroMLDocument::
    alphaCurrSynapses () const
    {
      return this->alphaCurrSynapse_;
    }

    NeuroMLDocument::AlphaCurrSynapseSequence& NeuroMLDocument::
    alphaCurrSynapses ()
    {
      return this->alphaCurrSynapse_;
    }

    void NeuroMLDocument::
    setAlphaCurrSynapses (const AlphaCurrSynapseSequence& s)
    {
      this->alphaCurrSynapse_ = s;
    }

    const NeuroMLDocument::SpikeSourcePoissonSequence& NeuroMLDocument::
    SpikeSourcePoissons () const
    {
      return this->SpikeSourcePoisson_;
    }

    NeuroMLDocument::SpikeSourcePoissonSequence& NeuroMLDocument::
    SpikeSourcePoissons ()
    {
      return this->SpikeSourcePoisson_;
    }

    void NeuroMLDocument::
    setSpikeSourcePoissons (const SpikeSourcePoissonSequence& s)
    {
      this->SpikeSourcePoisson_ = s;
    }

    const NeuroMLDocument::NetworkSequence& NeuroMLDocument::
    networks () const
    {
      return this->network_;
    }

    NeuroMLDocument::NetworkSequence& NeuroMLDocument::
    networks ()
    {
      return this->network_;
    }

    void NeuroMLDocument::
    setNetworks (const NetworkSequence& s)
    {
      this->network_ = s;
    }

    const NeuroMLDocument::ComponentTypeSequence& NeuroMLDocument::
    ComponentTypes () const
    {
      return this->ComponentType_;
    }

    NeuroMLDocument::ComponentTypeSequence& NeuroMLDocument::
    ComponentTypes ()
    {
      return this->ComponentType_;
    }

    void NeuroMLDocument::
    setComponentTypes (const ComponentTypeSequence& s)
    {
      this->ComponentType_ = s;
    }


    // IncludeType
    // 

    const IncludeType::HrefOptional& IncludeType::
    href () const
    {
      return this->href_;
    }

    IncludeType::HrefOptional& IncludeType::
    href ()
    {
      return this->href_;
    }

    void IncludeType::
    setHref (const HrefType& x)
    {
      this->href_.set (x);
    }

    void IncludeType::
    setHref (const HrefOptional& x)
    {
      this->href_ = x;
    }

    void IncludeType::
    setHref (::std::unique_ptr< HrefType > x)
    {
      this->href_.set (std::move (x));
    }


    // IonChannel
    // 

    const IonChannel::GateSequence& IonChannel::
    gates () const
    {
      return this->gate_;
    }

    IonChannel::GateSequence& IonChannel::
    gates ()
    {
      return this->gate_;
    }

    void IonChannel::
    setGates (const GateSequence& s)
    {
      this->gate_ = s;
    }

    const IonChannel::GateHHratesSequence& IonChannel::
    gateHHratess () const
    {
      return this->gateHHrates_;
    }

    IonChannel::GateHHratesSequence& IonChannel::
    gateHHratess ()
    {
      return this->gateHHrates_;
    }

    void IonChannel::
    setGateHHratess (const GateHHratesSequence& s)
    {
      this->gateHHrates_ = s;
    }

    const IonChannel::GateHHratesTauSequence& IonChannel::
    gateHHratesTaus () const
    {
      return this->gateHHratesTau_;
    }

    IonChannel::GateHHratesTauSequence& IonChannel::
    gateHHratesTaus ()
    {
      return this->gateHHratesTau_;
    }

    void IonChannel::
    setGateHHratesTaus (const GateHHratesTauSequence& s)
    {
      this->gateHHratesTau_ = s;
    }

    const IonChannel::GateHHtauInfSequence& IonChannel::
    gateHHtauInfs () const
    {
      return this->gateHHtauInf_;
    }

    IonChannel::GateHHtauInfSequence& IonChannel::
    gateHHtauInfs ()
    {
      return this->gateHHtauInf_;
    }

    void IonChannel::
    setGateHHtauInfs (const GateHHtauInfSequence& s)
    {
      this->gateHHtauInf_ = s;
    }

    const IonChannel::GateHHratesInfSequence& IonChannel::
    gateHHratesInfs () const
    {
      return this->gateHHratesInf_;
    }

    IonChannel::GateHHratesInfSequence& IonChannel::
    gateHHratesInfs ()
    {
      return this->gateHHratesInf_;
    }

    void IonChannel::
    setGateHHratesInfs (const GateHHratesInfSequence& s)
    {
      this->gateHHratesInf_ = s;
    }

    const IonChannel::GateHHratesTauInfSequence& IonChannel::
    gateHHratesTauInfs () const
    {
      return this->gateHHratesTauInf_;
    }

    IonChannel::GateHHratesTauInfSequence& IonChannel::
    gateHHratesTauInfs ()
    {
      return this->gateHHratesTauInf_;
    }

    void IonChannel::
    setGateHHratesTauInfs (const GateHHratesTauInfSequence& s)
    {
      this->gateHHratesTauInf_ = s;
    }

    const IonChannel::SpeciesOptional& IonChannel::
    species () const
    {
      return this->species_;
    }

    IonChannel::SpeciesOptional& IonChannel::
    species ()
    {
      return this->species_;
    }

    void IonChannel::
    setSpecies (const SpeciesType& x)
    {
      this->species_.set (x);
    }

    void IonChannel::
    setSpecies (const SpeciesOptional& x)
    {
      this->species_ = x;
    }

    void IonChannel::
    setSpecies (::std::unique_ptr< SpeciesType > x)
    {
      this->species_.set (std::move (x));
    }

    const IonChannel::TypeOptional& IonChannel::
    type () const
    {
      return this->type_;
    }

    IonChannel::TypeOptional& IonChannel::
    type ()
    {
      return this->type_;
    }

    void IonChannel::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void IonChannel::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void IonChannel::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const IonChannel::ConductanceOptional& IonChannel::
    conductance () const
    {
      return this->conductance_;
    }

    IonChannel::ConductanceOptional& IonChannel::
    conductance ()
    {
      return this->conductance_;
    }

    void IonChannel::
    setConductance (const ConductanceType& x)
    {
      this->conductance_.set (x);
    }

    void IonChannel::
    setConductance (const ConductanceOptional& x)
    {
      this->conductance_ = x;
    }

    void IonChannel::
    setConductance (::std::unique_ptr< ConductanceType > x)
    {
      this->conductance_.set (std::move (x));
    }


    // IonChannelHH
    // 


    // ChannelTypes
    // 

    ChannelTypes::
    ChannelTypes (Value v)
    : ::xml_schema::String (_xsd_ChannelTypes_literals_[v])
    {
    }

    ChannelTypes::
    ChannelTypes (const char* v)
    : ::xml_schema::String (v)
    {
    }

    ChannelTypes::
    ChannelTypes (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    ChannelTypes::
    ChannelTypes (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    ChannelTypes::
    ChannelTypes (const ChannelTypes& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    ChannelTypes& ChannelTypes::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_ChannelTypes_literals_[v]);

      return *this;
    }


    // GateTypes
    // 

    GateTypes::
    GateTypes (Value v)
    : ::xml_schema::String (_xsd_GateTypes_literals_[v])
    {
    }

    GateTypes::
    GateTypes (const char* v)
    : ::xml_schema::String (v)
    {
    }

    GateTypes::
    GateTypes (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    GateTypes::
    GateTypes (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    GateTypes::
    GateTypes (const GateTypes& v,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    GateTypes& GateTypes::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_GateTypes_literals_[v]);

      return *this;
    }


    // GateHHUndetermined
    // 

    const GateHHUndetermined::NotesOptional& GateHHUndetermined::
    notes () const
    {
      return this->notes_;
    }

    GateHHUndetermined::NotesOptional& GateHHUndetermined::
    notes ()
    {
      return this->notes_;
    }

    void GateHHUndetermined::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void GateHHUndetermined::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void GateHHUndetermined::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const GateHHUndetermined::Q10SettingsOptional& GateHHUndetermined::
    q10Settings () const
    {
      return this->q10Settings_;
    }

    GateHHUndetermined::Q10SettingsOptional& GateHHUndetermined::
    q10Settings ()
    {
      return this->q10Settings_;
    }

    void GateHHUndetermined::
    setQ10Settings (const Q10SettingsType& x)
    {
      this->q10Settings_.set (x);
    }

    void GateHHUndetermined::
    setQ10Settings (const Q10SettingsOptional& x)
    {
      this->q10Settings_ = x;
    }

    void GateHHUndetermined::
    setQ10Settings (::std::unique_ptr< Q10SettingsType > x)
    {
      this->q10Settings_.set (std::move (x));
    }

    const GateHHUndetermined::ForwardRateOptional& GateHHUndetermined::
    forwardRate () const
    {
      return this->forwardRate_;
    }

    GateHHUndetermined::ForwardRateOptional& GateHHUndetermined::
    forwardRate ()
    {
      return this->forwardRate_;
    }

    void GateHHUndetermined::
    setForwardRate (const ForwardRateType& x)
    {
      this->forwardRate_.set (x);
    }

    void GateHHUndetermined::
    setForwardRate (const ForwardRateOptional& x)
    {
      this->forwardRate_ = x;
    }

    void GateHHUndetermined::
    setForwardRate (::std::unique_ptr< ForwardRateType > x)
    {
      this->forwardRate_.set (std::move (x));
    }

    const GateHHUndetermined::ReverseRateOptional& GateHHUndetermined::
    reverseRate () const
    {
      return this->reverseRate_;
    }

    GateHHUndetermined::ReverseRateOptional& GateHHUndetermined::
    reverseRate ()
    {
      return this->reverseRate_;
    }

    void GateHHUndetermined::
    setReverseRate (const ReverseRateType& x)
    {
      this->reverseRate_.set (x);
    }

    void GateHHUndetermined::
    setReverseRate (const ReverseRateOptional& x)
    {
      this->reverseRate_ = x;
    }

    void GateHHUndetermined::
    setReverseRate (::std::unique_ptr< ReverseRateType > x)
    {
      this->reverseRate_.set (std::move (x));
    }

    const GateHHUndetermined::TimeCourseOptional& GateHHUndetermined::
    timeCourse () const
    {
      return this->timeCourse_;
    }

    GateHHUndetermined::TimeCourseOptional& GateHHUndetermined::
    timeCourse ()
    {
      return this->timeCourse_;
    }

    void GateHHUndetermined::
    setTimeCourse (const TimeCourseType& x)
    {
      this->timeCourse_.set (x);
    }

    void GateHHUndetermined::
    setTimeCourse (const TimeCourseOptional& x)
    {
      this->timeCourse_ = x;
    }

    void GateHHUndetermined::
    setTimeCourse (::std::unique_ptr< TimeCourseType > x)
    {
      this->timeCourse_.set (std::move (x));
    }

    const GateHHUndetermined::SteadyStateOptional& GateHHUndetermined::
    steadyState () const
    {
      return this->steadyState_;
    }

    GateHHUndetermined::SteadyStateOptional& GateHHUndetermined::
    steadyState ()
    {
      return this->steadyState_;
    }

    void GateHHUndetermined::
    setSteadyState (const SteadyStateType& x)
    {
      this->steadyState_.set (x);
    }

    void GateHHUndetermined::
    setSteadyState (const SteadyStateOptional& x)
    {
      this->steadyState_ = x;
    }

    void GateHHUndetermined::
    setSteadyState (::std::unique_ptr< SteadyStateType > x)
    {
      this->steadyState_.set (std::move (x));
    }

    const GateHHUndetermined::InstancesType& GateHHUndetermined::
    instances () const
    {
      return this->instances_.get ();
    }

    GateHHUndetermined::InstancesType& GateHHUndetermined::
    instances ()
    {
      return this->instances_.get ();
    }

    void GateHHUndetermined::
    setInstances (const InstancesType& x)
    {
      this->instances_.set (x);
    }

    GateHHUndetermined::InstancesType GateHHUndetermined::
    instancesDefaultValue ()
    {
      return InstancesType (1LL);
    }

    const GateHHUndetermined::TypeOptional& GateHHUndetermined::
    type () const
    {
      return this->type_;
    }

    GateHHUndetermined::TypeOptional& GateHHUndetermined::
    type ()
    {
      return this->type_;
    }

    void GateHHUndetermined::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void GateHHUndetermined::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void GateHHUndetermined::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // GateHHRates
    // 

    const GateHHRates::NotesOptional& GateHHRates::
    notes () const
    {
      return this->notes_;
    }

    GateHHRates::NotesOptional& GateHHRates::
    notes ()
    {
      return this->notes_;
    }

    void GateHHRates::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void GateHHRates::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void GateHHRates::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const GateHHRates::Q10SettingsOptional& GateHHRates::
    q10Settings () const
    {
      return this->q10Settings_;
    }

    GateHHRates::Q10SettingsOptional& GateHHRates::
    q10Settings ()
    {
      return this->q10Settings_;
    }

    void GateHHRates::
    setQ10Settings (const Q10SettingsType& x)
    {
      this->q10Settings_.set (x);
    }

    void GateHHRates::
    setQ10Settings (const Q10SettingsOptional& x)
    {
      this->q10Settings_ = x;
    }

    void GateHHRates::
    setQ10Settings (::std::unique_ptr< Q10SettingsType > x)
    {
      this->q10Settings_.set (std::move (x));
    }

    const GateHHRates::ForwardRateType& GateHHRates::
    forwardRate () const
    {
      return this->forwardRate_.get ();
    }

    GateHHRates::ForwardRateType& GateHHRates::
    forwardRate ()
    {
      return this->forwardRate_.get ();
    }

    void GateHHRates::
    setForwardRate (const ForwardRateType& x)
    {
      this->forwardRate_.set (x);
    }

    void GateHHRates::
    setForwardRate (::std::unique_ptr< ForwardRateType > x)
    {
      this->forwardRate_.set (std::move (x));
    }

    const GateHHRates::ReverseRateType& GateHHRates::
    reverseRate () const
    {
      return this->reverseRate_.get ();
    }

    GateHHRates::ReverseRateType& GateHHRates::
    reverseRate ()
    {
      return this->reverseRate_.get ();
    }

    void GateHHRates::
    setReverseRate (const ReverseRateType& x)
    {
      this->reverseRate_.set (x);
    }

    void GateHHRates::
    setReverseRate (::std::unique_ptr< ReverseRateType > x)
    {
      this->reverseRate_.set (std::move (x));
    }

    const GateHHRates::InstancesType& GateHHRates::
    instances () const
    {
      return this->instances_.get ();
    }

    GateHHRates::InstancesType& GateHHRates::
    instances ()
    {
      return this->instances_.get ();
    }

    void GateHHRates::
    setInstances (const InstancesType& x)
    {
      this->instances_.set (x);
    }

    GateHHRates::InstancesType GateHHRates::
    instancesDefaultValue ()
    {
      return InstancesType (1LL);
    }

    const GateHHRates::TypeOptional& GateHHRates::
    type () const
    {
      return this->type_;
    }

    GateHHRates::TypeOptional& GateHHRates::
    type ()
    {
      return this->type_;
    }

    void GateHHRates::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void GateHHRates::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void GateHHRates::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // GateHHTauInf
    // 

    const GateHHTauInf::NotesOptional& GateHHTauInf::
    notes () const
    {
      return this->notes_;
    }

    GateHHTauInf::NotesOptional& GateHHTauInf::
    notes ()
    {
      return this->notes_;
    }

    void GateHHTauInf::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void GateHHTauInf::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void GateHHTauInf::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const GateHHTauInf::Q10SettingsOptional& GateHHTauInf::
    q10Settings () const
    {
      return this->q10Settings_;
    }

    GateHHTauInf::Q10SettingsOptional& GateHHTauInf::
    q10Settings ()
    {
      return this->q10Settings_;
    }

    void GateHHTauInf::
    setQ10Settings (const Q10SettingsType& x)
    {
      this->q10Settings_.set (x);
    }

    void GateHHTauInf::
    setQ10Settings (const Q10SettingsOptional& x)
    {
      this->q10Settings_ = x;
    }

    void GateHHTauInf::
    setQ10Settings (::std::unique_ptr< Q10SettingsType > x)
    {
      this->q10Settings_.set (std::move (x));
    }

    const GateHHTauInf::TimeCourseType& GateHHTauInf::
    timeCourse () const
    {
      return this->timeCourse_.get ();
    }

    GateHHTauInf::TimeCourseType& GateHHTauInf::
    timeCourse ()
    {
      return this->timeCourse_.get ();
    }

    void GateHHTauInf::
    setTimeCourse (const TimeCourseType& x)
    {
      this->timeCourse_.set (x);
    }

    void GateHHTauInf::
    setTimeCourse (::std::unique_ptr< TimeCourseType > x)
    {
      this->timeCourse_.set (std::move (x));
    }

    const GateHHTauInf::SteadyStateType& GateHHTauInf::
    steadyState () const
    {
      return this->steadyState_.get ();
    }

    GateHHTauInf::SteadyStateType& GateHHTauInf::
    steadyState ()
    {
      return this->steadyState_.get ();
    }

    void GateHHTauInf::
    setSteadyState (const SteadyStateType& x)
    {
      this->steadyState_.set (x);
    }

    void GateHHTauInf::
    setSteadyState (::std::unique_ptr< SteadyStateType > x)
    {
      this->steadyState_.set (std::move (x));
    }

    const GateHHTauInf::InstancesType& GateHHTauInf::
    instances () const
    {
      return this->instances_.get ();
    }

    GateHHTauInf::InstancesType& GateHHTauInf::
    instances ()
    {
      return this->instances_.get ();
    }

    void GateHHTauInf::
    setInstances (const InstancesType& x)
    {
      this->instances_.set (x);
    }

    GateHHTauInf::InstancesType GateHHTauInf::
    instancesDefaultValue ()
    {
      return InstancesType (1LL);
    }

    const GateHHTauInf::TypeOptional& GateHHTauInf::
    type () const
    {
      return this->type_;
    }

    GateHHTauInf::TypeOptional& GateHHTauInf::
    type ()
    {
      return this->type_;
    }

    void GateHHTauInf::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void GateHHTauInf::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void GateHHTauInf::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // GateHHRatesTauInf
    // 

    const GateHHRatesTauInf::NotesOptional& GateHHRatesTauInf::
    notes () const
    {
      return this->notes_;
    }

    GateHHRatesTauInf::NotesOptional& GateHHRatesTauInf::
    notes ()
    {
      return this->notes_;
    }

    void GateHHRatesTauInf::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void GateHHRatesTauInf::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void GateHHRatesTauInf::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const GateHHRatesTauInf::Q10SettingsOptional& GateHHRatesTauInf::
    q10Settings () const
    {
      return this->q10Settings_;
    }

    GateHHRatesTauInf::Q10SettingsOptional& GateHHRatesTauInf::
    q10Settings ()
    {
      return this->q10Settings_;
    }

    void GateHHRatesTauInf::
    setQ10Settings (const Q10SettingsType& x)
    {
      this->q10Settings_.set (x);
    }

    void GateHHRatesTauInf::
    setQ10Settings (const Q10SettingsOptional& x)
    {
      this->q10Settings_ = x;
    }

    void GateHHRatesTauInf::
    setQ10Settings (::std::unique_ptr< Q10SettingsType > x)
    {
      this->q10Settings_.set (std::move (x));
    }

    const GateHHRatesTauInf::ForwardRateType& GateHHRatesTauInf::
    forwardRate () const
    {
      return this->forwardRate_.get ();
    }

    GateHHRatesTauInf::ForwardRateType& GateHHRatesTauInf::
    forwardRate ()
    {
      return this->forwardRate_.get ();
    }

    void GateHHRatesTauInf::
    setForwardRate (const ForwardRateType& x)
    {
      this->forwardRate_.set (x);
    }

    void GateHHRatesTauInf::
    setForwardRate (::std::unique_ptr< ForwardRateType > x)
    {
      this->forwardRate_.set (std::move (x));
    }

    const GateHHRatesTauInf::ReverseRateType& GateHHRatesTauInf::
    reverseRate () const
    {
      return this->reverseRate_.get ();
    }

    GateHHRatesTauInf::ReverseRateType& GateHHRatesTauInf::
    reverseRate ()
    {
      return this->reverseRate_.get ();
    }

    void GateHHRatesTauInf::
    setReverseRate (const ReverseRateType& x)
    {
      this->reverseRate_.set (x);
    }

    void GateHHRatesTauInf::
    setReverseRate (::std::unique_ptr< ReverseRateType > x)
    {
      this->reverseRate_.set (std::move (x));
    }

    const GateHHRatesTauInf::TimeCourseType& GateHHRatesTauInf::
    timeCourse () const
    {
      return this->timeCourse_.get ();
    }

    GateHHRatesTauInf::TimeCourseType& GateHHRatesTauInf::
    timeCourse ()
    {
      return this->timeCourse_.get ();
    }

    void GateHHRatesTauInf::
    setTimeCourse (const TimeCourseType& x)
    {
      this->timeCourse_.set (x);
    }

    void GateHHRatesTauInf::
    setTimeCourse (::std::unique_ptr< TimeCourseType > x)
    {
      this->timeCourse_.set (std::move (x));
    }

    const GateHHRatesTauInf::SteadyStateType& GateHHRatesTauInf::
    steadyState () const
    {
      return this->steadyState_.get ();
    }

    GateHHRatesTauInf::SteadyStateType& GateHHRatesTauInf::
    steadyState ()
    {
      return this->steadyState_.get ();
    }

    void GateHHRatesTauInf::
    setSteadyState (const SteadyStateType& x)
    {
      this->steadyState_.set (x);
    }

    void GateHHRatesTauInf::
    setSteadyState (::std::unique_ptr< SteadyStateType > x)
    {
      this->steadyState_.set (std::move (x));
    }

    const GateHHRatesTauInf::InstancesType& GateHHRatesTauInf::
    instances () const
    {
      return this->instances_.get ();
    }

    GateHHRatesTauInf::InstancesType& GateHHRatesTauInf::
    instances ()
    {
      return this->instances_.get ();
    }

    void GateHHRatesTauInf::
    setInstances (const InstancesType& x)
    {
      this->instances_.set (x);
    }

    GateHHRatesTauInf::InstancesType GateHHRatesTauInf::
    instancesDefaultValue ()
    {
      return InstancesType (1LL);
    }

    const GateHHRatesTauInf::TypeOptional& GateHHRatesTauInf::
    type () const
    {
      return this->type_;
    }

    GateHHRatesTauInf::TypeOptional& GateHHRatesTauInf::
    type ()
    {
      return this->type_;
    }

    void GateHHRatesTauInf::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void GateHHRatesTauInf::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void GateHHRatesTauInf::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // GateHHRatesTau
    // 

    const GateHHRatesTau::NotesOptional& GateHHRatesTau::
    notes () const
    {
      return this->notes_;
    }

    GateHHRatesTau::NotesOptional& GateHHRatesTau::
    notes ()
    {
      return this->notes_;
    }

    void GateHHRatesTau::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void GateHHRatesTau::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void GateHHRatesTau::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const GateHHRatesTau::Q10SettingsOptional& GateHHRatesTau::
    q10Settings () const
    {
      return this->q10Settings_;
    }

    GateHHRatesTau::Q10SettingsOptional& GateHHRatesTau::
    q10Settings ()
    {
      return this->q10Settings_;
    }

    void GateHHRatesTau::
    setQ10Settings (const Q10SettingsType& x)
    {
      this->q10Settings_.set (x);
    }

    void GateHHRatesTau::
    setQ10Settings (const Q10SettingsOptional& x)
    {
      this->q10Settings_ = x;
    }

    void GateHHRatesTau::
    setQ10Settings (::std::unique_ptr< Q10SettingsType > x)
    {
      this->q10Settings_.set (std::move (x));
    }

    const GateHHRatesTau::ForwardRateType& GateHHRatesTau::
    forwardRate () const
    {
      return this->forwardRate_.get ();
    }

    GateHHRatesTau::ForwardRateType& GateHHRatesTau::
    forwardRate ()
    {
      return this->forwardRate_.get ();
    }

    void GateHHRatesTau::
    setForwardRate (const ForwardRateType& x)
    {
      this->forwardRate_.set (x);
    }

    void GateHHRatesTau::
    setForwardRate (::std::unique_ptr< ForwardRateType > x)
    {
      this->forwardRate_.set (std::move (x));
    }

    const GateHHRatesTau::ReverseRateType& GateHHRatesTau::
    reverseRate () const
    {
      return this->reverseRate_.get ();
    }

    GateHHRatesTau::ReverseRateType& GateHHRatesTau::
    reverseRate ()
    {
      return this->reverseRate_.get ();
    }

    void GateHHRatesTau::
    setReverseRate (const ReverseRateType& x)
    {
      this->reverseRate_.set (x);
    }

    void GateHHRatesTau::
    setReverseRate (::std::unique_ptr< ReverseRateType > x)
    {
      this->reverseRate_.set (std::move (x));
    }

    const GateHHRatesTau::TimeCourseType& GateHHRatesTau::
    timeCourse () const
    {
      return this->timeCourse_.get ();
    }

    GateHHRatesTau::TimeCourseType& GateHHRatesTau::
    timeCourse ()
    {
      return this->timeCourse_.get ();
    }

    void GateHHRatesTau::
    setTimeCourse (const TimeCourseType& x)
    {
      this->timeCourse_.set (x);
    }

    void GateHHRatesTau::
    setTimeCourse (::std::unique_ptr< TimeCourseType > x)
    {
      this->timeCourse_.set (std::move (x));
    }

    const GateHHRatesTau::InstancesType& GateHHRatesTau::
    instances () const
    {
      return this->instances_.get ();
    }

    GateHHRatesTau::InstancesType& GateHHRatesTau::
    instances ()
    {
      return this->instances_.get ();
    }

    void GateHHRatesTau::
    setInstances (const InstancesType& x)
    {
      this->instances_.set (x);
    }

    GateHHRatesTau::InstancesType GateHHRatesTau::
    instancesDefaultValue ()
    {
      return InstancesType (1LL);
    }

    const GateHHRatesTau::TypeOptional& GateHHRatesTau::
    type () const
    {
      return this->type_;
    }

    GateHHRatesTau::TypeOptional& GateHHRatesTau::
    type ()
    {
      return this->type_;
    }

    void GateHHRatesTau::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void GateHHRatesTau::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void GateHHRatesTau::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // GateHHRatesInf
    // 

    const GateHHRatesInf::NotesOptional& GateHHRatesInf::
    notes () const
    {
      return this->notes_;
    }

    GateHHRatesInf::NotesOptional& GateHHRatesInf::
    notes ()
    {
      return this->notes_;
    }

    void GateHHRatesInf::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void GateHHRatesInf::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void GateHHRatesInf::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const GateHHRatesInf::Q10SettingsOptional& GateHHRatesInf::
    q10Settings () const
    {
      return this->q10Settings_;
    }

    GateHHRatesInf::Q10SettingsOptional& GateHHRatesInf::
    q10Settings ()
    {
      return this->q10Settings_;
    }

    void GateHHRatesInf::
    setQ10Settings (const Q10SettingsType& x)
    {
      this->q10Settings_.set (x);
    }

    void GateHHRatesInf::
    setQ10Settings (const Q10SettingsOptional& x)
    {
      this->q10Settings_ = x;
    }

    void GateHHRatesInf::
    setQ10Settings (::std::unique_ptr< Q10SettingsType > x)
    {
      this->q10Settings_.set (std::move (x));
    }

    const GateHHRatesInf::ForwardRateType& GateHHRatesInf::
    forwardRate () const
    {
      return this->forwardRate_.get ();
    }

    GateHHRatesInf::ForwardRateType& GateHHRatesInf::
    forwardRate ()
    {
      return this->forwardRate_.get ();
    }

    void GateHHRatesInf::
    setForwardRate (const ForwardRateType& x)
    {
      this->forwardRate_.set (x);
    }

    void GateHHRatesInf::
    setForwardRate (::std::unique_ptr< ForwardRateType > x)
    {
      this->forwardRate_.set (std::move (x));
    }

    const GateHHRatesInf::ReverseRateType& GateHHRatesInf::
    reverseRate () const
    {
      return this->reverseRate_.get ();
    }

    GateHHRatesInf::ReverseRateType& GateHHRatesInf::
    reverseRate ()
    {
      return this->reverseRate_.get ();
    }

    void GateHHRatesInf::
    setReverseRate (const ReverseRateType& x)
    {
      this->reverseRate_.set (x);
    }

    void GateHHRatesInf::
    setReverseRate (::std::unique_ptr< ReverseRateType > x)
    {
      this->reverseRate_.set (std::move (x));
    }

    const GateHHRatesInf::SteadyStateType& GateHHRatesInf::
    steadyState () const
    {
      return this->steadyState_.get ();
    }

    GateHHRatesInf::SteadyStateType& GateHHRatesInf::
    steadyState ()
    {
      return this->steadyState_.get ();
    }

    void GateHHRatesInf::
    setSteadyState (const SteadyStateType& x)
    {
      this->steadyState_.set (x);
    }

    void GateHHRatesInf::
    setSteadyState (::std::unique_ptr< SteadyStateType > x)
    {
      this->steadyState_.set (std::move (x));
    }

    const GateHHRatesInf::InstancesType& GateHHRatesInf::
    instances () const
    {
      return this->instances_.get ();
    }

    GateHHRatesInf::InstancesType& GateHHRatesInf::
    instances ()
    {
      return this->instances_.get ();
    }

    void GateHHRatesInf::
    setInstances (const InstancesType& x)
    {
      this->instances_.set (x);
    }

    GateHHRatesInf::InstancesType GateHHRatesInf::
    instancesDefaultValue ()
    {
      return InstancesType (1LL);
    }

    const GateHHRatesInf::TypeOptional& GateHHRatesInf::
    type () const
    {
      return this->type_;
    }

    GateHHRatesInf::TypeOptional& GateHHRatesInf::
    type ()
    {
      return this->type_;
    }

    void GateHHRatesInf::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void GateHHRatesInf::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void GateHHRatesInf::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // Q10Settings
    // 

    const Q10Settings::TypeType& Q10Settings::
    type () const
    {
      return this->type_.get ();
    }

    Q10Settings::TypeType& Q10Settings::
    type ()
    {
      return this->type_.get ();
    }

    void Q10Settings::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void Q10Settings::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const Q10Settings::FixedQ10Optional& Q10Settings::
    fixedQ10 () const
    {
      return this->fixedQ10_;
    }

    Q10Settings::FixedQ10Optional& Q10Settings::
    fixedQ10 ()
    {
      return this->fixedQ10_;
    }

    void Q10Settings::
    setFixedQ10 (const FixedQ10Type& x)
    {
      this->fixedQ10_.set (x);
    }

    void Q10Settings::
    setFixedQ10 (const FixedQ10Optional& x)
    {
      this->fixedQ10_ = x;
    }

    void Q10Settings::
    setFixedQ10 (::std::unique_ptr< FixedQ10Type > x)
    {
      this->fixedQ10_.set (std::move (x));
    }

    const Q10Settings::Q10FactorOptional& Q10Settings::
    q10Factor () const
    {
      return this->q10Factor_;
    }

    Q10Settings::Q10FactorOptional& Q10Settings::
    q10Factor ()
    {
      return this->q10Factor_;
    }

    void Q10Settings::
    setQ10Factor (const Q10FactorType& x)
    {
      this->q10Factor_.set (x);
    }

    void Q10Settings::
    setQ10Factor (const Q10FactorOptional& x)
    {
      this->q10Factor_ = x;
    }

    void Q10Settings::
    setQ10Factor (::std::unique_ptr< Q10FactorType > x)
    {
      this->q10Factor_.set (std::move (x));
    }

    const Q10Settings::ExperimentalTempOptional& Q10Settings::
    experimentalTemp () const
    {
      return this->experimentalTemp_;
    }

    Q10Settings::ExperimentalTempOptional& Q10Settings::
    experimentalTemp ()
    {
      return this->experimentalTemp_;
    }

    void Q10Settings::
    setExperimentalTemp (const ExperimentalTempType& x)
    {
      this->experimentalTemp_.set (x);
    }

    void Q10Settings::
    setExperimentalTemp (const ExperimentalTempOptional& x)
    {
      this->experimentalTemp_ = x;
    }

    void Q10Settings::
    setExperimentalTemp (::std::unique_ptr< ExperimentalTempType > x)
    {
      this->experimentalTemp_.set (std::move (x));
    }


    // HHRate
    // 

    const HHRate::TypeType& HHRate::
    type () const
    {
      return this->type_.get ();
    }

    HHRate::TypeType& HHRate::
    type ()
    {
      return this->type_.get ();
    }

    void HHRate::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void HHRate::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const HHRate::RateOptional& HHRate::
    rate () const
    {
      return this->rate_;
    }

    HHRate::RateOptional& HHRate::
    rate ()
    {
      return this->rate_;
    }

    void HHRate::
    setRate (const RateType& x)
    {
      this->rate_.set (x);
    }

    void HHRate::
    setRate (const RateOptional& x)
    {
      this->rate_ = x;
    }

    void HHRate::
    setRate (::std::unique_ptr< RateType > x)
    {
      this->rate_.set (std::move (x));
    }

    const HHRate::MidpointOptional& HHRate::
    midpoint () const
    {
      return this->midpoint_;
    }

    HHRate::MidpointOptional& HHRate::
    midpoint ()
    {
      return this->midpoint_;
    }

    void HHRate::
    setMidpoint (const MidpointType& x)
    {
      this->midpoint_.set (x);
    }

    void HHRate::
    setMidpoint (const MidpointOptional& x)
    {
      this->midpoint_ = x;
    }

    void HHRate::
    setMidpoint (::std::unique_ptr< MidpointType > x)
    {
      this->midpoint_.set (std::move (x));
    }

    const HHRate::ScaleOptional& HHRate::
    scale () const
    {
      return this->scale_;
    }

    HHRate::ScaleOptional& HHRate::
    scale ()
    {
      return this->scale_;
    }

    void HHRate::
    setScale (const ScaleType& x)
    {
      this->scale_.set (x);
    }

    void HHRate::
    setScale (const ScaleOptional& x)
    {
      this->scale_ = x;
    }

    void HHRate::
    setScale (::std::unique_ptr< ScaleType > x)
    {
      this->scale_.set (std::move (x));
    }


    // HHVariable
    // 

    const HHVariable::TypeType& HHVariable::
    type () const
    {
      return this->type_.get ();
    }

    HHVariable::TypeType& HHVariable::
    type ()
    {
      return this->type_.get ();
    }

    void HHVariable::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void HHVariable::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const HHVariable::RateOptional& HHVariable::
    rate () const
    {
      return this->rate_;
    }

    HHVariable::RateOptional& HHVariable::
    rate ()
    {
      return this->rate_;
    }

    void HHVariable::
    setRate (const RateType& x)
    {
      this->rate_.set (x);
    }

    void HHVariable::
    setRate (const RateOptional& x)
    {
      this->rate_ = x;
    }

    const HHVariable::MidpointOptional& HHVariable::
    midpoint () const
    {
      return this->midpoint_;
    }

    HHVariable::MidpointOptional& HHVariable::
    midpoint ()
    {
      return this->midpoint_;
    }

    void HHVariable::
    setMidpoint (const MidpointType& x)
    {
      this->midpoint_.set (x);
    }

    void HHVariable::
    setMidpoint (const MidpointOptional& x)
    {
      this->midpoint_ = x;
    }

    void HHVariable::
    setMidpoint (::std::unique_ptr< MidpointType > x)
    {
      this->midpoint_.set (std::move (x));
    }

    const HHVariable::ScaleOptional& HHVariable::
    scale () const
    {
      return this->scale_;
    }

    HHVariable::ScaleOptional& HHVariable::
    scale ()
    {
      return this->scale_;
    }

    void HHVariable::
    setScale (const ScaleType& x)
    {
      this->scale_.set (x);
    }

    void HHVariable::
    setScale (const ScaleOptional& x)
    {
      this->scale_ = x;
    }

    void HHVariable::
    setScale (::std::unique_ptr< ScaleType > x)
    {
      this->scale_.set (std::move (x));
    }


    // HHTime
    // 

    const HHTime::TypeType& HHTime::
    type () const
    {
      return this->type_.get ();
    }

    HHTime::TypeType& HHTime::
    type ()
    {
      return this->type_.get ();
    }

    void HHTime::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void HHTime::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const HHTime::RateOptional& HHTime::
    rate () const
    {
      return this->rate_;
    }

    HHTime::RateOptional& HHTime::
    rate ()
    {
      return this->rate_;
    }

    void HHTime::
    setRate (const RateType& x)
    {
      this->rate_.set (x);
    }

    void HHTime::
    setRate (const RateOptional& x)
    {
      this->rate_ = x;
    }

    void HHTime::
    setRate (::std::unique_ptr< RateType > x)
    {
      this->rate_.set (std::move (x));
    }

    const HHTime::MidpointOptional& HHTime::
    midpoint () const
    {
      return this->midpoint_;
    }

    HHTime::MidpointOptional& HHTime::
    midpoint ()
    {
      return this->midpoint_;
    }

    void HHTime::
    setMidpoint (const MidpointType& x)
    {
      this->midpoint_.set (x);
    }

    void HHTime::
    setMidpoint (const MidpointOptional& x)
    {
      this->midpoint_ = x;
    }

    void HHTime::
    setMidpoint (::std::unique_ptr< MidpointType > x)
    {
      this->midpoint_.set (std::move (x));
    }

    const HHTime::ScaleOptional& HHTime::
    scale () const
    {
      return this->scale_;
    }

    HHTime::ScaleOptional& HHTime::
    scale ()
    {
      return this->scale_;
    }

    void HHTime::
    setScale (const ScaleType& x)
    {
      this->scale_.set (x);
    }

    void HHTime::
    setScale (const ScaleOptional& x)
    {
      this->scale_ = x;
    }

    void HHTime::
    setScale (::std::unique_ptr< ScaleType > x)
    {
      this->scale_.set (std::move (x));
    }

    const HHTime::TauOptional& HHTime::
    tau () const
    {
      return this->tau_;
    }

    HHTime::TauOptional& HHTime::
    tau ()
    {
      return this->tau_;
    }

    void HHTime::
    setTau (const TauType& x)
    {
      this->tau_.set (x);
    }

    void HHTime::
    setTau (const TauOptional& x)
    {
      this->tau_ = x;
    }

    void HHTime::
    setTau (::std::unique_ptr< TauType > x)
    {
      this->tau_.set (std::move (x));
    }


    // DecayingPoolConcentrationModel
    // 

    const DecayingPoolConcentrationModel::IonType& DecayingPoolConcentrationModel::
    ion () const
    {
      return this->ion_.get ();
    }

    DecayingPoolConcentrationModel::IonType& DecayingPoolConcentrationModel::
    ion ()
    {
      return this->ion_.get ();
    }

    void DecayingPoolConcentrationModel::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void DecayingPoolConcentrationModel::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }

    const DecayingPoolConcentrationModel::RestingConcType& DecayingPoolConcentrationModel::
    restingConc () const
    {
      return this->restingConc_.get ();
    }

    DecayingPoolConcentrationModel::RestingConcType& DecayingPoolConcentrationModel::
    restingConc ()
    {
      return this->restingConc_.get ();
    }

    void DecayingPoolConcentrationModel::
    setRestingConc (const RestingConcType& x)
    {
      this->restingConc_.set (x);
    }

    void DecayingPoolConcentrationModel::
    setRestingConc (::std::unique_ptr< RestingConcType > x)
    {
      this->restingConc_.set (std::move (x));
    }

    const DecayingPoolConcentrationModel::DecayConstantType& DecayingPoolConcentrationModel::
    decayConstant () const
    {
      return this->decayConstant_.get ();
    }

    DecayingPoolConcentrationModel::DecayConstantType& DecayingPoolConcentrationModel::
    decayConstant ()
    {
      return this->decayConstant_.get ();
    }

    void DecayingPoolConcentrationModel::
    setDecayConstant (const DecayConstantType& x)
    {
      this->decayConstant_.set (x);
    }

    void DecayingPoolConcentrationModel::
    setDecayConstant (::std::unique_ptr< DecayConstantType > x)
    {
      this->decayConstant_.set (std::move (x));
    }

    const DecayingPoolConcentrationModel::ShellThicknessType& DecayingPoolConcentrationModel::
    shellThickness () const
    {
      return this->shellThickness_.get ();
    }

    DecayingPoolConcentrationModel::ShellThicknessType& DecayingPoolConcentrationModel::
    shellThickness ()
    {
      return this->shellThickness_.get ();
    }

    void DecayingPoolConcentrationModel::
    setShellThickness (const ShellThicknessType& x)
    {
      this->shellThickness_.set (x);
    }

    void DecayingPoolConcentrationModel::
    setShellThickness (::std::unique_ptr< ShellThicknessType > x)
    {
      this->shellThickness_.set (std::move (x));
    }


    // FixedFactorConcentrationModel
    // 

    const FixedFactorConcentrationModel::IonType& FixedFactorConcentrationModel::
    ion () const
    {
      return this->ion_.get ();
    }

    FixedFactorConcentrationModel::IonType& FixedFactorConcentrationModel::
    ion ()
    {
      return this->ion_.get ();
    }

    void FixedFactorConcentrationModel::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void FixedFactorConcentrationModel::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }

    const FixedFactorConcentrationModel::RestingConcType& FixedFactorConcentrationModel::
    restingConc () const
    {
      return this->restingConc_.get ();
    }

    FixedFactorConcentrationModel::RestingConcType& FixedFactorConcentrationModel::
    restingConc ()
    {
      return this->restingConc_.get ();
    }

    void FixedFactorConcentrationModel::
    setRestingConc (const RestingConcType& x)
    {
      this->restingConc_.set (x);
    }

    void FixedFactorConcentrationModel::
    setRestingConc (::std::unique_ptr< RestingConcType > x)
    {
      this->restingConc_.set (std::move (x));
    }

    const FixedFactorConcentrationModel::DecayConstantType& FixedFactorConcentrationModel::
    decayConstant () const
    {
      return this->decayConstant_.get ();
    }

    FixedFactorConcentrationModel::DecayConstantType& FixedFactorConcentrationModel::
    decayConstant ()
    {
      return this->decayConstant_.get ();
    }

    void FixedFactorConcentrationModel::
    setDecayConstant (const DecayConstantType& x)
    {
      this->decayConstant_.set (x);
    }

    void FixedFactorConcentrationModel::
    setDecayConstant (::std::unique_ptr< DecayConstantType > x)
    {
      this->decayConstant_.set (std::move (x));
    }

    const FixedFactorConcentrationModel::RhoType& FixedFactorConcentrationModel::
    rho () const
    {
      return this->rho_.get ();
    }

    FixedFactorConcentrationModel::RhoType& FixedFactorConcentrationModel::
    rho ()
    {
      return this->rho_.get ();
    }

    void FixedFactorConcentrationModel::
    setRho (const RhoType& x)
    {
      this->rho_.set (x);
    }

    void FixedFactorConcentrationModel::
    setRho (::std::unique_ptr< RhoType > x)
    {
      this->rho_.set (std::move (x));
    }


    // BaseSynapse
    // 


    // BaseConductanceBasedSynapse
    // 

    const BaseConductanceBasedSynapse::GbaseType& BaseConductanceBasedSynapse::
    gbase () const
    {
      return this->gbase_.get ();
    }

    BaseConductanceBasedSynapse::GbaseType& BaseConductanceBasedSynapse::
    gbase ()
    {
      return this->gbase_.get ();
    }

    void BaseConductanceBasedSynapse::
    setGbase (const GbaseType& x)
    {
      this->gbase_.set (x);
    }

    void BaseConductanceBasedSynapse::
    setGbase (::std::unique_ptr< GbaseType > x)
    {
      this->gbase_.set (std::move (x));
    }

    const BaseConductanceBasedSynapse::ErevType& BaseConductanceBasedSynapse::
    erev () const
    {
      return this->erev_.get ();
    }

    BaseConductanceBasedSynapse::ErevType& BaseConductanceBasedSynapse::
    erev ()
    {
      return this->erev_.get ();
    }

    void BaseConductanceBasedSynapse::
    setErev (const ErevType& x)
    {
      this->erev_.set (x);
    }

    void BaseConductanceBasedSynapse::
    setErev (::std::unique_ptr< ErevType > x)
    {
      this->erev_.set (std::move (x));
    }


    // ExpOneSynapse
    // 

    const ExpOneSynapse::TauDecayType& ExpOneSynapse::
    tauDecay () const
    {
      return this->tauDecay_.get ();
    }

    ExpOneSynapse::TauDecayType& ExpOneSynapse::
    tauDecay ()
    {
      return this->tauDecay_.get ();
    }

    void ExpOneSynapse::
    setTauDecay (const TauDecayType& x)
    {
      this->tauDecay_.set (x);
    }

    void ExpOneSynapse::
    setTauDecay (::std::unique_ptr< TauDecayType > x)
    {
      this->tauDecay_.set (std::move (x));
    }


    // ExpTwoSynapse
    // 

    const ExpTwoSynapse::TauDecayType& ExpTwoSynapse::
    tauDecay () const
    {
      return this->tauDecay_.get ();
    }

    ExpTwoSynapse::TauDecayType& ExpTwoSynapse::
    tauDecay ()
    {
      return this->tauDecay_.get ();
    }

    void ExpTwoSynapse::
    setTauDecay (const TauDecayType& x)
    {
      this->tauDecay_.set (x);
    }

    void ExpTwoSynapse::
    setTauDecay (::std::unique_ptr< TauDecayType > x)
    {
      this->tauDecay_.set (std::move (x));
    }

    const ExpTwoSynapse::TauRiseType& ExpTwoSynapse::
    tauRise () const
    {
      return this->tauRise_.get ();
    }

    ExpTwoSynapse::TauRiseType& ExpTwoSynapse::
    tauRise ()
    {
      return this->tauRise_.get ();
    }

    void ExpTwoSynapse::
    setTauRise (const TauRiseType& x)
    {
      this->tauRise_.set (x);
    }

    void ExpTwoSynapse::
    setTauRise (::std::unique_ptr< TauRiseType > x)
    {
      this->tauRise_.set (std::move (x));
    }


    // BlockingPlasticSynapse
    // 

    const BlockingPlasticSynapse::PlasticityMechanismOptional& BlockingPlasticSynapse::
    plasticityMechanism () const
    {
      return this->plasticityMechanism_;
    }

    BlockingPlasticSynapse::PlasticityMechanismOptional& BlockingPlasticSynapse::
    plasticityMechanism ()
    {
      return this->plasticityMechanism_;
    }

    void BlockingPlasticSynapse::
    setPlasticityMechanism (const PlasticityMechanismType& x)
    {
      this->plasticityMechanism_.set (x);
    }

    void BlockingPlasticSynapse::
    setPlasticityMechanism (const PlasticityMechanismOptional& x)
    {
      this->plasticityMechanism_ = x;
    }

    void BlockingPlasticSynapse::
    setPlasticityMechanism (::std::unique_ptr< PlasticityMechanismType > x)
    {
      this->plasticityMechanism_.set (std::move (x));
    }

    const BlockingPlasticSynapse::BlockMechanismOptional& BlockingPlasticSynapse::
    blockMechanism () const
    {
      return this->blockMechanism_;
    }

    BlockingPlasticSynapse::BlockMechanismOptional& BlockingPlasticSynapse::
    blockMechanism ()
    {
      return this->blockMechanism_;
    }

    void BlockingPlasticSynapse::
    setBlockMechanism (const BlockMechanismType& x)
    {
      this->blockMechanism_.set (x);
    }

    void BlockingPlasticSynapse::
    setBlockMechanism (const BlockMechanismOptional& x)
    {
      this->blockMechanism_ = x;
    }

    void BlockingPlasticSynapse::
    setBlockMechanism (::std::unique_ptr< BlockMechanismType > x)
    {
      this->blockMechanism_.set (std::move (x));
    }


    // BlockTypes
    // 

    BlockTypes::
    BlockTypes (Value v)
    : ::xml_schema::String (_xsd_BlockTypes_literals_[v])
    {
    }

    BlockTypes::
    BlockTypes (const char* v)
    : ::xml_schema::String (v)
    {
    }

    BlockTypes::
    BlockTypes (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    BlockTypes::
    BlockTypes (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    BlockTypes::
    BlockTypes (const BlockTypes& v,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    BlockTypes& BlockTypes::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_BlockTypes_literals_[v]);

      return *this;
    }


    // BlockMechanism
    // 

    const BlockMechanism::TypeType& BlockMechanism::
    type () const
    {
      return this->type_.get ();
    }

    BlockMechanism::TypeType& BlockMechanism::
    type ()
    {
      return this->type_.get ();
    }

    void BlockMechanism::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void BlockMechanism::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const BlockMechanism::SpeciesType& BlockMechanism::
    species () const
    {
      return this->species_.get ();
    }

    BlockMechanism::SpeciesType& BlockMechanism::
    species ()
    {
      return this->species_.get ();
    }

    void BlockMechanism::
    setSpecies (const SpeciesType& x)
    {
      this->species_.set (x);
    }

    void BlockMechanism::
    setSpecies (::std::unique_ptr< SpeciesType > x)
    {
      this->species_.set (std::move (x));
    }

    const BlockMechanism::BlockConcentrationType& BlockMechanism::
    blockConcentration () const
    {
      return this->blockConcentration_.get ();
    }

    BlockMechanism::BlockConcentrationType& BlockMechanism::
    blockConcentration ()
    {
      return this->blockConcentration_.get ();
    }

    void BlockMechanism::
    setBlockConcentration (const BlockConcentrationType& x)
    {
      this->blockConcentration_.set (x);
    }

    void BlockMechanism::
    setBlockConcentration (::std::unique_ptr< BlockConcentrationType > x)
    {
      this->blockConcentration_.set (std::move (x));
    }

    const BlockMechanism::ScalingConcType& BlockMechanism::
    scalingConc () const
    {
      return this->scalingConc_.get ();
    }

    BlockMechanism::ScalingConcType& BlockMechanism::
    scalingConc ()
    {
      return this->scalingConc_.get ();
    }

    void BlockMechanism::
    setScalingConc (const ScalingConcType& x)
    {
      this->scalingConc_.set (x);
    }

    void BlockMechanism::
    setScalingConc (::std::unique_ptr< ScalingConcType > x)
    {
      this->scalingConc_.set (std::move (x));
    }

    const BlockMechanism::ScalingVoltType& BlockMechanism::
    scalingVolt () const
    {
      return this->scalingVolt_.get ();
    }

    BlockMechanism::ScalingVoltType& BlockMechanism::
    scalingVolt ()
    {
      return this->scalingVolt_.get ();
    }

    void BlockMechanism::
    setScalingVolt (const ScalingVoltType& x)
    {
      this->scalingVolt_.set (x);
    }

    void BlockMechanism::
    setScalingVolt (::std::unique_ptr< ScalingVoltType > x)
    {
      this->scalingVolt_.set (std::move (x));
    }


    // PlasticityTypes
    // 

    PlasticityTypes::
    PlasticityTypes (Value v)
    : ::xml_schema::String (_xsd_PlasticityTypes_literals_[v])
    {
    }

    PlasticityTypes::
    PlasticityTypes (const char* v)
    : ::xml_schema::String (v)
    {
    }

    PlasticityTypes::
    PlasticityTypes (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    PlasticityTypes::
    PlasticityTypes (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    PlasticityTypes::
    PlasticityTypes (const PlasticityTypes& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    PlasticityTypes& PlasticityTypes::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_PlasticityTypes_literals_[v]);

      return *this;
    }


    // PlasticityMechanism
    // 

    const PlasticityMechanism::TypeType& PlasticityMechanism::
    type () const
    {
      return this->type_.get ();
    }

    PlasticityMechanism::TypeType& PlasticityMechanism::
    type ()
    {
      return this->type_.get ();
    }

    void PlasticityMechanism::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void PlasticityMechanism::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const PlasticityMechanism::InitReleaseProbType& PlasticityMechanism::
    initReleaseProb () const
    {
      return this->initReleaseProb_.get ();
    }

    PlasticityMechanism::InitReleaseProbType& PlasticityMechanism::
    initReleaseProb ()
    {
      return this->initReleaseProb_.get ();
    }

    void PlasticityMechanism::
    setInitReleaseProb (const InitReleaseProbType& x)
    {
      this->initReleaseProb_.set (x);
    }

    void PlasticityMechanism::
    setInitReleaseProb (::std::unique_ptr< InitReleaseProbType > x)
    {
      this->initReleaseProb_.set (std::move (x));
    }

    const PlasticityMechanism::TauRecType& PlasticityMechanism::
    tauRec () const
    {
      return this->tauRec_.get ();
    }

    PlasticityMechanism::TauRecType& PlasticityMechanism::
    tauRec ()
    {
      return this->tauRec_.get ();
    }

    void PlasticityMechanism::
    setTauRec (const TauRecType& x)
    {
      this->tauRec_.set (x);
    }

    void PlasticityMechanism::
    setTauRec (::std::unique_ptr< TauRecType > x)
    {
      this->tauRec_.set (std::move (x));
    }

    const PlasticityMechanism::TauFacOptional& PlasticityMechanism::
    tauFac () const
    {
      return this->tauFac_;
    }

    PlasticityMechanism::TauFacOptional& PlasticityMechanism::
    tauFac ()
    {
      return this->tauFac_;
    }

    void PlasticityMechanism::
    setTauFac (const TauFacType& x)
    {
      this->tauFac_.set (x);
    }

    void PlasticityMechanism::
    setTauFac (const TauFacOptional& x)
    {
      this->tauFac_ = x;
    }

    void PlasticityMechanism::
    setTauFac (::std::unique_ptr< TauFacType > x)
    {
      this->tauFac_.set (std::move (x));
    }


    // BaseCell
    // 


    // IafTauCell
    // 

    const IafTauCell::LeakReversalType& IafTauCell::
    leakReversal () const
    {
      return this->leakReversal_.get ();
    }

    IafTauCell::LeakReversalType& IafTauCell::
    leakReversal ()
    {
      return this->leakReversal_.get ();
    }

    void IafTauCell::
    setLeakReversal (const LeakReversalType& x)
    {
      this->leakReversal_.set (x);
    }

    void IafTauCell::
    setLeakReversal (::std::unique_ptr< LeakReversalType > x)
    {
      this->leakReversal_.set (std::move (x));
    }

    const IafTauCell::ThreshType& IafTauCell::
    thresh () const
    {
      return this->thresh_.get ();
    }

    IafTauCell::ThreshType& IafTauCell::
    thresh ()
    {
      return this->thresh_.get ();
    }

    void IafTauCell::
    setThresh (const ThreshType& x)
    {
      this->thresh_.set (x);
    }

    void IafTauCell::
    setThresh (::std::unique_ptr< ThreshType > x)
    {
      this->thresh_.set (std::move (x));
    }

    const IafTauCell::ResetType& IafTauCell::
    reset () const
    {
      return this->reset_.get ();
    }

    IafTauCell::ResetType& IafTauCell::
    reset ()
    {
      return this->reset_.get ();
    }

    void IafTauCell::
    setReset (const ResetType& x)
    {
      this->reset_.set (x);
    }

    void IafTauCell::
    setReset (::std::unique_ptr< ResetType > x)
    {
      this->reset_.set (std::move (x));
    }

    const IafTauCell::TauType& IafTauCell::
    tau () const
    {
      return this->tau_.get ();
    }

    IafTauCell::TauType& IafTauCell::
    tau ()
    {
      return this->tau_.get ();
    }

    void IafTauCell::
    setTau (const TauType& x)
    {
      this->tau_.set (x);
    }

    void IafTauCell::
    setTau (::std::unique_ptr< TauType > x)
    {
      this->tau_.set (std::move (x));
    }


    // IafTauRefCell
    // 

    const IafTauRefCell::RefractType& IafTauRefCell::
    refract () const
    {
      return this->refract_.get ();
    }

    IafTauRefCell::RefractType& IafTauRefCell::
    refract ()
    {
      return this->refract_.get ();
    }

    void IafTauRefCell::
    setRefract (const RefractType& x)
    {
      this->refract_.set (x);
    }

    void IafTauRefCell::
    setRefract (::std::unique_ptr< RefractType > x)
    {
      this->refract_.set (std::move (x));
    }


    // IafCell
    // 

    const IafCell::LeakReversalType& IafCell::
    leakReversal () const
    {
      return this->leakReversal_.get ();
    }

    IafCell::LeakReversalType& IafCell::
    leakReversal ()
    {
      return this->leakReversal_.get ();
    }

    void IafCell::
    setLeakReversal (const LeakReversalType& x)
    {
      this->leakReversal_.set (x);
    }

    void IafCell::
    setLeakReversal (::std::unique_ptr< LeakReversalType > x)
    {
      this->leakReversal_.set (std::move (x));
    }

    const IafCell::ThreshType& IafCell::
    thresh () const
    {
      return this->thresh_.get ();
    }

    IafCell::ThreshType& IafCell::
    thresh ()
    {
      return this->thresh_.get ();
    }

    void IafCell::
    setThresh (const ThreshType& x)
    {
      this->thresh_.set (x);
    }

    void IafCell::
    setThresh (::std::unique_ptr< ThreshType > x)
    {
      this->thresh_.set (std::move (x));
    }

    const IafCell::ResetType& IafCell::
    reset () const
    {
      return this->reset_.get ();
    }

    IafCell::ResetType& IafCell::
    reset ()
    {
      return this->reset_.get ();
    }

    void IafCell::
    setReset (const ResetType& x)
    {
      this->reset_.set (x);
    }

    void IafCell::
    setReset (::std::unique_ptr< ResetType > x)
    {
      this->reset_.set (std::move (x));
    }

    const IafCell::CType& IafCell::
    c () const
    {
      return this->C_.get ();
    }

    IafCell::CType& IafCell::
    c ()
    {
      return this->C_.get ();
    }

    void IafCell::
    setC (const CType& x)
    {
      this->C_.set (x);
    }

    void IafCell::
    setC (::std::unique_ptr< CType > x)
    {
      this->C_.set (std::move (x));
    }

    const IafCell::LeakConductanceType& IafCell::
    leakConductance () const
    {
      return this->leakConductance_.get ();
    }

    IafCell::LeakConductanceType& IafCell::
    leakConductance ()
    {
      return this->leakConductance_.get ();
    }

    void IafCell::
    setLeakConductance (const LeakConductanceType& x)
    {
      this->leakConductance_.set (x);
    }

    void IafCell::
    setLeakConductance (::std::unique_ptr< LeakConductanceType > x)
    {
      this->leakConductance_.set (std::move (x));
    }


    // IafRefCell
    // 

    const IafRefCell::RefractType& IafRefCell::
    refract () const
    {
      return this->refract_.get ();
    }

    IafRefCell::RefractType& IafRefCell::
    refract ()
    {
      return this->refract_.get ();
    }

    void IafRefCell::
    setRefract (const RefractType& x)
    {
      this->refract_.set (x);
    }

    void IafRefCell::
    setRefract (::std::unique_ptr< RefractType > x)
    {
      this->refract_.set (std::move (x));
    }


    // IzhikevichCell
    // 

    const IzhikevichCell::V0Type& IzhikevichCell::
    v0 () const
    {
      return this->v0_.get ();
    }

    IzhikevichCell::V0Type& IzhikevichCell::
    v0 ()
    {
      return this->v0_.get ();
    }

    void IzhikevichCell::
    setV0 (const V0Type& x)
    {
      this->v0_.set (x);
    }

    void IzhikevichCell::
    setV0 (::std::unique_ptr< V0Type > x)
    {
      this->v0_.set (std::move (x));
    }

    const IzhikevichCell::ThreshType& IzhikevichCell::
    thresh () const
    {
      return this->thresh_.get ();
    }

    IzhikevichCell::ThreshType& IzhikevichCell::
    thresh ()
    {
      return this->thresh_.get ();
    }

    void IzhikevichCell::
    setThresh (const ThreshType& x)
    {
      this->thresh_.set (x);
    }

    void IzhikevichCell::
    setThresh (::std::unique_ptr< ThreshType > x)
    {
      this->thresh_.set (std::move (x));
    }

    const IzhikevichCell::AType& IzhikevichCell::
    a () const
    {
      return this->a_.get ();
    }

    IzhikevichCell::AType& IzhikevichCell::
    a ()
    {
      return this->a_.get ();
    }

    void IzhikevichCell::
    setA (const AType& x)
    {
      this->a_.set (x);
    }

    void IzhikevichCell::
    setA (::std::unique_ptr< AType > x)
    {
      this->a_.set (std::move (x));
    }

    const IzhikevichCell::BType& IzhikevichCell::
    b () const
    {
      return this->b_.get ();
    }

    IzhikevichCell::BType& IzhikevichCell::
    b ()
    {
      return this->b_.get ();
    }

    void IzhikevichCell::
    setB (const BType& x)
    {
      this->b_.set (x);
    }

    void IzhikevichCell::
    setB (::std::unique_ptr< BType > x)
    {
      this->b_.set (std::move (x));
    }

    const IzhikevichCell::CType& IzhikevichCell::
    c () const
    {
      return this->c_.get ();
    }

    IzhikevichCell::CType& IzhikevichCell::
    c ()
    {
      return this->c_.get ();
    }

    void IzhikevichCell::
    setC (const CType& x)
    {
      this->c_.set (x);
    }

    void IzhikevichCell::
    setC (::std::unique_ptr< CType > x)
    {
      this->c_.set (std::move (x));
    }

    const IzhikevichCell::DType& IzhikevichCell::
    d () const
    {
      return this->d_.get ();
    }

    IzhikevichCell::DType& IzhikevichCell::
    d ()
    {
      return this->d_.get ();
    }

    void IzhikevichCell::
    setD (const DType& x)
    {
      this->d_.set (x);
    }

    void IzhikevichCell::
    setD (::std::unique_ptr< DType > x)
    {
      this->d_.set (std::move (x));
    }


    // AdExIaFCell
    // 

    const AdExIaFCell::CType& AdExIaFCell::
    c () const
    {
      return this->C_.get ();
    }

    AdExIaFCell::CType& AdExIaFCell::
    c ()
    {
      return this->C_.get ();
    }

    void AdExIaFCell::
    setC (const CType& x)
    {
      this->C_.set (x);
    }

    void AdExIaFCell::
    setC (::std::unique_ptr< CType > x)
    {
      this->C_.set (std::move (x));
    }

    const AdExIaFCell::GLType& AdExIaFCell::
    gL () const
    {
      return this->gL_.get ();
    }

    AdExIaFCell::GLType& AdExIaFCell::
    gL ()
    {
      return this->gL_.get ();
    }

    void AdExIaFCell::
    setGL (const GLType& x)
    {
      this->gL_.set (x);
    }

    void AdExIaFCell::
    setGL (::std::unique_ptr< GLType > x)
    {
      this->gL_.set (std::move (x));
    }

    const AdExIaFCell::ELType& AdExIaFCell::
    eL () const
    {
      return this->EL_.get ();
    }

    AdExIaFCell::ELType& AdExIaFCell::
    eL ()
    {
      return this->EL_.get ();
    }

    void AdExIaFCell::
    setEL (const ELType& x)
    {
      this->EL_.set (x);
    }

    void AdExIaFCell::
    setEL (::std::unique_ptr< ELType > x)
    {
      this->EL_.set (std::move (x));
    }

    const AdExIaFCell::ResetType& AdExIaFCell::
    reset () const
    {
      return this->reset_.get ();
    }

    AdExIaFCell::ResetType& AdExIaFCell::
    reset ()
    {
      return this->reset_.get ();
    }

    void AdExIaFCell::
    setReset (const ResetType& x)
    {
      this->reset_.set (x);
    }

    void AdExIaFCell::
    setReset (::std::unique_ptr< ResetType > x)
    {
      this->reset_.set (std::move (x));
    }

    const AdExIaFCell::VTType& AdExIaFCell::
    vT () const
    {
      return this->VT_.get ();
    }

    AdExIaFCell::VTType& AdExIaFCell::
    vT ()
    {
      return this->VT_.get ();
    }

    void AdExIaFCell::
    setVT (const VTType& x)
    {
      this->VT_.set (x);
    }

    void AdExIaFCell::
    setVT (::std::unique_ptr< VTType > x)
    {
      this->VT_.set (std::move (x));
    }

    const AdExIaFCell::ThreshType& AdExIaFCell::
    thresh () const
    {
      return this->thresh_.get ();
    }

    AdExIaFCell::ThreshType& AdExIaFCell::
    thresh ()
    {
      return this->thresh_.get ();
    }

    void AdExIaFCell::
    setThresh (const ThreshType& x)
    {
      this->thresh_.set (x);
    }

    void AdExIaFCell::
    setThresh (::std::unique_ptr< ThreshType > x)
    {
      this->thresh_.set (std::move (x));
    }

    const AdExIaFCell::DelTType& AdExIaFCell::
    delT () const
    {
      return this->delT_.get ();
    }

    AdExIaFCell::DelTType& AdExIaFCell::
    delT ()
    {
      return this->delT_.get ();
    }

    void AdExIaFCell::
    setDelT (const DelTType& x)
    {
      this->delT_.set (x);
    }

    void AdExIaFCell::
    setDelT (::std::unique_ptr< DelTType > x)
    {
      this->delT_.set (std::move (x));
    }

    const AdExIaFCell::TauwType& AdExIaFCell::
    tauw () const
    {
      return this->tauw_.get ();
    }

    AdExIaFCell::TauwType& AdExIaFCell::
    tauw ()
    {
      return this->tauw_.get ();
    }

    void AdExIaFCell::
    setTauw (const TauwType& x)
    {
      this->tauw_.set (x);
    }

    void AdExIaFCell::
    setTauw (::std::unique_ptr< TauwType > x)
    {
      this->tauw_.set (std::move (x));
    }

    const AdExIaFCell::RefractType& AdExIaFCell::
    refract () const
    {
      return this->refract_.get ();
    }

    AdExIaFCell::RefractType& AdExIaFCell::
    refract ()
    {
      return this->refract_.get ();
    }

    void AdExIaFCell::
    setRefract (const RefractType& x)
    {
      this->refract_.set (x);
    }

    void AdExIaFCell::
    setRefract (::std::unique_ptr< RefractType > x)
    {
      this->refract_.set (std::move (x));
    }

    const AdExIaFCell::AType& AdExIaFCell::
    a () const
    {
      return this->a_.get ();
    }

    AdExIaFCell::AType& AdExIaFCell::
    a ()
    {
      return this->a_.get ();
    }

    void AdExIaFCell::
    setA (const AType& x)
    {
      this->a_.set (x);
    }

    void AdExIaFCell::
    setA (::std::unique_ptr< AType > x)
    {
      this->a_.set (std::move (x));
    }

    const AdExIaFCell::BType& AdExIaFCell::
    b () const
    {
      return this->b_.get ();
    }

    AdExIaFCell::BType& AdExIaFCell::
    b ()
    {
      return this->b_.get ();
    }

    void AdExIaFCell::
    setB (const BType& x)
    {
      this->b_.set (x);
    }

    void AdExIaFCell::
    setB (::std::unique_ptr< BType > x)
    {
      this->b_.set (std::move (x));
    }


    // FitzHughNagumoCell
    // 

    const FitzHughNagumoCell::IType& FitzHughNagumoCell::
    i () const
    {
      return this->I_.get ();
    }

    FitzHughNagumoCell::IType& FitzHughNagumoCell::
    i ()
    {
      return this->I_.get ();
    }

    void FitzHughNagumoCell::
    setI (const IType& x)
    {
      this->I_.set (x);
    }

    void FitzHughNagumoCell::
    setI (::std::unique_ptr< IType > x)
    {
      this->I_.set (std::move (x));
    }


    // Cell
    // 

    const Cell::MorphologyOptional& Cell::
    morphology () const
    {
      return this->morphology_;
    }

    Cell::MorphologyOptional& Cell::
    morphology ()
    {
      return this->morphology_;
    }

    void Cell::
    setMorphology (const MorphologyType& x)
    {
      this->morphology_.set (x);
    }

    void Cell::
    setMorphology (const MorphologyOptional& x)
    {
      this->morphology_ = x;
    }

    void Cell::
    setMorphology (::std::unique_ptr< MorphologyType > x)
    {
      this->morphology_.set (std::move (x));
    }

    const Cell::BiophysicalPropertiesOptional& Cell::
    biophysicalProperties () const
    {
      return this->biophysicalProperties_;
    }

    Cell::BiophysicalPropertiesOptional& Cell::
    biophysicalProperties ()
    {
      return this->biophysicalProperties_;
    }

    void Cell::
    setBiophysicalProperties (const BiophysicalPropertiesType& x)
    {
      this->biophysicalProperties_.set (x);
    }

    void Cell::
    setBiophysicalProperties (const BiophysicalPropertiesOptional& x)
    {
      this->biophysicalProperties_ = x;
    }

    void Cell::
    setBiophysicalProperties (::std::unique_ptr< BiophysicalPropertiesType > x)
    {
      this->biophysicalProperties_.set (std::move (x));
    }

    const Cell::Morphology1Type& Cell::
    morphology1 () const
    {
      return this->morphology1_.get ();
    }

    Cell::Morphology1Type& Cell::
    morphology1 ()
    {
      return this->morphology1_.get ();
    }

    void Cell::
    setMorphology1 (const Morphology1Type& x)
    {
      this->morphology1_.set (x);
    }

    void Cell::
    setMorphology1 (::std::unique_ptr< Morphology1Type > x)
    {
      this->morphology1_.set (std::move (x));
    }

    const Cell::Morphology1Type& Cell::
    morphology1DefaultValue ()
    {
      return morphology1_default_value_;
    }

    const Cell::BiophysicalProperties1Type& Cell::
    biophysicalProperties1 () const
    {
      return this->biophysicalProperties1_.get ();
    }

    Cell::BiophysicalProperties1Type& Cell::
    biophysicalProperties1 ()
    {
      return this->biophysicalProperties1_.get ();
    }

    void Cell::
    setBiophysicalProperties1 (const BiophysicalProperties1Type& x)
    {
      this->biophysicalProperties1_.set (x);
    }

    void Cell::
    setBiophysicalProperties1 (::std::unique_ptr< BiophysicalProperties1Type > x)
    {
      this->biophysicalProperties1_.set (std::move (x));
    }

    const Cell::BiophysicalProperties1Type& Cell::
    biophysicalProperties1DefaultValue ()
    {
      return biophysicalProperties1_default_value_;
    }


    // Morphology
    // 

    const Morphology::SegmentSequence& Morphology::
    segments () const
    {
      return this->segment_;
    }

    Morphology::SegmentSequence& Morphology::
    segments ()
    {
      return this->segment_;
    }

    void Morphology::
    setSegments (const SegmentSequence& s)
    {
      this->segment_ = s;
    }

    const Morphology::SegmentGroupSequence& Morphology::
    segmentGroups () const
    {
      return this->segmentGroup_;
    }

    Morphology::SegmentGroupSequence& Morphology::
    segmentGroups ()
    {
      return this->segmentGroup_;
    }

    void Morphology::
    setSegmentGroups (const SegmentGroupSequence& s)
    {
      this->segmentGroup_ = s;
    }


    // Segment
    // 

    const Segment::ParentOptional& Segment::
    parent () const
    {
      return this->parent_;
    }

    Segment::ParentOptional& Segment::
    parent ()
    {
      return this->parent_;
    }

    void Segment::
    setParent (const ParentType& x)
    {
      this->parent_.set (x);
    }

    void Segment::
    setParent (const ParentOptional& x)
    {
      this->parent_ = x;
    }

    void Segment::
    setParent (::std::unique_ptr< ParentType > x)
    {
      this->parent_.set (std::move (x));
    }

    const Segment::ProximalOptional& Segment::
    proximal () const
    {
      return this->proximal_;
    }

    Segment::ProximalOptional& Segment::
    proximal ()
    {
      return this->proximal_;
    }

    void Segment::
    setProximal (const ProximalType& x)
    {
      this->proximal_.set (x);
    }

    void Segment::
    setProximal (const ProximalOptional& x)
    {
      this->proximal_ = x;
    }

    void Segment::
    setProximal (::std::unique_ptr< ProximalType > x)
    {
      this->proximal_.set (std::move (x));
    }

    const Segment::DistalType& Segment::
    distal () const
    {
      return this->distal_.get ();
    }

    Segment::DistalType& Segment::
    distal ()
    {
      return this->distal_.get ();
    }

    void Segment::
    setDistal (const DistalType& x)
    {
      this->distal_.set (x);
    }

    void Segment::
    setDistal (::std::unique_ptr< DistalType > x)
    {
      this->distal_.set (std::move (x));
    }

    const Segment::IdType& Segment::
    id () const
    {
      return this->id_.get ();
    }

    Segment::IdType& Segment::
    id ()
    {
      return this->id_.get ();
    }

    void Segment::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Segment::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Segment::NameOptional& Segment::
    name () const
    {
      return this->name_;
    }

    Segment::NameOptional& Segment::
    name ()
    {
      return this->name_;
    }

    void Segment::
    setName (const NameType& x)
    {
      this->name_.set (x);
    }

    void Segment::
    setName (const NameOptional& x)
    {
      this->name_ = x;
    }

    void Segment::
    setName (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }


    // SegmentParent
    // 

    const SegmentParent::SegmentType& SegmentParent::
    segment () const
    {
      return this->segment_.get ();
    }

    SegmentParent::SegmentType& SegmentParent::
    segment ()
    {
      return this->segment_.get ();
    }

    void SegmentParent::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void SegmentParent::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }

    const SegmentParent::FractionAlongType& SegmentParent::
    fractionAlong () const
    {
      return this->fractionAlong_.get ();
    }

    SegmentParent::FractionAlongType& SegmentParent::
    fractionAlong ()
    {
      return this->fractionAlong_.get ();
    }

    void SegmentParent::
    setFractionAlong (const FractionAlongType& x)
    {
      this->fractionAlong_.set (x);
    }

    void SegmentParent::
    setFractionAlong (::std::unique_ptr< FractionAlongType > x)
    {
      this->fractionAlong_.set (std::move (x));
    }

    SegmentParent::FractionAlongType SegmentParent::
    fractionAlongDefaultValue ()
    {
      return FractionAlongType (1.0);
    }


    // Point3DWithDiam
    // 

    const Point3DWithDiam::XType& Point3DWithDiam::
    x () const
    {
      return this->x_.get ();
    }

    Point3DWithDiam::XType& Point3DWithDiam::
    x ()
    {
      return this->x_.get ();
    }

    void Point3DWithDiam::
    setX (const XType& x)
    {
      this->x_.set (x);
    }

    const Point3DWithDiam::YType& Point3DWithDiam::
    y () const
    {
      return this->y_.get ();
    }

    Point3DWithDiam::YType& Point3DWithDiam::
    y ()
    {
      return this->y_.get ();
    }

    void Point3DWithDiam::
    setY (const YType& x)
    {
      this->y_.set (x);
    }

    const Point3DWithDiam::ZType& Point3DWithDiam::
    z () const
    {
      return this->z_.get ();
    }

    Point3DWithDiam::ZType& Point3DWithDiam::
    z ()
    {
      return this->z_.get ();
    }

    void Point3DWithDiam::
    setZ (const ZType& x)
    {
      this->z_.set (x);
    }

    const Point3DWithDiam::DiameterType& Point3DWithDiam::
    diameter () const
    {
      return this->diameter_.get ();
    }

    Point3DWithDiam::DiameterType& Point3DWithDiam::
    diameter ()
    {
      return this->diameter_.get ();
    }

    void Point3DWithDiam::
    setDiameter (const DiameterType& x)
    {
      this->diameter_.set (x);
    }


    // SegmentGroup
    // 

    const SegmentGroup::NotesOptional& SegmentGroup::
    notes () const
    {
      return this->notes_;
    }

    SegmentGroup::NotesOptional& SegmentGroup::
    notes ()
    {
      return this->notes_;
    }

    void SegmentGroup::
    setNotes (const NotesType& x)
    {
      this->notes_.set (x);
    }

    void SegmentGroup::
    setNotes (const NotesOptional& x)
    {
      this->notes_ = x;
    }

    void SegmentGroup::
    setNotes (::std::unique_ptr< NotesType > x)
    {
      this->notes_.set (std::move (x));
    }

    const SegmentGroup::AnnotationOptional& SegmentGroup::
    annotation () const
    {
      return this->annotation_;
    }

    SegmentGroup::AnnotationOptional& SegmentGroup::
    annotation ()
    {
      return this->annotation_;
    }

    void SegmentGroup::
    setAnnotation (const AnnotationType& x)
    {
      this->annotation_.set (x);
    }

    void SegmentGroup::
    setAnnotation (const AnnotationOptional& x)
    {
      this->annotation_ = x;
    }

    void SegmentGroup::
    setAnnotation (::std::unique_ptr< AnnotationType > x)
    {
      this->annotation_.set (std::move (x));
    }

    const SegmentGroup::MemberSequence& SegmentGroup::
    members () const
    {
      return this->member_;
    }

    SegmentGroup::MemberSequence& SegmentGroup::
    members ()
    {
      return this->member_;
    }

    void SegmentGroup::
    setMembers (const MemberSequence& s)
    {
      this->member_ = s;
    }

    const SegmentGroup::IncludeSequence& SegmentGroup::
    includes () const
    {
      return this->include_;
    }

    SegmentGroup::IncludeSequence& SegmentGroup::
    includes ()
    {
      return this->include_;
    }

    void SegmentGroup::
    setIncludes (const IncludeSequence& s)
    {
      this->include_ = s;
    }

    const SegmentGroup::PathSequence& SegmentGroup::
    paths () const
    {
      return this->path_;
    }

    SegmentGroup::PathSequence& SegmentGroup::
    paths ()
    {
      return this->path_;
    }

    void SegmentGroup::
    setPaths (const PathSequence& s)
    {
      this->path_ = s;
    }

    const SegmentGroup::SubTreeSequence& SegmentGroup::
    subTrees () const
    {
      return this->subTree_;
    }

    SegmentGroup::SubTreeSequence& SegmentGroup::
    subTrees ()
    {
      return this->subTree_;
    }

    void SegmentGroup::
    setSubTrees (const SubTreeSequence& s)
    {
      this->subTree_ = s;
    }

    const SegmentGroup::InhomogeneousParameterSequence& SegmentGroup::
    inhomogeneousParameters () const
    {
      return this->inhomogeneousParameter_;
    }

    SegmentGroup::InhomogeneousParameterSequence& SegmentGroup::
    inhomogeneousParameters ()
    {
      return this->inhomogeneousParameter_;
    }

    void SegmentGroup::
    setInhomogeneousParameters (const InhomogeneousParameterSequence& s)
    {
      this->inhomogeneousParameter_ = s;
    }


    // InhomogeneousParameter
    // 

    const InhomogeneousParameter::ProximalOptional& InhomogeneousParameter::
    proximal () const
    {
      return this->proximal_;
    }

    InhomogeneousParameter::ProximalOptional& InhomogeneousParameter::
    proximal ()
    {
      return this->proximal_;
    }

    void InhomogeneousParameter::
    setProximal (const ProximalType& x)
    {
      this->proximal_.set (x);
    }

    void InhomogeneousParameter::
    setProximal (const ProximalOptional& x)
    {
      this->proximal_ = x;
    }

    void InhomogeneousParameter::
    setProximal (::std::unique_ptr< ProximalType > x)
    {
      this->proximal_.set (std::move (x));
    }

    const InhomogeneousParameter::DistalOptional& InhomogeneousParameter::
    distal () const
    {
      return this->distal_;
    }

    InhomogeneousParameter::DistalOptional& InhomogeneousParameter::
    distal ()
    {
      return this->distal_;
    }

    void InhomogeneousParameter::
    setDistal (const DistalType& x)
    {
      this->distal_.set (x);
    }

    void InhomogeneousParameter::
    setDistal (const DistalOptional& x)
    {
      this->distal_ = x;
    }

    void InhomogeneousParameter::
    setDistal (::std::unique_ptr< DistalType > x)
    {
      this->distal_.set (std::move (x));
    }

    const InhomogeneousParameter::VariableType& InhomogeneousParameter::
    variable () const
    {
      return this->variable_.get ();
    }

    InhomogeneousParameter::VariableType& InhomogeneousParameter::
    variable ()
    {
      return this->variable_.get ();
    }

    void InhomogeneousParameter::
    setVariable (const VariableType& x)
    {
      this->variable_.set (x);
    }

    void InhomogeneousParameter::
    setVariable (::std::unique_ptr< VariableType > x)
    {
      this->variable_.set (std::move (x));
    }

    const InhomogeneousParameter::MetricType& InhomogeneousParameter::
    metric () const
    {
      return this->metric_.get ();
    }

    InhomogeneousParameter::MetricType& InhomogeneousParameter::
    metric ()
    {
      return this->metric_.get ();
    }

    void InhomogeneousParameter::
    setMetric (const MetricType& x)
    {
      this->metric_.set (x);
    }

    void InhomogeneousParameter::
    setMetric (::std::unique_ptr< MetricType > x)
    {
      this->metric_.set (std::move (x));
    }


    // Metric
    // 

    Metric::
    Metric (Value v)
    : ::xml_schema::String (_xsd_Metric_literals_[v])
    {
    }

    Metric::
    Metric (const char* v)
    : ::xml_schema::String (v)
    {
    }

    Metric::
    Metric (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    Metric::
    Metric (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    Metric::
    Metric (const Metric& v,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    Metric& Metric::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_Metric_literals_[v]);

      return *this;
    }


    // ProximalDetails
    // 

    const ProximalDetails::TranslationStartType& ProximalDetails::
    translationStart () const
    {
      return this->translationStart_.get ();
    }

    ProximalDetails::TranslationStartType& ProximalDetails::
    translationStart ()
    {
      return this->translationStart_.get ();
    }

    void ProximalDetails::
    setTranslationStart (const TranslationStartType& x)
    {
      this->translationStart_.set (x);
    }


    // DistalDetails
    // 

    const DistalDetails::NormalizationEndType& DistalDetails::
    normalizationEnd () const
    {
      return this->normalizationEnd_.get ();
    }

    DistalDetails::NormalizationEndType& DistalDetails::
    normalizationEnd ()
    {
      return this->normalizationEnd_.get ();
    }

    void DistalDetails::
    setNormalizationEnd (const NormalizationEndType& x)
    {
      this->normalizationEnd_.set (x);
    }


    // Member
    // 

    const Member::SegmentType& Member::
    segment () const
    {
      return this->segment_.get ();
    }

    Member::SegmentType& Member::
    segment ()
    {
      return this->segment_.get ();
    }

    void Member::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void Member::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }


    // Include
    // 

    const Include::SegmentGroupType& Include::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    Include::SegmentGroupType& Include::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void Include::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void Include::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }


    // Path
    // 

    const Path::FromOptional& Path::
    from () const
    {
      return this->from_;
    }

    Path::FromOptional& Path::
    from ()
    {
      return this->from_;
    }

    void Path::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void Path::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void Path::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const Path::ToOptional& Path::
    to () const
    {
      return this->to_;
    }

    Path::ToOptional& Path::
    to ()
    {
      return this->to_;
    }

    void Path::
    setTo (const ToType& x)
    {
      this->to_.set (x);
    }

    void Path::
    setTo (const ToOptional& x)
    {
      this->to_ = x;
    }

    void Path::
    setTo (::std::unique_ptr< ToType > x)
    {
      this->to_.set (std::move (x));
    }


    // SubTree
    // 

    const SubTree::FromOptional& SubTree::
    from () const
    {
      return this->from_;
    }

    SubTree::FromOptional& SubTree::
    from ()
    {
      return this->from_;
    }

    void SubTree::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void SubTree::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void SubTree::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const SubTree::ToOptional& SubTree::
    to () const
    {
      return this->to_;
    }

    SubTree::ToOptional& SubTree::
    to ()
    {
      return this->to_;
    }

    void SubTree::
    setTo (const ToType& x)
    {
      this->to_.set (x);
    }

    void SubTree::
    setTo (const ToOptional& x)
    {
      this->to_ = x;
    }

    void SubTree::
    setTo (::std::unique_ptr< ToType > x)
    {
      this->to_.set (std::move (x));
    }


    // SegmentEndPoint
    // 

    const SegmentEndPoint::SegmentType& SegmentEndPoint::
    segment () const
    {
      return this->segment_.get ();
    }

    SegmentEndPoint::SegmentType& SegmentEndPoint::
    segment ()
    {
      return this->segment_.get ();
    }

    void SegmentEndPoint::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void SegmentEndPoint::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }


    // BiophysicalProperties
    // 

    const BiophysicalProperties::MembranePropertiesType& BiophysicalProperties::
    membraneProperties () const
    {
      return this->membraneProperties_.get ();
    }

    BiophysicalProperties::MembranePropertiesType& BiophysicalProperties::
    membraneProperties ()
    {
      return this->membraneProperties_.get ();
    }

    void BiophysicalProperties::
    setMembraneProperties (const MembranePropertiesType& x)
    {
      this->membraneProperties_.set (x);
    }

    void BiophysicalProperties::
    setMembraneProperties (::std::unique_ptr< MembranePropertiesType > x)
    {
      this->membraneProperties_.set (std::move (x));
    }

    const BiophysicalProperties::IntracellularPropertiesOptional& BiophysicalProperties::
    intracellularProperties () const
    {
      return this->intracellularProperties_;
    }

    BiophysicalProperties::IntracellularPropertiesOptional& BiophysicalProperties::
    intracellularProperties ()
    {
      return this->intracellularProperties_;
    }

    void BiophysicalProperties::
    setIntracellularProperties (const IntracellularPropertiesType& x)
    {
      this->intracellularProperties_.set (x);
    }

    void BiophysicalProperties::
    setIntracellularProperties (const IntracellularPropertiesOptional& x)
    {
      this->intracellularProperties_ = x;
    }

    void BiophysicalProperties::
    setIntracellularProperties (::std::unique_ptr< IntracellularPropertiesType > x)
    {
      this->intracellularProperties_.set (std::move (x));
    }

    const BiophysicalProperties::ExtracellularPropertiesOptional& BiophysicalProperties::
    extracellularProperties () const
    {
      return this->extracellularProperties_;
    }

    BiophysicalProperties::ExtracellularPropertiesOptional& BiophysicalProperties::
    extracellularProperties ()
    {
      return this->extracellularProperties_;
    }

    void BiophysicalProperties::
    setExtracellularProperties (const ExtracellularPropertiesType& x)
    {
      this->extracellularProperties_.set (x);
    }

    void BiophysicalProperties::
    setExtracellularProperties (const ExtracellularPropertiesOptional& x)
    {
      this->extracellularProperties_ = x;
    }

    void BiophysicalProperties::
    setExtracellularProperties (::std::unique_ptr< ExtracellularPropertiesType > x)
    {
      this->extracellularProperties_.set (std::move (x));
    }


    // MembraneProperties
    // 

    const MembraneProperties::ChannelPopulationSequence& MembraneProperties::
    channelPopulations () const
    {
      return this->channelPopulation_;
    }

    MembraneProperties::ChannelPopulationSequence& MembraneProperties::
    channelPopulations ()
    {
      return this->channelPopulation_;
    }

    void MembraneProperties::
    setChannelPopulations (const ChannelPopulationSequence& s)
    {
      this->channelPopulation_ = s;
    }

    const MembraneProperties::ChannelDensitySequence& MembraneProperties::
    channelDensitys () const
    {
      return this->channelDensity_;
    }

    MembraneProperties::ChannelDensitySequence& MembraneProperties::
    channelDensitys ()
    {
      return this->channelDensity_;
    }

    void MembraneProperties::
    setChannelDensitys (const ChannelDensitySequence& s)
    {
      this->channelDensity_ = s;
    }

    const MembraneProperties::ChannelDensityNernstSequence& MembraneProperties::
    channelDensityNernsts () const
    {
      return this->channelDensityNernst_;
    }

    MembraneProperties::ChannelDensityNernstSequence& MembraneProperties::
    channelDensityNernsts ()
    {
      return this->channelDensityNernst_;
    }

    void MembraneProperties::
    setChannelDensityNernsts (const ChannelDensityNernstSequence& s)
    {
      this->channelDensityNernst_ = s;
    }

    const MembraneProperties::ChannelDensityGHKSequence& MembraneProperties::
    channelDensityGHKs () const
    {
      return this->channelDensityGHK_;
    }

    MembraneProperties::ChannelDensityGHKSequence& MembraneProperties::
    channelDensityGHKs ()
    {
      return this->channelDensityGHK_;
    }

    void MembraneProperties::
    setChannelDensityGHKs (const ChannelDensityGHKSequence& s)
    {
      this->channelDensityGHK_ = s;
    }

    const MembraneProperties::ChannelDensityNonUniformSequence& MembraneProperties::
    channelDensityNonUniforms () const
    {
      return this->channelDensityNonUniform_;
    }

    MembraneProperties::ChannelDensityNonUniformSequence& MembraneProperties::
    channelDensityNonUniforms ()
    {
      return this->channelDensityNonUniform_;
    }

    void MembraneProperties::
    setChannelDensityNonUniforms (const ChannelDensityNonUniformSequence& s)
    {
      this->channelDensityNonUniform_ = s;
    }

    const MembraneProperties::ChannelDensityNonUniformNernstSequence& MembraneProperties::
    channelDensityNonUniformNernsts () const
    {
      return this->channelDensityNonUniformNernst_;
    }

    MembraneProperties::ChannelDensityNonUniformNernstSequence& MembraneProperties::
    channelDensityNonUniformNernsts ()
    {
      return this->channelDensityNonUniformNernst_;
    }

    void MembraneProperties::
    setChannelDensityNonUniformNernsts (const ChannelDensityNonUniformNernstSequence& s)
    {
      this->channelDensityNonUniformNernst_ = s;
    }

    const MembraneProperties::SpikeThreshSequence& MembraneProperties::
    spikeThreshs () const
    {
      return this->spikeThresh_;
    }

    MembraneProperties::SpikeThreshSequence& MembraneProperties::
    spikeThreshs ()
    {
      return this->spikeThresh_;
    }

    void MembraneProperties::
    setSpikeThreshs (const SpikeThreshSequence& s)
    {
      this->spikeThresh_ = s;
    }

    const MembraneProperties::SpecificCapacitanceSequence& MembraneProperties::
    specificCapacitances () const
    {
      return this->specificCapacitance_;
    }

    MembraneProperties::SpecificCapacitanceSequence& MembraneProperties::
    specificCapacitances ()
    {
      return this->specificCapacitance_;
    }

    void MembraneProperties::
    setSpecificCapacitances (const SpecificCapacitanceSequence& s)
    {
      this->specificCapacitance_ = s;
    }

    const MembraneProperties::InitMembPotentialSequence& MembraneProperties::
    initMembPotentials () const
    {
      return this->initMembPotential_;
    }

    MembraneProperties::InitMembPotentialSequence& MembraneProperties::
    initMembPotentials ()
    {
      return this->initMembPotential_;
    }

    void MembraneProperties::
    setInitMembPotentials (const InitMembPotentialSequence& s)
    {
      this->initMembPotential_ = s;
    }


    // ValueAcrossSegOrSegGroup
    // 

    const ValueAcrossSegOrSegGroup::ValueOptional& ValueAcrossSegOrSegGroup::
    value () const
    {
      return this->value_;
    }

    ValueAcrossSegOrSegGroup::ValueOptional& ValueAcrossSegOrSegGroup::
    value ()
    {
      return this->value_;
    }

    void ValueAcrossSegOrSegGroup::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }

    void ValueAcrossSegOrSegGroup::
    setValue (const ValueOptional& x)
    {
      this->value_ = x;
    }

    void ValueAcrossSegOrSegGroup::
    setValue (::std::unique_ptr< ValueType > x)
    {
      this->value_.set (std::move (x));
    }

    const ValueAcrossSegOrSegGroup::SegmentGroupType& ValueAcrossSegOrSegGroup::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    ValueAcrossSegOrSegGroup::SegmentGroupType& ValueAcrossSegOrSegGroup::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void ValueAcrossSegOrSegGroup::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void ValueAcrossSegOrSegGroup::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }

    const ValueAcrossSegOrSegGroup::SegmentGroupType& ValueAcrossSegOrSegGroup::
    segmentGroupDefaultValue ()
    {
      return segmentGroup_default_value_;
    }

    const ValueAcrossSegOrSegGroup::SegmentOptional& ValueAcrossSegOrSegGroup::
    segment () const
    {
      return this->segment_;
    }

    ValueAcrossSegOrSegGroup::SegmentOptional& ValueAcrossSegOrSegGroup::
    segment ()
    {
      return this->segment_;
    }

    void ValueAcrossSegOrSegGroup::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void ValueAcrossSegOrSegGroup::
    setSegment (const SegmentOptional& x)
    {
      this->segment_ = x;
    }

    void ValueAcrossSegOrSegGroup::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }


    // SpikeThresh
    // 


    // SpecificCapacitance
    // 


    // InitMembPotential
    // 


    // Resistivity
    // 


    // ChannelPopulation
    // 

    const ChannelPopulation::VariableParameterSequence& ChannelPopulation::
    variableParameters () const
    {
      return this->variableParameter_;
    }

    ChannelPopulation::VariableParameterSequence& ChannelPopulation::
    variableParameters ()
    {
      return this->variableParameter_;
    }

    void ChannelPopulation::
    setVariableParameters (const VariableParameterSequence& s)
    {
      this->variableParameter_ = s;
    }

    const ChannelPopulation::IonChannelType& ChannelPopulation::
    ionChannel () const
    {
      return this->ionChannel_.get ();
    }

    ChannelPopulation::IonChannelType& ChannelPopulation::
    ionChannel ()
    {
      return this->ionChannel_.get ();
    }

    void ChannelPopulation::
    setIonChannel (const IonChannelType& x)
    {
      this->ionChannel_.set (x);
    }

    void ChannelPopulation::
    setIonChannel (::std::unique_ptr< IonChannelType > x)
    {
      this->ionChannel_.set (std::move (x));
    }

    const ChannelPopulation::NumberType& ChannelPopulation::
    number () const
    {
      return this->number_.get ();
    }

    ChannelPopulation::NumberType& ChannelPopulation::
    number ()
    {
      return this->number_.get ();
    }

    void ChannelPopulation::
    setNumber (const NumberType& x)
    {
      this->number_.set (x);
    }

    const ChannelPopulation::ErevType& ChannelPopulation::
    erev () const
    {
      return this->erev_.get ();
    }

    ChannelPopulation::ErevType& ChannelPopulation::
    erev ()
    {
      return this->erev_.get ();
    }

    void ChannelPopulation::
    setErev (const ErevType& x)
    {
      this->erev_.set (x);
    }

    void ChannelPopulation::
    setErev (::std::unique_ptr< ErevType > x)
    {
      this->erev_.set (std::move (x));
    }

    const ChannelPopulation::SegmentGroupType& ChannelPopulation::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    ChannelPopulation::SegmentGroupType& ChannelPopulation::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void ChannelPopulation::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void ChannelPopulation::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }

    const ChannelPopulation::SegmentGroupType& ChannelPopulation::
    segmentGroupDefaultValue ()
    {
      return segmentGroup_default_value_;
    }

    const ChannelPopulation::SegmentOptional& ChannelPopulation::
    segment () const
    {
      return this->segment_;
    }

    ChannelPopulation::SegmentOptional& ChannelPopulation::
    segment ()
    {
      return this->segment_;
    }

    void ChannelPopulation::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void ChannelPopulation::
    setSegment (const SegmentOptional& x)
    {
      this->segment_ = x;
    }

    void ChannelPopulation::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }

    const ChannelPopulation::IonOptional& ChannelPopulation::
    ion () const
    {
      return this->ion_;
    }

    ChannelPopulation::IonOptional& ChannelPopulation::
    ion ()
    {
      return this->ion_;
    }

    void ChannelPopulation::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void ChannelPopulation::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void ChannelPopulation::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }


    // ChannelDensityNonUniform
    // 

    const ChannelDensityNonUniform::VariableParameterSequence& ChannelDensityNonUniform::
    variableParameters () const
    {
      return this->variableParameter_;
    }

    ChannelDensityNonUniform::VariableParameterSequence& ChannelDensityNonUniform::
    variableParameters ()
    {
      return this->variableParameter_;
    }

    void ChannelDensityNonUniform::
    setVariableParameters (const VariableParameterSequence& s)
    {
      this->variableParameter_ = s;
    }

    const ChannelDensityNonUniform::IonChannelType& ChannelDensityNonUniform::
    ionChannel () const
    {
      return this->ionChannel_.get ();
    }

    ChannelDensityNonUniform::IonChannelType& ChannelDensityNonUniform::
    ionChannel ()
    {
      return this->ionChannel_.get ();
    }

    void ChannelDensityNonUniform::
    setIonChannel (const IonChannelType& x)
    {
      this->ionChannel_.set (x);
    }

    void ChannelDensityNonUniform::
    setIonChannel (::std::unique_ptr< IonChannelType > x)
    {
      this->ionChannel_.set (std::move (x));
    }

    const ChannelDensityNonUniform::ErevType& ChannelDensityNonUniform::
    erev () const
    {
      return this->erev_.get ();
    }

    ChannelDensityNonUniform::ErevType& ChannelDensityNonUniform::
    erev ()
    {
      return this->erev_.get ();
    }

    void ChannelDensityNonUniform::
    setErev (const ErevType& x)
    {
      this->erev_.set (x);
    }

    void ChannelDensityNonUniform::
    setErev (::std::unique_ptr< ErevType > x)
    {
      this->erev_.set (std::move (x));
    }

    const ChannelDensityNonUniform::IonOptional& ChannelDensityNonUniform::
    ion () const
    {
      return this->ion_;
    }

    ChannelDensityNonUniform::IonOptional& ChannelDensityNonUniform::
    ion ()
    {
      return this->ion_;
    }

    void ChannelDensityNonUniform::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void ChannelDensityNonUniform::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void ChannelDensityNonUniform::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }


    // ChannelDensityNonUniformNernst
    // 

    const ChannelDensityNonUniformNernst::VariableParameterSequence& ChannelDensityNonUniformNernst::
    variableParameters () const
    {
      return this->variableParameter_;
    }

    ChannelDensityNonUniformNernst::VariableParameterSequence& ChannelDensityNonUniformNernst::
    variableParameters ()
    {
      return this->variableParameter_;
    }

    void ChannelDensityNonUniformNernst::
    setVariableParameters (const VariableParameterSequence& s)
    {
      this->variableParameter_ = s;
    }

    const ChannelDensityNonUniformNernst::IonChannelType& ChannelDensityNonUniformNernst::
    ionChannel () const
    {
      return this->ionChannel_.get ();
    }

    ChannelDensityNonUniformNernst::IonChannelType& ChannelDensityNonUniformNernst::
    ionChannel ()
    {
      return this->ionChannel_.get ();
    }

    void ChannelDensityNonUniformNernst::
    setIonChannel (const IonChannelType& x)
    {
      this->ionChannel_.set (x);
    }

    void ChannelDensityNonUniformNernst::
    setIonChannel (::std::unique_ptr< IonChannelType > x)
    {
      this->ionChannel_.set (std::move (x));
    }

    const ChannelDensityNonUniformNernst::IonOptional& ChannelDensityNonUniformNernst::
    ion () const
    {
      return this->ion_;
    }

    ChannelDensityNonUniformNernst::IonOptional& ChannelDensityNonUniformNernst::
    ion ()
    {
      return this->ion_;
    }

    void ChannelDensityNonUniformNernst::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void ChannelDensityNonUniformNernst::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void ChannelDensityNonUniformNernst::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }


    // ChannelDensity
    // 

    const ChannelDensity::VariableParameterSequence& ChannelDensity::
    variableParameters () const
    {
      return this->variableParameter_;
    }

    ChannelDensity::VariableParameterSequence& ChannelDensity::
    variableParameters ()
    {
      return this->variableParameter_;
    }

    void ChannelDensity::
    setVariableParameters (const VariableParameterSequence& s)
    {
      this->variableParameter_ = s;
    }

    const ChannelDensity::IonChannelType& ChannelDensity::
    ionChannel () const
    {
      return this->ionChannel_.get ();
    }

    ChannelDensity::IonChannelType& ChannelDensity::
    ionChannel ()
    {
      return this->ionChannel_.get ();
    }

    void ChannelDensity::
    setIonChannel (const IonChannelType& x)
    {
      this->ionChannel_.set (x);
    }

    void ChannelDensity::
    setIonChannel (::std::unique_ptr< IonChannelType > x)
    {
      this->ionChannel_.set (std::move (x));
    }

    const ChannelDensity::CondDensityOptional& ChannelDensity::
    condDensity () const
    {
      return this->condDensity_;
    }

    ChannelDensity::CondDensityOptional& ChannelDensity::
    condDensity ()
    {
      return this->condDensity_;
    }

    void ChannelDensity::
    setCondDensity (const CondDensityType& x)
    {
      this->condDensity_.set (x);
    }

    void ChannelDensity::
    setCondDensity (const CondDensityOptional& x)
    {
      this->condDensity_ = x;
    }

    void ChannelDensity::
    setCondDensity (::std::unique_ptr< CondDensityType > x)
    {
      this->condDensity_.set (std::move (x));
    }

    const ChannelDensity::ErevType& ChannelDensity::
    erev () const
    {
      return this->erev_.get ();
    }

    ChannelDensity::ErevType& ChannelDensity::
    erev ()
    {
      return this->erev_.get ();
    }

    void ChannelDensity::
    setErev (const ErevType& x)
    {
      this->erev_.set (x);
    }

    void ChannelDensity::
    setErev (::std::unique_ptr< ErevType > x)
    {
      this->erev_.set (std::move (x));
    }

    const ChannelDensity::SegmentGroupType& ChannelDensity::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    ChannelDensity::SegmentGroupType& ChannelDensity::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void ChannelDensity::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void ChannelDensity::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }

    const ChannelDensity::SegmentGroupType& ChannelDensity::
    segmentGroupDefaultValue ()
    {
      return segmentGroup_default_value_;
    }

    const ChannelDensity::SegmentOptional& ChannelDensity::
    segment () const
    {
      return this->segment_;
    }

    ChannelDensity::SegmentOptional& ChannelDensity::
    segment ()
    {
      return this->segment_;
    }

    void ChannelDensity::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void ChannelDensity::
    setSegment (const SegmentOptional& x)
    {
      this->segment_ = x;
    }

    void ChannelDensity::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }

    const ChannelDensity::IonOptional& ChannelDensity::
    ion () const
    {
      return this->ion_;
    }

    ChannelDensity::IonOptional& ChannelDensity::
    ion ()
    {
      return this->ion_;
    }

    void ChannelDensity::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void ChannelDensity::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void ChannelDensity::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }


    // ChannelDensityNernst
    // 

    const ChannelDensityNernst::VariableParameterSequence& ChannelDensityNernst::
    variableParameters () const
    {
      return this->variableParameter_;
    }

    ChannelDensityNernst::VariableParameterSequence& ChannelDensityNernst::
    variableParameters ()
    {
      return this->variableParameter_;
    }

    void ChannelDensityNernst::
    setVariableParameters (const VariableParameterSequence& s)
    {
      this->variableParameter_ = s;
    }

    const ChannelDensityNernst::IonChannelType& ChannelDensityNernst::
    ionChannel () const
    {
      return this->ionChannel_.get ();
    }

    ChannelDensityNernst::IonChannelType& ChannelDensityNernst::
    ionChannel ()
    {
      return this->ionChannel_.get ();
    }

    void ChannelDensityNernst::
    setIonChannel (const IonChannelType& x)
    {
      this->ionChannel_.set (x);
    }

    void ChannelDensityNernst::
    setIonChannel (::std::unique_ptr< IonChannelType > x)
    {
      this->ionChannel_.set (std::move (x));
    }

    const ChannelDensityNernst::CondDensityOptional& ChannelDensityNernst::
    condDensity () const
    {
      return this->condDensity_;
    }

    ChannelDensityNernst::CondDensityOptional& ChannelDensityNernst::
    condDensity ()
    {
      return this->condDensity_;
    }

    void ChannelDensityNernst::
    setCondDensity (const CondDensityType& x)
    {
      this->condDensity_.set (x);
    }

    void ChannelDensityNernst::
    setCondDensity (const CondDensityOptional& x)
    {
      this->condDensity_ = x;
    }

    void ChannelDensityNernst::
    setCondDensity (::std::unique_ptr< CondDensityType > x)
    {
      this->condDensity_.set (std::move (x));
    }

    const ChannelDensityNernst::SegmentGroupType& ChannelDensityNernst::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    ChannelDensityNernst::SegmentGroupType& ChannelDensityNernst::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void ChannelDensityNernst::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void ChannelDensityNernst::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }

    const ChannelDensityNernst::SegmentGroupType& ChannelDensityNernst::
    segmentGroupDefaultValue ()
    {
      return segmentGroup_default_value_;
    }

    const ChannelDensityNernst::SegmentOptional& ChannelDensityNernst::
    segment () const
    {
      return this->segment_;
    }

    ChannelDensityNernst::SegmentOptional& ChannelDensityNernst::
    segment ()
    {
      return this->segment_;
    }

    void ChannelDensityNernst::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void ChannelDensityNernst::
    setSegment (const SegmentOptional& x)
    {
      this->segment_ = x;
    }

    void ChannelDensityNernst::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }

    const ChannelDensityNernst::IonOptional& ChannelDensityNernst::
    ion () const
    {
      return this->ion_;
    }

    ChannelDensityNernst::IonOptional& ChannelDensityNernst::
    ion ()
    {
      return this->ion_;
    }

    void ChannelDensityNernst::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void ChannelDensityNernst::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void ChannelDensityNernst::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }


    // ChannelDensityGHK
    // 

    const ChannelDensityGHK::VariableParameterSequence& ChannelDensityGHK::
    variableParameters () const
    {
      return this->variableParameter_;
    }

    ChannelDensityGHK::VariableParameterSequence& ChannelDensityGHK::
    variableParameters ()
    {
      return this->variableParameter_;
    }

    void ChannelDensityGHK::
    setVariableParameters (const VariableParameterSequence& s)
    {
      this->variableParameter_ = s;
    }

    const ChannelDensityGHK::IonChannelType& ChannelDensityGHK::
    ionChannel () const
    {
      return this->ionChannel_.get ();
    }

    ChannelDensityGHK::IonChannelType& ChannelDensityGHK::
    ionChannel ()
    {
      return this->ionChannel_.get ();
    }

    void ChannelDensityGHK::
    setIonChannel (const IonChannelType& x)
    {
      this->ionChannel_.set (x);
    }

    void ChannelDensityGHK::
    setIonChannel (::std::unique_ptr< IonChannelType > x)
    {
      this->ionChannel_.set (std::move (x));
    }

    const ChannelDensityGHK::PermeabilityType& ChannelDensityGHK::
    permeability () const
    {
      return this->permeability_.get ();
    }

    ChannelDensityGHK::PermeabilityType& ChannelDensityGHK::
    permeability ()
    {
      return this->permeability_.get ();
    }

    void ChannelDensityGHK::
    setPermeability (const PermeabilityType& x)
    {
      this->permeability_.set (x);
    }

    void ChannelDensityGHK::
    setPermeability (::std::unique_ptr< PermeabilityType > x)
    {
      this->permeability_.set (std::move (x));
    }

    const ChannelDensityGHK::SegmentGroupType& ChannelDensityGHK::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    ChannelDensityGHK::SegmentGroupType& ChannelDensityGHK::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void ChannelDensityGHK::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void ChannelDensityGHK::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }

    const ChannelDensityGHK::SegmentGroupType& ChannelDensityGHK::
    segmentGroupDefaultValue ()
    {
      return segmentGroup_default_value_;
    }

    const ChannelDensityGHK::SegmentOptional& ChannelDensityGHK::
    segment () const
    {
      return this->segment_;
    }

    ChannelDensityGHK::SegmentOptional& ChannelDensityGHK::
    segment ()
    {
      return this->segment_;
    }

    void ChannelDensityGHK::
    setSegment (const SegmentType& x)
    {
      this->segment_.set (x);
    }

    void ChannelDensityGHK::
    setSegment (const SegmentOptional& x)
    {
      this->segment_ = x;
    }

    void ChannelDensityGHK::
    setSegment (::std::unique_ptr< SegmentType > x)
    {
      this->segment_.set (std::move (x));
    }

    const ChannelDensityGHK::IonOptional& ChannelDensityGHK::
    ion () const
    {
      return this->ion_;
    }

    ChannelDensityGHK::IonOptional& ChannelDensityGHK::
    ion ()
    {
      return this->ion_;
    }

    void ChannelDensityGHK::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void ChannelDensityGHK::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void ChannelDensityGHK::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }


    // VariableParameter
    // 

    const VariableParameter::InhomogeneousValueOptional& VariableParameter::
    inhomogeneousValue () const
    {
      return this->inhomogeneousValue_;
    }

    VariableParameter::InhomogeneousValueOptional& VariableParameter::
    inhomogeneousValue ()
    {
      return this->inhomogeneousValue_;
    }

    void VariableParameter::
    setInhomogeneousValue (const InhomogeneousValueType& x)
    {
      this->inhomogeneousValue_.set (x);
    }

    void VariableParameter::
    setInhomogeneousValue (const InhomogeneousValueOptional& x)
    {
      this->inhomogeneousValue_ = x;
    }

    void VariableParameter::
    setInhomogeneousValue (::std::unique_ptr< InhomogeneousValueType > x)
    {
      this->inhomogeneousValue_.set (std::move (x));
    }

    const VariableParameter::ParameterType& VariableParameter::
    parameter () const
    {
      return this->parameter_.get ();
    }

    VariableParameter::ParameterType& VariableParameter::
    parameter ()
    {
      return this->parameter_.get ();
    }

    void VariableParameter::
    setParameter (const ParameterType& x)
    {
      this->parameter_.set (x);
    }

    void VariableParameter::
    setParameter (::std::unique_ptr< ParameterType > x)
    {
      this->parameter_.set (std::move (x));
    }

    const VariableParameter::SegmentGroupType& VariableParameter::
    segmentGroup () const
    {
      return this->segmentGroup_.get ();
    }

    VariableParameter::SegmentGroupType& VariableParameter::
    segmentGroup ()
    {
      return this->segmentGroup_.get ();
    }

    void VariableParameter::
    setSegmentGroup (const SegmentGroupType& x)
    {
      this->segmentGroup_.set (x);
    }

    void VariableParameter::
    setSegmentGroup (::std::unique_ptr< SegmentGroupType > x)
    {
      this->segmentGroup_.set (std::move (x));
    }


    // InhomogeneousValue
    // 

    const InhomogeneousValue::InhomogeneousParameterType& InhomogeneousValue::
    inhomogeneousParameter () const
    {
      return this->inhomogeneousParameter_.get ();
    }

    InhomogeneousValue::InhomogeneousParameterType& InhomogeneousValue::
    inhomogeneousParameter ()
    {
      return this->inhomogeneousParameter_.get ();
    }

    void InhomogeneousValue::
    setInhomogeneousParameter (const InhomogeneousParameterType& x)
    {
      this->inhomogeneousParameter_.set (x);
    }

    void InhomogeneousValue::
    setInhomogeneousParameter (::std::unique_ptr< InhomogeneousParameterType > x)
    {
      this->inhomogeneousParameter_.set (std::move (x));
    }

    const InhomogeneousValue::ValueType& InhomogeneousValue::
    value () const
    {
      return this->value_.get ();
    }

    InhomogeneousValue::ValueType& InhomogeneousValue::
    value ()
    {
      return this->value_.get ();
    }

    void InhomogeneousValue::
    setValue (const ValueType& x)
    {
      this->value_.set (x);
    }

    void InhomogeneousValue::
    setValue (::std::unique_ptr< ValueType > x)
    {
      this->value_.set (std::move (x));
    }


    // Species
    // 

    const Species::IdType& Species::
    id () const
    {
      return this->id_.get ();
    }

    Species::IdType& Species::
    id ()
    {
      return this->id_.get ();
    }

    void Species::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Species::
    setId (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const Species::ConcentrationModelType& Species::
    concentrationModel () const
    {
      return this->concentrationModel_.get ();
    }

    Species::ConcentrationModelType& Species::
    concentrationModel ()
    {
      return this->concentrationModel_.get ();
    }

    void Species::
    setConcentrationModel (const ConcentrationModelType& x)
    {
      this->concentrationModel_.set (x);
    }

    void Species::
    setConcentrationModel (::std::unique_ptr< ConcentrationModelType > x)
    {
      this->concentrationModel_.set (std::move (x));
    }

    const Species::IonOptional& Species::
    ion () const
    {
      return this->ion_;
    }

    Species::IonOptional& Species::
    ion ()
    {
      return this->ion_;
    }

    void Species::
    setIon (const IonType& x)
    {
      this->ion_.set (x);
    }

    void Species::
    setIon (const IonOptional& x)
    {
      this->ion_ = x;
    }

    void Species::
    setIon (::std::unique_ptr< IonType > x)
    {
      this->ion_.set (std::move (x));
    }

    const Species::InitialConcentrationType& Species::
    initialConcentration () const
    {
      return this->initialConcentration_.get ();
    }

    Species::InitialConcentrationType& Species::
    initialConcentration ()
    {
      return this->initialConcentration_.get ();
    }

    void Species::
    setInitialConcentration (const InitialConcentrationType& x)
    {
      this->initialConcentration_.set (x);
    }

    void Species::
    setInitialConcentration (::std::unique_ptr< InitialConcentrationType > x)
    {
      this->initialConcentration_.set (std::move (x));
    }

    const Species::InitialExtConcentrationType& Species::
    initialExtConcentration () const
    {
      return this->initialExtConcentration_.get ();
    }

    Species::InitialExtConcentrationType& Species::
    initialExtConcentration ()
    {
      return this->initialExtConcentration_.get ();
    }

    void Species::
    setInitialExtConcentration (const InitialExtConcentrationType& x)
    {
      this->initialExtConcentration_.set (x);
    }

    void Species::
    setInitialExtConcentration (::std::unique_ptr< InitialExtConcentrationType > x)
    {
      this->initialExtConcentration_.set (std::move (x));
    }


    // ConcentrationModel_D
    // 

    const ConcentrationModel_D::TypeType& ConcentrationModel_D::
    type () const
    {
      return this->type_.get ();
    }

    const ConcentrationModel_D::TypeType& ConcentrationModel_D::
    typeDefaultValue ()
    {
      return type_default_value_;
    }


    // IntracellularProperties
    // 

    const IntracellularProperties::SpeciesSequence& IntracellularProperties::
    speciess () const
    {
      return this->species_;
    }

    IntracellularProperties::SpeciesSequence& IntracellularProperties::
    speciess ()
    {
      return this->species_;
    }

    void IntracellularProperties::
    setSpeciess (const SpeciesSequence& s)
    {
      this->species_ = s;
    }

    const IntracellularProperties::ResistivitySequence& IntracellularProperties::
    resistivitys () const
    {
      return this->resistivity_;
    }

    IntracellularProperties::ResistivitySequence& IntracellularProperties::
    resistivitys ()
    {
      return this->resistivity_;
    }

    void IntracellularProperties::
    setResistivitys (const ResistivitySequence& s)
    {
      this->resistivity_ = s;
    }


    // ExtracellularProperties
    // 

    const ExtracellularProperties::SpeciesSequence& ExtracellularProperties::
    speciess () const
    {
      return this->species_;
    }

    ExtracellularProperties::SpeciesSequence& ExtracellularProperties::
    speciess ()
    {
      return this->species_;
    }

    void ExtracellularProperties::
    setSpeciess (const SpeciesSequence& s)
    {
      this->species_ = s;
    }


    // ExtracellularPropertiesLocal
    // 

    const ExtracellularPropertiesLocal::SpeciesSequence& ExtracellularPropertiesLocal::
    speciess () const
    {
      return this->species_;
    }

    ExtracellularPropertiesLocal::SpeciesSequence& ExtracellularPropertiesLocal::
    speciess ()
    {
      return this->species_;
    }

    void ExtracellularPropertiesLocal::
    setSpeciess (const SpeciesSequence& s)
    {
      this->species_ = s;
    }


    // ReactionScheme
    // 

    const ReactionScheme::SourceType& ReactionScheme::
    source () const
    {
      return this->source_.get ();
    }

    ReactionScheme::SourceType& ReactionScheme::
    source ()
    {
      return this->source_.get ();
    }

    void ReactionScheme::
    setSource (const SourceType& x)
    {
      this->source_.set (x);
    }

    void ReactionScheme::
    setSource (::std::unique_ptr< SourceType > x)
    {
      this->source_.set (std::move (x));
    }

    const ReactionScheme::TypeType& ReactionScheme::
    type () const
    {
      return this->type_.get ();
    }

    ReactionScheme::TypeType& ReactionScheme::
    type ()
    {
      return this->type_.get ();
    }

    void ReactionScheme::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void ReactionScheme::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }


    // PulseGenerator
    // 

    const PulseGenerator::DelayType& PulseGenerator::
    delay () const
    {
      return this->delay_.get ();
    }

    PulseGenerator::DelayType& PulseGenerator::
    delay ()
    {
      return this->delay_.get ();
    }

    void PulseGenerator::
    setDelay (const DelayType& x)
    {
      this->delay_.set (x);
    }

    void PulseGenerator::
    setDelay (::std::unique_ptr< DelayType > x)
    {
      this->delay_.set (std::move (x));
    }

    const PulseGenerator::DurationType& PulseGenerator::
    duration () const
    {
      return this->duration_.get ();
    }

    PulseGenerator::DurationType& PulseGenerator::
    duration ()
    {
      return this->duration_.get ();
    }

    void PulseGenerator::
    setDuration (const DurationType& x)
    {
      this->duration_.set (x);
    }

    void PulseGenerator::
    setDuration (::std::unique_ptr< DurationType > x)
    {
      this->duration_.set (std::move (x));
    }

    const PulseGenerator::AmplitudeType& PulseGenerator::
    amplitude () const
    {
      return this->amplitude_.get ();
    }

    PulseGenerator::AmplitudeType& PulseGenerator::
    amplitude ()
    {
      return this->amplitude_.get ();
    }

    void PulseGenerator::
    setAmplitude (const AmplitudeType& x)
    {
      this->amplitude_.set (x);
    }

    void PulseGenerator::
    setAmplitude (::std::unique_ptr< AmplitudeType > x)
    {
      this->amplitude_.set (std::move (x));
    }


    // SineGenerator
    // 

    const SineGenerator::DelayType& SineGenerator::
    delay () const
    {
      return this->delay_.get ();
    }

    SineGenerator::DelayType& SineGenerator::
    delay ()
    {
      return this->delay_.get ();
    }

    void SineGenerator::
    setDelay (const DelayType& x)
    {
      this->delay_.set (x);
    }

    void SineGenerator::
    setDelay (::std::unique_ptr< DelayType > x)
    {
      this->delay_.set (std::move (x));
    }

    const SineGenerator::PhaseType& SineGenerator::
    phase () const
    {
      return this->phase_.get ();
    }

    SineGenerator::PhaseType& SineGenerator::
    phase ()
    {
      return this->phase_.get ();
    }

    void SineGenerator::
    setPhase (const PhaseType& x)
    {
      this->phase_.set (x);
    }

    void SineGenerator::
    setPhase (::std::unique_ptr< PhaseType > x)
    {
      this->phase_.set (std::move (x));
    }

    const SineGenerator::DurationType& SineGenerator::
    duration () const
    {
      return this->duration_.get ();
    }

    SineGenerator::DurationType& SineGenerator::
    duration ()
    {
      return this->duration_.get ();
    }

    void SineGenerator::
    setDuration (const DurationType& x)
    {
      this->duration_.set (x);
    }

    void SineGenerator::
    setDuration (::std::unique_ptr< DurationType > x)
    {
      this->duration_.set (std::move (x));
    }

    const SineGenerator::AmplitudeType& SineGenerator::
    amplitude () const
    {
      return this->amplitude_.get ();
    }

    SineGenerator::AmplitudeType& SineGenerator::
    amplitude ()
    {
      return this->amplitude_.get ();
    }

    void SineGenerator::
    setAmplitude (const AmplitudeType& x)
    {
      this->amplitude_.set (x);
    }

    void SineGenerator::
    setAmplitude (::std::unique_ptr< AmplitudeType > x)
    {
      this->amplitude_.set (std::move (x));
    }

    const SineGenerator::PeriodType& SineGenerator::
    period () const
    {
      return this->period_.get ();
    }

    SineGenerator::PeriodType& SineGenerator::
    period ()
    {
      return this->period_.get ();
    }

    void SineGenerator::
    setPeriod (const PeriodType& x)
    {
      this->period_.set (x);
    }

    void SineGenerator::
    setPeriod (::std::unique_ptr< PeriodType > x)
    {
      this->period_.set (std::move (x));
    }


    // RampGenerator
    // 

    const RampGenerator::DelayType& RampGenerator::
    delay () const
    {
      return this->delay_.get ();
    }

    RampGenerator::DelayType& RampGenerator::
    delay ()
    {
      return this->delay_.get ();
    }

    void RampGenerator::
    setDelay (const DelayType& x)
    {
      this->delay_.set (x);
    }

    void RampGenerator::
    setDelay (::std::unique_ptr< DelayType > x)
    {
      this->delay_.set (std::move (x));
    }

    const RampGenerator::DurationType& RampGenerator::
    duration () const
    {
      return this->duration_.get ();
    }

    RampGenerator::DurationType& RampGenerator::
    duration ()
    {
      return this->duration_.get ();
    }

    void RampGenerator::
    setDuration (const DurationType& x)
    {
      this->duration_.set (x);
    }

    void RampGenerator::
    setDuration (::std::unique_ptr< DurationType > x)
    {
      this->duration_.set (std::move (x));
    }

    const RampGenerator::StartAmplitudeType& RampGenerator::
    startAmplitude () const
    {
      return this->startAmplitude_.get ();
    }

    RampGenerator::StartAmplitudeType& RampGenerator::
    startAmplitude ()
    {
      return this->startAmplitude_.get ();
    }

    void RampGenerator::
    setStartAmplitude (const StartAmplitudeType& x)
    {
      this->startAmplitude_.set (x);
    }

    void RampGenerator::
    setStartAmplitude (::std::unique_ptr< StartAmplitudeType > x)
    {
      this->startAmplitude_.set (std::move (x));
    }

    const RampGenerator::FinishAmplitudeType& RampGenerator::
    finishAmplitude () const
    {
      return this->finishAmplitude_.get ();
    }

    RampGenerator::FinishAmplitudeType& RampGenerator::
    finishAmplitude ()
    {
      return this->finishAmplitude_.get ();
    }

    void RampGenerator::
    setFinishAmplitude (const FinishAmplitudeType& x)
    {
      this->finishAmplitude_.set (x);
    }

    void RampGenerator::
    setFinishAmplitude (::std::unique_ptr< FinishAmplitudeType > x)
    {
      this->finishAmplitude_.set (std::move (x));
    }

    const RampGenerator::BaselineAmplitudeType& RampGenerator::
    baselineAmplitude () const
    {
      return this->baselineAmplitude_.get ();
    }

    RampGenerator::BaselineAmplitudeType& RampGenerator::
    baselineAmplitude ()
    {
      return this->baselineAmplitude_.get ();
    }

    void RampGenerator::
    setBaselineAmplitude (const BaselineAmplitudeType& x)
    {
      this->baselineAmplitude_.set (x);
    }

    void RampGenerator::
    setBaselineAmplitude (::std::unique_ptr< BaselineAmplitudeType > x)
    {
      this->baselineAmplitude_.set (std::move (x));
    }


    // VoltageClamp
    // 

    const VoltageClamp::DelayType& VoltageClamp::
    delay () const
    {
      return this->delay_.get ();
    }

    VoltageClamp::DelayType& VoltageClamp::
    delay ()
    {
      return this->delay_.get ();
    }

    void VoltageClamp::
    setDelay (const DelayType& x)
    {
      this->delay_.set (x);
    }

    void VoltageClamp::
    setDelay (::std::unique_ptr< DelayType > x)
    {
      this->delay_.set (std::move (x));
    }

    const VoltageClamp::DurationType& VoltageClamp::
    duration () const
    {
      return this->duration_.get ();
    }

    VoltageClamp::DurationType& VoltageClamp::
    duration ()
    {
      return this->duration_.get ();
    }

    void VoltageClamp::
    setDuration (const DurationType& x)
    {
      this->duration_.set (x);
    }

    void VoltageClamp::
    setDuration (::std::unique_ptr< DurationType > x)
    {
      this->duration_.set (std::move (x));
    }

    const VoltageClamp::TargetVoltageType& VoltageClamp::
    targetVoltage () const
    {
      return this->targetVoltage_.get ();
    }

    VoltageClamp::TargetVoltageType& VoltageClamp::
    targetVoltage ()
    {
      return this->targetVoltage_.get ();
    }

    void VoltageClamp::
    setTargetVoltage (const TargetVoltageType& x)
    {
      this->targetVoltage_.set (x);
    }

    void VoltageClamp::
    setTargetVoltage (::std::unique_ptr< TargetVoltageType > x)
    {
      this->targetVoltage_.set (std::move (x));
    }

    const VoltageClamp::SimpleSeriesResistanceType& VoltageClamp::
    simpleSeriesResistance () const
    {
      return this->simpleSeriesResistance_.get ();
    }

    VoltageClamp::SimpleSeriesResistanceType& VoltageClamp::
    simpleSeriesResistance ()
    {
      return this->simpleSeriesResistance_.get ();
    }

    void VoltageClamp::
    setSimpleSeriesResistance (const SimpleSeriesResistanceType& x)
    {
      this->simpleSeriesResistance_.set (x);
    }

    void VoltageClamp::
    setSimpleSeriesResistance (::std::unique_ptr< SimpleSeriesResistanceType > x)
    {
      this->simpleSeriesResistance_.set (std::move (x));
    }


    // Spike
    // 

    const Spike::TimeType& Spike::
    time () const
    {
      return this->time_.get ();
    }

    Spike::TimeType& Spike::
    time ()
    {
      return this->time_.get ();
    }

    void Spike::
    setTime (const TimeType& x)
    {
      this->time_.set (x);
    }

    void Spike::
    setTime (::std::unique_ptr< TimeType > x)
    {
      this->time_.set (std::move (x));
    }


    // SpikeArray
    // 

    const SpikeArray::SpikeSequence& SpikeArray::
    spikes () const
    {
      return this->spike_;
    }

    SpikeArray::SpikeSequence& SpikeArray::
    spikes ()
    {
      return this->spike_;
    }

    void SpikeArray::
    setSpikes (const SpikeSequence& s)
    {
      this->spike_ = s;
    }


    // SpikeGenerator
    // 

    const SpikeGenerator::PeriodType& SpikeGenerator::
    period () const
    {
      return this->period_.get ();
    }

    SpikeGenerator::PeriodType& SpikeGenerator::
    period ()
    {
      return this->period_.get ();
    }

    void SpikeGenerator::
    setPeriod (const PeriodType& x)
    {
      this->period_.set (x);
    }

    void SpikeGenerator::
    setPeriod (::std::unique_ptr< PeriodType > x)
    {
      this->period_.set (std::move (x));
    }


    // SpikeGeneratorRandom
    // 

    const SpikeGeneratorRandom::MaxISIType& SpikeGeneratorRandom::
    maxISI () const
    {
      return this->maxISI_.get ();
    }

    SpikeGeneratorRandom::MaxISIType& SpikeGeneratorRandom::
    maxISI ()
    {
      return this->maxISI_.get ();
    }

    void SpikeGeneratorRandom::
    setMaxISI (const MaxISIType& x)
    {
      this->maxISI_.set (x);
    }

    void SpikeGeneratorRandom::
    setMaxISI (::std::unique_ptr< MaxISIType > x)
    {
      this->maxISI_.set (std::move (x));
    }

    const SpikeGeneratorRandom::MinISIType& SpikeGeneratorRandom::
    minISI () const
    {
      return this->minISI_.get ();
    }

    SpikeGeneratorRandom::MinISIType& SpikeGeneratorRandom::
    minISI ()
    {
      return this->minISI_.get ();
    }

    void SpikeGeneratorRandom::
    setMinISI (const MinISIType& x)
    {
      this->minISI_.set (x);
    }

    void SpikeGeneratorRandom::
    setMinISI (::std::unique_ptr< MinISIType > x)
    {
      this->minISI_.set (std::move (x));
    }


    // SpikeGeneratorPoisson
    // 

    const SpikeGeneratorPoisson::AverageRateType& SpikeGeneratorPoisson::
    averageRate () const
    {
      return this->averageRate_.get ();
    }

    SpikeGeneratorPoisson::AverageRateType& SpikeGeneratorPoisson::
    averageRate ()
    {
      return this->averageRate_.get ();
    }

    void SpikeGeneratorPoisson::
    setAverageRate (const AverageRateType& x)
    {
      this->averageRate_.set (x);
    }

    void SpikeGeneratorPoisson::
    setAverageRate (::std::unique_ptr< AverageRateType > x)
    {
      this->averageRate_.set (std::move (x));
    }


    // Network
    // 

    const Network::SpaceSequence& Network::
    spaces () const
    {
      return this->space_;
    }

    Network::SpaceSequence& Network::
    spaces ()
    {
      return this->space_;
    }

    void Network::
    setSpaces (const SpaceSequence& s)
    {
      this->space_ = s;
    }

    const Network::RegionSequence& Network::
    regions () const
    {
      return this->region_;
    }

    Network::RegionSequence& Network::
    regions ()
    {
      return this->region_;
    }

    void Network::
    setRegions (const RegionSequence& s)
    {
      this->region_ = s;
    }

    const Network::ExtracellularPropertiesSequence& Network::
    extracellularPropertiess () const
    {
      return this->extracellularProperties_;
    }

    Network::ExtracellularPropertiesSequence& Network::
    extracellularPropertiess ()
    {
      return this->extracellularProperties_;
    }

    void Network::
    setExtracellularPropertiess (const ExtracellularPropertiesSequence& s)
    {
      this->extracellularProperties_ = s;
    }

    const Network::PopulationSequence& Network::
    populations () const
    {
      return this->population_;
    }

    Network::PopulationSequence& Network::
    populations ()
    {
      return this->population_;
    }

    void Network::
    setPopulations (const PopulationSequence& s)
    {
      this->population_ = s;
    }

    const Network::CellSetSequence& Network::
    cellSets () const
    {
      return this->cellSet_;
    }

    Network::CellSetSequence& Network::
    cellSets ()
    {
      return this->cellSet_;
    }

    void Network::
    setCellSets (const CellSetSequence& s)
    {
      this->cellSet_ = s;
    }

    const Network::SynapticConnectionSequence& Network::
    synapticConnections () const
    {
      return this->synapticConnection_;
    }

    Network::SynapticConnectionSequence& Network::
    synapticConnections ()
    {
      return this->synapticConnection_;
    }

    void Network::
    setSynapticConnections (const SynapticConnectionSequence& s)
    {
      this->synapticConnection_ = s;
    }

    const Network::ProjectionSequence& Network::
    projections () const
    {
      return this->projection_;
    }

    Network::ProjectionSequence& Network::
    projections ()
    {
      return this->projection_;
    }

    void Network::
    setProjections (const ProjectionSequence& s)
    {
      this->projection_ = s;
    }

    const Network::ExplicitInputSequence& Network::
    explicitInputs () const
    {
      return this->explicitInput_;
    }

    Network::ExplicitInputSequence& Network::
    explicitInputs ()
    {
      return this->explicitInput_;
    }

    void Network::
    setExplicitInputs (const ExplicitInputSequence& s)
    {
      this->explicitInput_ = s;
    }

    const Network::InputListSequence& Network::
    inputLists () const
    {
      return this->inputList_;
    }

    Network::InputListSequence& Network::
    inputLists ()
    {
      return this->inputList_;
    }

    void Network::
    setInputLists (const InputListSequence& s)
    {
      this->inputList_ = s;
    }

    const Network::TypeOptional& Network::
    type () const
    {
      return this->type_;
    }

    Network::TypeOptional& Network::
    type ()
    {
      return this->type_;
    }

    void Network::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void Network::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void Network::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const Network::TemperatureOptional& Network::
    temperature () const
    {
      return this->temperature_;
    }

    Network::TemperatureOptional& Network::
    temperature ()
    {
      return this->temperature_;
    }

    void Network::
    setTemperature (const TemperatureType& x)
    {
      this->temperature_.set (x);
    }

    void Network::
    setTemperature (const TemperatureOptional& x)
    {
      this->temperature_ = x;
    }

    void Network::
    setTemperature (::std::unique_ptr< TemperatureType > x)
    {
      this->temperature_.set (std::move (x));
    }


    // NetworkTypes
    // 

    NetworkTypes::
    NetworkTypes (Value v)
    : ::xml_schema::String (_xsd_NetworkTypes_literals_[v])
    {
    }

    NetworkTypes::
    NetworkTypes (const char* v)
    : ::xml_schema::String (v)
    {
    }

    NetworkTypes::
    NetworkTypes (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    NetworkTypes::
    NetworkTypes (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    NetworkTypes::
    NetworkTypes (const NetworkTypes& v,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    NetworkTypes& NetworkTypes::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_NetworkTypes_literals_[v]);

      return *this;
    }


    // Space
    // 

    const Space::StructureOptional& Space::
    structure () const
    {
      return this->structure_;
    }

    Space::StructureOptional& Space::
    structure ()
    {
      return this->structure_;
    }

    void Space::
    setStructure (const StructureType& x)
    {
      this->structure_.set (x);
    }

    void Space::
    setStructure (const StructureOptional& x)
    {
      this->structure_ = x;
    }

    void Space::
    setStructure (::std::unique_ptr< StructureType > x)
    {
      this->structure_.set (std::move (x));
    }

    const Space::BasedOnOptional& Space::
    basedOn () const
    {
      return this->basedOn_;
    }

    Space::BasedOnOptional& Space::
    basedOn ()
    {
      return this->basedOn_;
    }

    void Space::
    setBasedOn (const BasedOnType& x)
    {
      this->basedOn_.set (x);
    }

    void Space::
    setBasedOn (const BasedOnOptional& x)
    {
      this->basedOn_ = x;
    }

    void Space::
    setBasedOn (::std::unique_ptr< BasedOnType > x)
    {
      this->basedOn_.set (std::move (x));
    }


    // SpaceStructure
    // 

    const SpaceStructure::XSpacingOptional& SpaceStructure::
    xSpacing () const
    {
      return this->xSpacing_;
    }

    SpaceStructure::XSpacingOptional& SpaceStructure::
    xSpacing ()
    {
      return this->xSpacing_;
    }

    void SpaceStructure::
    setXSpacing (const XSpacingType& x)
    {
      this->xSpacing_.set (x);
    }

    void SpaceStructure::
    setXSpacing (const XSpacingOptional& x)
    {
      this->xSpacing_ = x;
    }

    const SpaceStructure::YSpacingOptional& SpaceStructure::
    ySpacing () const
    {
      return this->ySpacing_;
    }

    SpaceStructure::YSpacingOptional& SpaceStructure::
    ySpacing ()
    {
      return this->ySpacing_;
    }

    void SpaceStructure::
    setYSpacing (const YSpacingType& x)
    {
      this->ySpacing_.set (x);
    }

    void SpaceStructure::
    setYSpacing (const YSpacingOptional& x)
    {
      this->ySpacing_ = x;
    }

    const SpaceStructure::ZSpacingOptional& SpaceStructure::
    zSpacing () const
    {
      return this->zSpacing_;
    }

    SpaceStructure::ZSpacingOptional& SpaceStructure::
    zSpacing ()
    {
      return this->zSpacing_;
    }

    void SpaceStructure::
    setZSpacing (const ZSpacingType& x)
    {
      this->zSpacing_.set (x);
    }

    void SpaceStructure::
    setZSpacing (const ZSpacingOptional& x)
    {
      this->zSpacing_ = x;
    }

    const SpaceStructure::XStartType& SpaceStructure::
    xStart () const
    {
      return this->xStart_.get ();
    }

    SpaceStructure::XStartType& SpaceStructure::
    xStart ()
    {
      return this->xStart_.get ();
    }

    void SpaceStructure::
    setXStart (const XStartType& x)
    {
      this->xStart_.set (x);
    }

    SpaceStructure::XStartType SpaceStructure::
    xStartDefaultValue ()
    {
      return XStartType (0.0F);
    }

    const SpaceStructure::YStartType& SpaceStructure::
    yStart () const
    {
      return this->yStart_.get ();
    }

    SpaceStructure::YStartType& SpaceStructure::
    yStart ()
    {
      return this->yStart_.get ();
    }

    void SpaceStructure::
    setYStart (const YStartType& x)
    {
      this->yStart_.set (x);
    }

    SpaceStructure::YStartType SpaceStructure::
    yStartDefaultValue ()
    {
      return YStartType (0.0F);
    }

    const SpaceStructure::ZStartType& SpaceStructure::
    zStart () const
    {
      return this->zStart_.get ();
    }

    SpaceStructure::ZStartType& SpaceStructure::
    zStart ()
    {
      return this->zStart_.get ();
    }

    void SpaceStructure::
    setZStart (const ZStartType& x)
    {
      this->zStart_.set (x);
    }

    SpaceStructure::ZStartType SpaceStructure::
    zStartDefaultValue ()
    {
      return ZStartType (0.0F);
    }


    // AllowedSpaces
    // 

    AllowedSpaces::
    AllowedSpaces (Value v)
    : ::xml_schema::String (_xsd_AllowedSpaces_literals_[v])
    {
    }

    AllowedSpaces::
    AllowedSpaces (const char* v)
    : ::xml_schema::String (v)
    {
    }

    AllowedSpaces::
    AllowedSpaces (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    AllowedSpaces::
    AllowedSpaces (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    AllowedSpaces::
    AllowedSpaces (const AllowedSpaces& v,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    AllowedSpaces& AllowedSpaces::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_AllowedSpaces_literals_[v]);

      return *this;
    }


    // Region
    // 

    const Region::SpaceOptional& Region::
    space () const
    {
      return this->space_;
    }

    Region::SpaceOptional& Region::
    space ()
    {
      return this->space_;
    }

    void Region::
    setSpace (const SpaceType& x)
    {
      this->space_.set (x);
    }

    void Region::
    setSpace (const SpaceOptional& x)
    {
      this->space_ = x;
    }

    void Region::
    setSpace (::std::unique_ptr< SpaceType > x)
    {
      this->space_.set (std::move (x));
    }


    // Population
    // 

    const Population::LayoutOptional& Population::
    layout () const
    {
      return this->layout_;
    }

    Population::LayoutOptional& Population::
    layout ()
    {
      return this->layout_;
    }

    void Population::
    setLayout (const LayoutType& x)
    {
      this->layout_.set (x);
    }

    void Population::
    setLayout (const LayoutOptional& x)
    {
      this->layout_ = x;
    }

    void Population::
    setLayout (::std::unique_ptr< LayoutType > x)
    {
      this->layout_.set (std::move (x));
    }

    const Population::InstanceSequence& Population::
    instances () const
    {
      return this->instance_;
    }

    Population::InstanceSequence& Population::
    instances ()
    {
      return this->instance_;
    }

    void Population::
    setInstances (const InstanceSequence& s)
    {
      this->instance_ = s;
    }

    const Population::CellOptional& Population::
    cell () const
    {
      return this->cell_;
    }

    Population::CellOptional& Population::
    cell ()
    {
      return this->cell_;
    }

    void Population::
    setCell (const CellType& x)
    {
      this->cell_.set (x);
    }

    void Population::
    setCell (const CellOptional& x)
    {
      this->cell_ = x;
    }

    void Population::
    setCell (::std::unique_ptr< CellType > x)
    {
      this->cell_.set (std::move (x));
    }

    const Population::NetworkOptional& Population::
    network () const
    {
      return this->network_;
    }

    Population::NetworkOptional& Population::
    network ()
    {
      return this->network_;
    }

    void Population::
    setNetwork (const NetworkType& x)
    {
      this->network_.set (x);
    }

    void Population::
    setNetwork (const NetworkOptional& x)
    {
      this->network_ = x;
    }

    void Population::
    setNetwork (::std::unique_ptr< NetworkType > x)
    {
      this->network_.set (std::move (x));
    }

    const Population::ComponentOptional& Population::
    component () const
    {
      return this->component_;
    }

    Population::ComponentOptional& Population::
    component ()
    {
      return this->component_;
    }

    void Population::
    setComponent (const ComponentType& x)
    {
      this->component_.set (x);
    }

    void Population::
    setComponent (const ComponentOptional& x)
    {
      this->component_ = x;
    }

    void Population::
    setComponent (::std::unique_ptr< ComponentType > x)
    {
      this->component_.set (std::move (x));
    }

    const Population::SizeOptional& Population::
    size () const
    {
      return this->size_;
    }

    Population::SizeOptional& Population::
    size ()
    {
      return this->size_;
    }

    void Population::
    setSize (const SizeType& x)
    {
      this->size_.set (x);
    }

    void Population::
    setSize (const SizeOptional& x)
    {
      this->size_ = x;
    }

    const Population::TypeOptional& Population::
    type () const
    {
      return this->type_;
    }

    Population::TypeOptional& Population::
    type ()
    {
      return this->type_;
    }

    void Population::
    setType (const TypeType& x)
    {
      this->type_.set (x);
    }

    void Population::
    setType (const TypeOptional& x)
    {
      this->type_ = x;
    }

    void Population::
    setType (::std::unique_ptr< TypeType > x)
    {
      this->type_.set (std::move (x));
    }

    const Population::ExtracellularPropertiesOptional& Population::
    extracellularProperties () const
    {
      return this->extracellularProperties_;
    }

    Population::ExtracellularPropertiesOptional& Population::
    extracellularProperties ()
    {
      return this->extracellularProperties_;
    }

    void Population::
    setExtracellularProperties (const ExtracellularPropertiesType& x)
    {
      this->extracellularProperties_.set (x);
    }

    void Population::
    setExtracellularProperties (const ExtracellularPropertiesOptional& x)
    {
      this->extracellularProperties_ = x;
    }

    void Population::
    setExtracellularProperties (::std::unique_ptr< ExtracellularPropertiesType > x)
    {
      this->extracellularProperties_.set (std::move (x));
    }


    // PopulationTypes
    // 

    PopulationTypes::
    PopulationTypes (Value v)
    : ::xml_schema::String (_xsd_PopulationTypes_literals_[v])
    {
    }

    PopulationTypes::
    PopulationTypes (const char* v)
    : ::xml_schema::String (v)
    {
    }

    PopulationTypes::
    PopulationTypes (const ::std::string& v)
    : ::xml_schema::String (v)
    {
    }

    PopulationTypes::
    PopulationTypes (const ::xml_schema::String& v)
    : ::xml_schema::String (v)
    {
    }

    PopulationTypes::
    PopulationTypes (const PopulationTypes& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (v, f, c)
    {
    }

    PopulationTypes& PopulationTypes::
    operator= (Value v)
    {
      static_cast< ::xml_schema::String& > (*this) = 
      ::xml_schema::String (_xsd_PopulationTypes_literals_[v]);

      return *this;
    }


    // Layout
    // 

    const Layout::RandomOptional& Layout::
    random () const
    {
      return this->random_;
    }

    Layout::RandomOptional& Layout::
    random ()
    {
      return this->random_;
    }

    void Layout::
    setRandom (const RandomType& x)
    {
      this->random_.set (x);
    }

    void Layout::
    setRandom (const RandomOptional& x)
    {
      this->random_ = x;
    }

    void Layout::
    setRandom (::std::unique_ptr< RandomType > x)
    {
      this->random_.set (std::move (x));
    }

    const Layout::GridOptional& Layout::
    grid () const
    {
      return this->grid_;
    }

    Layout::GridOptional& Layout::
    grid ()
    {
      return this->grid_;
    }

    void Layout::
    setGrid (const GridType& x)
    {
      this->grid_.set (x);
    }

    void Layout::
    setGrid (const GridOptional& x)
    {
      this->grid_ = x;
    }

    void Layout::
    setGrid (::std::unique_ptr< GridType > x)
    {
      this->grid_.set (std::move (x));
    }

    const Layout::UnstructuredOptional& Layout::
    unstructured () const
    {
      return this->unstructured_;
    }

    Layout::UnstructuredOptional& Layout::
    unstructured ()
    {
      return this->unstructured_;
    }

    void Layout::
    setUnstructured (const UnstructuredType& x)
    {
      this->unstructured_.set (x);
    }

    void Layout::
    setUnstructured (const UnstructuredOptional& x)
    {
      this->unstructured_ = x;
    }

    void Layout::
    setUnstructured (::std::unique_ptr< UnstructuredType > x)
    {
      this->unstructured_.set (std::move (x));
    }

    const Layout::SpaceOptional& Layout::
    space () const
    {
      return this->space_;
    }

    Layout::SpaceOptional& Layout::
    space ()
    {
      return this->space_;
    }

    void Layout::
    setSpace (const SpaceType& x)
    {
      this->space_.set (x);
    }

    void Layout::
    setSpace (const SpaceOptional& x)
    {
      this->space_ = x;
    }

    void Layout::
    setSpace (::std::unique_ptr< SpaceType > x)
    {
      this->space_.set (std::move (x));
    }


    // UnstructuredLayout
    // 

    const UnstructuredLayout::NumberOptional& UnstructuredLayout::
    number () const
    {
      return this->number_;
    }

    UnstructuredLayout::NumberOptional& UnstructuredLayout::
    number ()
    {
      return this->number_;
    }

    void UnstructuredLayout::
    setNumber (const NumberType& x)
    {
      this->number_.set (x);
    }

    void UnstructuredLayout::
    setNumber (const NumberOptional& x)
    {
      this->number_ = x;
    }


    // RandomLayout
    // 

    const RandomLayout::NumberOptional& RandomLayout::
    number () const
    {
      return this->number_;
    }

    RandomLayout::NumberOptional& RandomLayout::
    number ()
    {
      return this->number_;
    }

    void RandomLayout::
    setNumber (const NumberType& x)
    {
      this->number_.set (x);
    }

    void RandomLayout::
    setNumber (const NumberOptional& x)
    {
      this->number_ = x;
    }

    const RandomLayout::RegionOptional& RandomLayout::
    region () const
    {
      return this->region_;
    }

    RandomLayout::RegionOptional& RandomLayout::
    region ()
    {
      return this->region_;
    }

    void RandomLayout::
    setRegion (const RegionType& x)
    {
      this->region_.set (x);
    }

    void RandomLayout::
    setRegion (const RegionOptional& x)
    {
      this->region_ = x;
    }

    void RandomLayout::
    setRegion (::std::unique_ptr< RegionType > x)
    {
      this->region_.set (std::move (x));
    }


    // GridLayout
    // 

    const GridLayout::XSizeOptional& GridLayout::
    xSize () const
    {
      return this->xSize_;
    }

    GridLayout::XSizeOptional& GridLayout::
    xSize ()
    {
      return this->xSize_;
    }

    void GridLayout::
    setXSize (const XSizeType& x)
    {
      this->xSize_.set (x);
    }

    void GridLayout::
    setXSize (const XSizeOptional& x)
    {
      this->xSize_ = x;
    }

    const GridLayout::YSizeOptional& GridLayout::
    ySize () const
    {
      return this->ySize_;
    }

    GridLayout::YSizeOptional& GridLayout::
    ySize ()
    {
      return this->ySize_;
    }

    void GridLayout::
    setYSize (const YSizeType& x)
    {
      this->ySize_.set (x);
    }

    void GridLayout::
    setYSize (const YSizeOptional& x)
    {
      this->ySize_ = x;
    }

    const GridLayout::ZSizeOptional& GridLayout::
    zSize () const
    {
      return this->zSize_;
    }

    GridLayout::ZSizeOptional& GridLayout::
    zSize ()
    {
      return this->zSize_;
    }

    void GridLayout::
    setZSize (const ZSizeType& x)
    {
      this->zSize_.set (x);
    }

    void GridLayout::
    setZSize (const ZSizeOptional& x)
    {
      this->zSize_ = x;
    }


    // Instance
    // 

    const Instance::LocationType& Instance::
    location () const
    {
      return this->location_.get ();
    }

    Instance::LocationType& Instance::
    location ()
    {
      return this->location_.get ();
    }

    void Instance::
    setLocation (const LocationType& x)
    {
      this->location_.set (x);
    }

    void Instance::
    setLocation (::std::unique_ptr< LocationType > x)
    {
      this->location_.set (std::move (x));
    }

    const Instance::IdOptional& Instance::
    id () const
    {
      return this->id_;
    }

    Instance::IdOptional& Instance::
    id ()
    {
      return this->id_;
    }

    void Instance::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Instance::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    const Instance::IOptional& Instance::
    i () const
    {
      return this->i_;
    }

    Instance::IOptional& Instance::
    i ()
    {
      return this->i_;
    }

    void Instance::
    setI (const IType& x)
    {
      this->i_.set (x);
    }

    void Instance::
    setI (const IOptional& x)
    {
      this->i_ = x;
    }

    const Instance::JOptional& Instance::
    j () const
    {
      return this->j_;
    }

    Instance::JOptional& Instance::
    j ()
    {
      return this->j_;
    }

    void Instance::
    setJ (const JType& x)
    {
      this->j_.set (x);
    }

    void Instance::
    setJ (const JOptional& x)
    {
      this->j_ = x;
    }

    const Instance::KOptional& Instance::
    k () const
    {
      return this->k_;
    }

    Instance::KOptional& Instance::
    k ()
    {
      return this->k_;
    }

    void Instance::
    setK (const KType& x)
    {
      this->k_.set (x);
    }

    void Instance::
    setK (const KOptional& x)
    {
      this->k_ = x;
    }


    // Location
    // 

    const Location::XOptional& Location::
    x () const
    {
      return this->x_;
    }

    Location::XOptional& Location::
    x ()
    {
      return this->x_;
    }

    void Location::
    setX (const XType& x)
    {
      this->x_.set (x);
    }

    void Location::
    setX (const XOptional& x)
    {
      this->x_ = x;
    }

    const Location::YOptional& Location::
    y () const
    {
      return this->y_;
    }

    Location::YOptional& Location::
    y ()
    {
      return this->y_;
    }

    void Location::
    setY (const YType& x)
    {
      this->y_.set (x);
    }

    void Location::
    setY (const YOptional& x)
    {
      this->y_ = x;
    }

    const Location::ZOptional& Location::
    z () const
    {
      return this->z_;
    }

    Location::ZOptional& Location::
    z ()
    {
      return this->z_;
    }

    void Location::
    setZ (const ZType& x)
    {
      this->z_.set (x);
    }

    void Location::
    setZ (const ZOptional& x)
    {
      this->z_ = x;
    }


    // CellSet
    // 

    const CellSet::SelectType& CellSet::
    select () const
    {
      return this->select_.get ();
    }

    CellSet::SelectType& CellSet::
    select ()
    {
      return this->select_.get ();
    }

    void CellSet::
    setSelect (const SelectType& x)
    {
      this->select_.set (x);
    }

    void CellSet::
    setSelect (::std::unique_ptr< SelectType > x)
    {
      this->select_.set (std::move (x));
    }


    // SynapticConnection
    // 

    const SynapticConnection::FromOptional& SynapticConnection::
    from () const
    {
      return this->from_;
    }

    SynapticConnection::FromOptional& SynapticConnection::
    from ()
    {
      return this->from_;
    }

    void SynapticConnection::
    setFrom (const FromType& x)
    {
      this->from_.set (x);
    }

    void SynapticConnection::
    setFrom (const FromOptional& x)
    {
      this->from_ = x;
    }

    void SynapticConnection::
    setFrom (::std::unique_ptr< FromType > x)
    {
      this->from_.set (std::move (x));
    }

    const SynapticConnection::ToOptional& SynapticConnection::
    to () const
    {
      return this->to_;
    }

    SynapticConnection::ToOptional& SynapticConnection::
    to ()
    {
      return this->to_;
    }

    void SynapticConnection::
    setTo (const ToType& x)
    {
      this->to_.set (x);
    }

    void SynapticConnection::
    setTo (const ToOptional& x)
    {
      this->to_ = x;
    }

    void SynapticConnection::
    setTo (::std::unique_ptr< ToType > x)
    {
      this->to_.set (std::move (x));
    }

    const SynapticConnection::SynapseOptional& SynapticConnection::
    synapse () const
    {
      return this->synapse_;
    }

    SynapticConnection::SynapseOptional& SynapticConnection::
    synapse ()
    {
      return this->synapse_;
    }

    void SynapticConnection::
    setSynapse (const SynapseType& x)
    {
      this->synapse_.set (x);
    }

    void SynapticConnection::
    setSynapse (const SynapseOptional& x)
    {
      this->synapse_ = x;
    }

    void SynapticConnection::
    setSynapse (::std::unique_ptr< SynapseType > x)
    {
      this->synapse_.set (std::move (x));
    }

    const SynapticConnection::DestinationOptional& SynapticConnection::
    destination () const
    {
      return this->destination_;
    }

    SynapticConnection::DestinationOptional& SynapticConnection::
    destination ()
    {
      return this->destination_;
    }

    void SynapticConnection::
    setDestination (const DestinationType& x)
    {
      this->destination_.set (x);
    }

    void SynapticConnection::
    setDestination (const DestinationOptional& x)
    {
      this->destination_ = x;
    }

    void SynapticConnection::
    setDestination (::std::unique_ptr< DestinationType > x)
    {
      this->destination_.set (std::move (x));
    }


    // Projection
    // 

    const Projection::ConnectionSequence& Projection::
    connections () const
    {
      return this->connection_;
    }

    Projection::ConnectionSequence& Projection::
    connections ()
    {
      return this->connection_;
    }

    void Projection::
    setConnections (const ConnectionSequence& s)
    {
      this->connection_ = s;
    }

    const Projection::PresynapticPopulationOptional& Projection::
    presynapticPopulation () const
    {
      return this->presynapticPopulation_;
    }

    Projection::PresynapticPopulationOptional& Projection::
    presynapticPopulation ()
    {
      return this->presynapticPopulation_;
    }

    void Projection::
    setPresynapticPopulation (const PresynapticPopulationType& x)
    {
      this->presynapticPopulation_.set (x);
    }

    void Projection::
    setPresynapticPopulation (const PresynapticPopulationOptional& x)
    {
      this->presynapticPopulation_ = x;
    }

    void Projection::
    setPresynapticPopulation (::std::unique_ptr< PresynapticPopulationType > x)
    {
      this->presynapticPopulation_.set (std::move (x));
    }

    const Projection::PostsynapticPopulationOptional& Projection::
    postsynapticPopulation () const
    {
      return this->postsynapticPopulation_;
    }

    Projection::PostsynapticPopulationOptional& Projection::
    postsynapticPopulation ()
    {
      return this->postsynapticPopulation_;
    }

    void Projection::
    setPostsynapticPopulation (const PostsynapticPopulationType& x)
    {
      this->postsynapticPopulation_.set (x);
    }

    void Projection::
    setPostsynapticPopulation (const PostsynapticPopulationOptional& x)
    {
      this->postsynapticPopulation_ = x;
    }

    void Projection::
    setPostsynapticPopulation (::std::unique_ptr< PostsynapticPopulationType > x)
    {
      this->postsynapticPopulation_.set (std::move (x));
    }

    const Projection::SynapseOptional& Projection::
    synapse () const
    {
      return this->synapse_;
    }

    Projection::SynapseOptional& Projection::
    synapse ()
    {
      return this->synapse_;
    }

    void Projection::
    setSynapse (const SynapseType& x)
    {
      this->synapse_.set (x);
    }

    void Projection::
    setSynapse (const SynapseOptional& x)
    {
      this->synapse_ = x;
    }

    void Projection::
    setSynapse (::std::unique_ptr< SynapseType > x)
    {
      this->synapse_.set (std::move (x));
    }


    // Connection
    // 

    const Connection::IdOptional& Connection::
    id () const
    {
      return this->id_;
    }

    Connection::IdOptional& Connection::
    id ()
    {
      return this->id_;
    }

    void Connection::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Connection::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    const Connection::PreCellIdOptional& Connection::
    preCellId () const
    {
      return this->preCellId_;
    }

    Connection::PreCellIdOptional& Connection::
    preCellId ()
    {
      return this->preCellId_;
    }

    void Connection::
    setPreCellId (const PreCellIdType& x)
    {
      this->preCellId_.set (x);
    }

    void Connection::
    setPreCellId (const PreCellIdOptional& x)
    {
      this->preCellId_ = x;
    }

    void Connection::
    setPreCellId (::std::unique_ptr< PreCellIdType > x)
    {
      this->preCellId_.set (std::move (x));
    }

    const Connection::PreSegmentIdOptional& Connection::
    preSegmentId () const
    {
      return this->preSegmentId_;
    }

    Connection::PreSegmentIdOptional& Connection::
    preSegmentId ()
    {
      return this->preSegmentId_;
    }

    void Connection::
    setPreSegmentId (const PreSegmentIdType& x)
    {
      this->preSegmentId_.set (x);
    }

    void Connection::
    setPreSegmentId (const PreSegmentIdOptional& x)
    {
      this->preSegmentId_ = x;
    }

    void Connection::
    setPreSegmentId (::std::unique_ptr< PreSegmentIdType > x)
    {
      this->preSegmentId_.set (std::move (x));
    }

    const Connection::PreFractionAlongOptional& Connection::
    preFractionAlong () const
    {
      return this->preFractionAlong_;
    }

    Connection::PreFractionAlongOptional& Connection::
    preFractionAlong ()
    {
      return this->preFractionAlong_;
    }

    void Connection::
    setPreFractionAlong (const PreFractionAlongType& x)
    {
      this->preFractionAlong_.set (x);
    }

    void Connection::
    setPreFractionAlong (const PreFractionAlongOptional& x)
    {
      this->preFractionAlong_ = x;
    }

    void Connection::
    setPreFractionAlong (::std::unique_ptr< PreFractionAlongType > x)
    {
      this->preFractionAlong_.set (std::move (x));
    }

    const Connection::PostCellIdOptional& Connection::
    postCellId () const
    {
      return this->postCellId_;
    }

    Connection::PostCellIdOptional& Connection::
    postCellId ()
    {
      return this->postCellId_;
    }

    void Connection::
    setPostCellId (const PostCellIdType& x)
    {
      this->postCellId_.set (x);
    }

    void Connection::
    setPostCellId (const PostCellIdOptional& x)
    {
      this->postCellId_ = x;
    }

    void Connection::
    setPostCellId (::std::unique_ptr< PostCellIdType > x)
    {
      this->postCellId_.set (std::move (x));
    }

    const Connection::PostSegmentIdOptional& Connection::
    postSegmentId () const
    {
      return this->postSegmentId_;
    }

    Connection::PostSegmentIdOptional& Connection::
    postSegmentId ()
    {
      return this->postSegmentId_;
    }

    void Connection::
    setPostSegmentId (const PostSegmentIdType& x)
    {
      this->postSegmentId_.set (x);
    }

    void Connection::
    setPostSegmentId (const PostSegmentIdOptional& x)
    {
      this->postSegmentId_ = x;
    }

    void Connection::
    setPostSegmentId (::std::unique_ptr< PostSegmentIdType > x)
    {
      this->postSegmentId_.set (std::move (x));
    }

    const Connection::PostFractionAlongOptional& Connection::
    postFractionAlong () const
    {
      return this->postFractionAlong_;
    }

    Connection::PostFractionAlongOptional& Connection::
    postFractionAlong ()
    {
      return this->postFractionAlong_;
    }

    void Connection::
    setPostFractionAlong (const PostFractionAlongType& x)
    {
      this->postFractionAlong_.set (x);
    }

    void Connection::
    setPostFractionAlong (const PostFractionAlongOptional& x)
    {
      this->postFractionAlong_ = x;
    }

    void Connection::
    setPostFractionAlong (::std::unique_ptr< PostFractionAlongType > x)
    {
      this->postFractionAlong_.set (std::move (x));
    }


    // ExplicitInput
    // 

    const ExplicitInput::TargetOptional& ExplicitInput::
    target () const
    {
      return this->target_;
    }

    ExplicitInput::TargetOptional& ExplicitInput::
    target ()
    {
      return this->target_;
    }

    void ExplicitInput::
    setTarget (const TargetType& x)
    {
      this->target_.set (x);
    }

    void ExplicitInput::
    setTarget (const TargetOptional& x)
    {
      this->target_ = x;
    }

    void ExplicitInput::
    setTarget (::std::unique_ptr< TargetType > x)
    {
      this->target_.set (std::move (x));
    }

    const ExplicitInput::InputOptional& ExplicitInput::
    input () const
    {
      return this->input_;
    }

    ExplicitInput::InputOptional& ExplicitInput::
    input ()
    {
      return this->input_;
    }

    void ExplicitInput::
    setInput (const InputType& x)
    {
      this->input_.set (x);
    }

    void ExplicitInput::
    setInput (const InputOptional& x)
    {
      this->input_ = x;
    }

    void ExplicitInput::
    setInput (::std::unique_ptr< InputType > x)
    {
      this->input_.set (std::move (x));
    }

    const ExplicitInput::DestinationOptional& ExplicitInput::
    destination () const
    {
      return this->destination_;
    }

    ExplicitInput::DestinationOptional& ExplicitInput::
    destination ()
    {
      return this->destination_;
    }

    void ExplicitInput::
    setDestination (const DestinationType& x)
    {
      this->destination_.set (x);
    }

    void ExplicitInput::
    setDestination (const DestinationOptional& x)
    {
      this->destination_ = x;
    }

    void ExplicitInput::
    setDestination (::std::unique_ptr< DestinationType > x)
    {
      this->destination_.set (std::move (x));
    }


    // InputList
    // 

    const InputList::InputSequence& InputList::
    inputs () const
    {
      return this->input_;
    }

    InputList::InputSequence& InputList::
    inputs ()
    {
      return this->input_;
    }

    void InputList::
    setInputs (const InputSequence& s)
    {
      this->input_ = s;
    }

    const InputList::PopulationOptional& InputList::
    population () const
    {
      return this->population_;
    }

    InputList::PopulationOptional& InputList::
    population ()
    {
      return this->population_;
    }

    void InputList::
    setPopulation (const PopulationType& x)
    {
      this->population_.set (x);
    }

    void InputList::
    setPopulation (const PopulationOptional& x)
    {
      this->population_ = x;
    }

    void InputList::
    setPopulation (::std::unique_ptr< PopulationType > x)
    {
      this->population_.set (std::move (x));
    }

    const InputList::ComponentOptional& InputList::
    component () const
    {
      return this->component_;
    }

    InputList::ComponentOptional& InputList::
    component ()
    {
      return this->component_;
    }

    void InputList::
    setComponent (const ComponentType& x)
    {
      this->component_.set (x);
    }

    void InputList::
    setComponent (const ComponentOptional& x)
    {
      this->component_ = x;
    }

    void InputList::
    setComponent (::std::unique_ptr< ComponentType > x)
    {
      this->component_.set (std::move (x));
    }


    // Input
    // 

    const Input::IdOptional& Input::
    id () const
    {
      return this->id_;
    }

    Input::IdOptional& Input::
    id ()
    {
      return this->id_;
    }

    void Input::
    setId (const IdType& x)
    {
      this->id_.set (x);
    }

    void Input::
    setId (const IdOptional& x)
    {
      this->id_ = x;
    }

    const Input::TargetOptional& Input::
    target () const
    {
      return this->target_;
    }

    Input::TargetOptional& Input::
    target ()
    {
      return this->target_;
    }

    void Input::
    setTarget (const TargetType& x)
    {
      this->target_.set (x);
    }

    void Input::
    setTarget (const TargetOptional& x)
    {
      this->target_ = x;
    }

    void Input::
    setTarget (::std::unique_ptr< TargetType > x)
    {
      this->target_.set (std::move (x));
    }

    const Input::DestinationOptional& Input::
    destination () const
    {
      return this->destination_;
    }

    Input::DestinationOptional& Input::
    destination ()
    {
      return this->destination_;
    }

    void Input::
    setDestination (const DestinationType& x)
    {
      this->destination_.set (x);
    }

    void Input::
    setDestination (const DestinationOptional& x)
    {
      this->destination_ = x;
    }

    void Input::
    setDestination (::std::unique_ptr< DestinationType > x)
    {
      this->destination_.set (std::move (x));
    }

    const Input::SegmentIdOptional& Input::
    segmentId () const
    {
      return this->segmentId_;
    }

    Input::SegmentIdOptional& Input::
    segmentId ()
    {
      return this->segmentId_;
    }

    void Input::
    setSegmentId (const SegmentIdType& x)
    {
      this->segmentId_.set (x);
    }

    void Input::
    setSegmentId (const SegmentIdOptional& x)
    {
      this->segmentId_ = x;
    }

    void Input::
    setSegmentId (::std::unique_ptr< SegmentIdType > x)
    {
      this->segmentId_.set (std::move (x));
    }

    const Input::FractionAlongOptional& Input::
    fractionAlong () const
    {
      return this->fractionAlong_;
    }

    Input::FractionAlongOptional& Input::
    fractionAlong ()
    {
      return this->fractionAlong_;
    }

    void Input::
    setFractionAlong (const FractionAlongType& x)
    {
      this->fractionAlong_.set (x);
    }

    void Input::
    setFractionAlong (const FractionAlongOptional& x)
    {
      this->fractionAlong_ = x;
    }

    void Input::
    setFractionAlong (::std::unique_ptr< FractionAlongType > x)
    {
      this->fractionAlong_.set (std::move (x));
    }


    // BasePyNNCell
    // 

    const BasePyNNCell::CmOptional& BasePyNNCell::
    cm () const
    {
      return this->cm_;
    }

    BasePyNNCell::CmOptional& BasePyNNCell::
    cm ()
    {
      return this->cm_;
    }

    void BasePyNNCell::
    setCm (const CmType& x)
    {
      this->cm_.set (x);
    }

    void BasePyNNCell::
    setCm (const CmOptional& x)
    {
      this->cm_ = x;
    }

    const BasePyNNCell::I_offsetOptional& BasePyNNCell::
    i_offset () const
    {
      return this->i_offset_;
    }

    BasePyNNCell::I_offsetOptional& BasePyNNCell::
    i_offset ()
    {
      return this->i_offset_;
    }

    void BasePyNNCell::
    setI_offset (const I_offsetType& x)
    {
      this->i_offset_.set (x);
    }

    void BasePyNNCell::
    setI_offset (const I_offsetOptional& x)
    {
      this->i_offset_ = x;
    }

    const BasePyNNCell::Tau_syn_EOptional& BasePyNNCell::
    tau_syn_E () const
    {
      return this->tau_syn_E_;
    }

    BasePyNNCell::Tau_syn_EOptional& BasePyNNCell::
    tau_syn_E ()
    {
      return this->tau_syn_E_;
    }

    void BasePyNNCell::
    setTau_syn_E (const Tau_syn_EType& x)
    {
      this->tau_syn_E_.set (x);
    }

    void BasePyNNCell::
    setTau_syn_E (const Tau_syn_EOptional& x)
    {
      this->tau_syn_E_ = x;
    }

    const BasePyNNCell::Tau_syn_IOptional& BasePyNNCell::
    tau_syn_I () const
    {
      return this->tau_syn_I_;
    }

    BasePyNNCell::Tau_syn_IOptional& BasePyNNCell::
    tau_syn_I ()
    {
      return this->tau_syn_I_;
    }

    void BasePyNNCell::
    setTau_syn_I (const Tau_syn_IType& x)
    {
      this->tau_syn_I_.set (x);
    }

    void BasePyNNCell::
    setTau_syn_I (const Tau_syn_IOptional& x)
    {
      this->tau_syn_I_ = x;
    }

    const BasePyNNCell::V_initOptional& BasePyNNCell::
    v_init () const
    {
      return this->v_init_;
    }

    BasePyNNCell::V_initOptional& BasePyNNCell::
    v_init ()
    {
      return this->v_init_;
    }

    void BasePyNNCell::
    setV_init (const V_initType& x)
    {
      this->v_init_.set (x);
    }

    void BasePyNNCell::
    setV_init (const V_initOptional& x)
    {
      this->v_init_ = x;
    }


    // BasePyNNIaFCell
    // 

    const BasePyNNIaFCell::Tau_mOptional& BasePyNNIaFCell::
    tau_m () const
    {
      return this->tau_m_;
    }

    BasePyNNIaFCell::Tau_mOptional& BasePyNNIaFCell::
    tau_m ()
    {
      return this->tau_m_;
    }

    void BasePyNNIaFCell::
    setTau_m (const Tau_mType& x)
    {
      this->tau_m_.set (x);
    }

    void BasePyNNIaFCell::
    setTau_m (const Tau_mOptional& x)
    {
      this->tau_m_ = x;
    }

    const BasePyNNIaFCell::Tau_refracOptional& BasePyNNIaFCell::
    tau_refrac () const
    {
      return this->tau_refrac_;
    }

    BasePyNNIaFCell::Tau_refracOptional& BasePyNNIaFCell::
    tau_refrac ()
    {
      return this->tau_refrac_;
    }

    void BasePyNNIaFCell::
    setTau_refrac (const Tau_refracType& x)
    {
      this->tau_refrac_.set (x);
    }

    void BasePyNNIaFCell::
    setTau_refrac (const Tau_refracOptional& x)
    {
      this->tau_refrac_ = x;
    }

    const BasePyNNIaFCell::V_resetOptional& BasePyNNIaFCell::
    v_reset () const
    {
      return this->v_reset_;
    }

    BasePyNNIaFCell::V_resetOptional& BasePyNNIaFCell::
    v_reset ()
    {
      return this->v_reset_;
    }

    void BasePyNNIaFCell::
    setV_reset (const V_resetType& x)
    {
      this->v_reset_.set (x);
    }

    void BasePyNNIaFCell::
    setV_reset (const V_resetOptional& x)
    {
      this->v_reset_ = x;
    }

    const BasePyNNIaFCell::V_restOptional& BasePyNNIaFCell::
    v_rest () const
    {
      return this->v_rest_;
    }

    BasePyNNIaFCell::V_restOptional& BasePyNNIaFCell::
    v_rest ()
    {
      return this->v_rest_;
    }

    void BasePyNNIaFCell::
    setV_rest (const V_restType& x)
    {
      this->v_rest_.set (x);
    }

    void BasePyNNIaFCell::
    setV_rest (const V_restOptional& x)
    {
      this->v_rest_ = x;
    }

    const BasePyNNIaFCell::V_threshOptional& BasePyNNIaFCell::
    v_thresh () const
    {
      return this->v_thresh_;
    }

    BasePyNNIaFCell::V_threshOptional& BasePyNNIaFCell::
    v_thresh ()
    {
      return this->v_thresh_;
    }

    void BasePyNNIaFCell::
    setV_thresh (const V_threshType& x)
    {
      this->v_thresh_.set (x);
    }

    void BasePyNNIaFCell::
    setV_thresh (const V_threshOptional& x)
    {
      this->v_thresh_ = x;
    }


    // BasePyNNIaFCondCell
    // 

    const BasePyNNIaFCondCell::E_rev_EOptional& BasePyNNIaFCondCell::
    e_rev_E () const
    {
      return this->e_rev_E_;
    }

    BasePyNNIaFCondCell::E_rev_EOptional& BasePyNNIaFCondCell::
    e_rev_E ()
    {
      return this->e_rev_E_;
    }

    void BasePyNNIaFCondCell::
    setE_rev_E (const E_rev_EType& x)
    {
      this->e_rev_E_.set (x);
    }

    void BasePyNNIaFCondCell::
    setE_rev_E (const E_rev_EOptional& x)
    {
      this->e_rev_E_ = x;
    }

    const BasePyNNIaFCondCell::E_rev_IOptional& BasePyNNIaFCondCell::
    e_rev_I () const
    {
      return this->e_rev_I_;
    }

    BasePyNNIaFCondCell::E_rev_IOptional& BasePyNNIaFCondCell::
    e_rev_I ()
    {
      return this->e_rev_I_;
    }

    void BasePyNNIaFCondCell::
    setE_rev_I (const E_rev_IType& x)
    {
      this->e_rev_I_.set (x);
    }

    void BasePyNNIaFCondCell::
    setE_rev_I (const E_rev_IOptional& x)
    {
      this->e_rev_I_ = x;
    }


    // IF_curr_alpha
    // 


    // IF_curr_exp
    // 


    // IF_cond_alpha
    // 


    // IF_cond_exp
    // 


    // EIF_cond_exp_isfa_ista
    // 

    const EIF_cond_exp_isfa_ista::AOptional& EIF_cond_exp_isfa_ista::
    a () const
    {
      return this->a_;
    }

    EIF_cond_exp_isfa_ista::AOptional& EIF_cond_exp_isfa_ista::
    a ()
    {
      return this->a_;
    }

    void EIF_cond_exp_isfa_ista::
    setA (const AType& x)
    {
      this->a_.set (x);
    }

    void EIF_cond_exp_isfa_ista::
    setA (const AOptional& x)
    {
      this->a_ = x;
    }

    const EIF_cond_exp_isfa_ista::BOptional& EIF_cond_exp_isfa_ista::
    b () const
    {
      return this->b_;
    }

    EIF_cond_exp_isfa_ista::BOptional& EIF_cond_exp_isfa_ista::
    b ()
    {
      return this->b_;
    }

    void EIF_cond_exp_isfa_ista::
    setB (const BType& x)
    {
      this->b_.set (x);
    }

    void EIF_cond_exp_isfa_ista::
    setB (const BOptional& x)
    {
      this->b_ = x;
    }

    const EIF_cond_exp_isfa_ista::Delta_TOptional& EIF_cond_exp_isfa_ista::
    delta_T () const
    {
      return this->delta_T_;
    }

    EIF_cond_exp_isfa_ista::Delta_TOptional& EIF_cond_exp_isfa_ista::
    delta_T ()
    {
      return this->delta_T_;
    }

    void EIF_cond_exp_isfa_ista::
    setDelta_T (const Delta_TType& x)
    {
      this->delta_T_.set (x);
    }

    void EIF_cond_exp_isfa_ista::
    setDelta_T (const Delta_TOptional& x)
    {
      this->delta_T_ = x;
    }

    const EIF_cond_exp_isfa_ista::Tau_wOptional& EIF_cond_exp_isfa_ista::
    tau_w () const
    {
      return this->tau_w_;
    }

    EIF_cond_exp_isfa_ista::Tau_wOptional& EIF_cond_exp_isfa_ista::
    tau_w ()
    {
      return this->tau_w_;
    }

    void EIF_cond_exp_isfa_ista::
    setTau_w (const Tau_wType& x)
    {
      this->tau_w_.set (x);
    }

    void EIF_cond_exp_isfa_ista::
    setTau_w (const Tau_wOptional& x)
    {
      this->tau_w_ = x;
    }

    const EIF_cond_exp_isfa_ista::V_spikeOptional& EIF_cond_exp_isfa_ista::
    v_spike () const
    {
      return this->v_spike_;
    }

    EIF_cond_exp_isfa_ista::V_spikeOptional& EIF_cond_exp_isfa_ista::
    v_spike ()
    {
      return this->v_spike_;
    }

    void EIF_cond_exp_isfa_ista::
    setV_spike (const V_spikeType& x)
    {
      this->v_spike_.set (x);
    }

    void EIF_cond_exp_isfa_ista::
    setV_spike (const V_spikeOptional& x)
    {
      this->v_spike_ = x;
    }


    // EIF_cond_alpha_isfa_ista
    // 

    const EIF_cond_alpha_isfa_ista::AOptional& EIF_cond_alpha_isfa_ista::
    a () const
    {
      return this->a_;
    }

    EIF_cond_alpha_isfa_ista::AOptional& EIF_cond_alpha_isfa_ista::
    a ()
    {
      return this->a_;
    }

    void EIF_cond_alpha_isfa_ista::
    setA (const AType& x)
    {
      this->a_.set (x);
    }

    void EIF_cond_alpha_isfa_ista::
    setA (const AOptional& x)
    {
      this->a_ = x;
    }

    const EIF_cond_alpha_isfa_ista::BOptional& EIF_cond_alpha_isfa_ista::
    b () const
    {
      return this->b_;
    }

    EIF_cond_alpha_isfa_ista::BOptional& EIF_cond_alpha_isfa_ista::
    b ()
    {
      return this->b_;
    }

    void EIF_cond_alpha_isfa_ista::
    setB (const BType& x)
    {
      this->b_.set (x);
    }

    void EIF_cond_alpha_isfa_ista::
    setB (const BOptional& x)
    {
      this->b_ = x;
    }

    const EIF_cond_alpha_isfa_ista::Delta_TOptional& EIF_cond_alpha_isfa_ista::
    delta_T () const
    {
      return this->delta_T_;
    }

    EIF_cond_alpha_isfa_ista::Delta_TOptional& EIF_cond_alpha_isfa_ista::
    delta_T ()
    {
      return this->delta_T_;
    }

    void EIF_cond_alpha_isfa_ista::
    setDelta_T (const Delta_TType& x)
    {
      this->delta_T_.set (x);
    }

    void EIF_cond_alpha_isfa_ista::
    setDelta_T (const Delta_TOptional& x)
    {
      this->delta_T_ = x;
    }

    const EIF_cond_alpha_isfa_ista::Tau_wOptional& EIF_cond_alpha_isfa_ista::
    tau_w () const
    {
      return this->tau_w_;
    }

    EIF_cond_alpha_isfa_ista::Tau_wOptional& EIF_cond_alpha_isfa_ista::
    tau_w ()
    {
      return this->tau_w_;
    }

    void EIF_cond_alpha_isfa_ista::
    setTau_w (const Tau_wType& x)
    {
      this->tau_w_.set (x);
    }

    void EIF_cond_alpha_isfa_ista::
    setTau_w (const Tau_wOptional& x)
    {
      this->tau_w_ = x;
    }

    const EIF_cond_alpha_isfa_ista::V_spikeOptional& EIF_cond_alpha_isfa_ista::
    v_spike () const
    {
      return this->v_spike_;
    }

    EIF_cond_alpha_isfa_ista::V_spikeOptional& EIF_cond_alpha_isfa_ista::
    v_spike ()
    {
      return this->v_spike_;
    }

    void EIF_cond_alpha_isfa_ista::
    setV_spike (const V_spikeType& x)
    {
      this->v_spike_.set (x);
    }

    void EIF_cond_alpha_isfa_ista::
    setV_spike (const V_spikeOptional& x)
    {
      this->v_spike_ = x;
    }


    // HH_cond_exp
    // 

    const HH_cond_exp::V_offsetOptional& HH_cond_exp::
    v_offset () const
    {
      return this->v_offset_;
    }

    HH_cond_exp::V_offsetOptional& HH_cond_exp::
    v_offset ()
    {
      return this->v_offset_;
    }

    void HH_cond_exp::
    setV_offset (const V_offsetType& x)
    {
      this->v_offset_.set (x);
    }

    void HH_cond_exp::
    setV_offset (const V_offsetOptional& x)
    {
      this->v_offset_ = x;
    }

    const HH_cond_exp::E_rev_EOptional& HH_cond_exp::
    e_rev_E () const
    {
      return this->e_rev_E_;
    }

    HH_cond_exp::E_rev_EOptional& HH_cond_exp::
    e_rev_E ()
    {
      return this->e_rev_E_;
    }

    void HH_cond_exp::
    setE_rev_E (const E_rev_EType& x)
    {
      this->e_rev_E_.set (x);
    }

    void HH_cond_exp::
    setE_rev_E (const E_rev_EOptional& x)
    {
      this->e_rev_E_ = x;
    }

    const HH_cond_exp::E_rev_IOptional& HH_cond_exp::
    e_rev_I () const
    {
      return this->e_rev_I_;
    }

    HH_cond_exp::E_rev_IOptional& HH_cond_exp::
    e_rev_I ()
    {
      return this->e_rev_I_;
    }

    void HH_cond_exp::
    setE_rev_I (const E_rev_IType& x)
    {
      this->e_rev_I_.set (x);
    }

    void HH_cond_exp::
    setE_rev_I (const E_rev_IOptional& x)
    {
      this->e_rev_I_ = x;
    }

    const HH_cond_exp::E_rev_KOptional& HH_cond_exp::
    e_rev_K () const
    {
      return this->e_rev_K_;
    }

    HH_cond_exp::E_rev_KOptional& HH_cond_exp::
    e_rev_K ()
    {
      return this->e_rev_K_;
    }

    void HH_cond_exp::
    setE_rev_K (const E_rev_KType& x)
    {
      this->e_rev_K_.set (x);
    }

    void HH_cond_exp::
    setE_rev_K (const E_rev_KOptional& x)
    {
      this->e_rev_K_ = x;
    }

    const HH_cond_exp::E_rev_NaOptional& HH_cond_exp::
    e_rev_Na () const
    {
      return this->e_rev_Na_;
    }

    HH_cond_exp::E_rev_NaOptional& HH_cond_exp::
    e_rev_Na ()
    {
      return this->e_rev_Na_;
    }

    void HH_cond_exp::
    setE_rev_Na (const E_rev_NaType& x)
    {
      this->e_rev_Na_.set (x);
    }

    void HH_cond_exp::
    setE_rev_Na (const E_rev_NaOptional& x)
    {
      this->e_rev_Na_ = x;
    }

    const HH_cond_exp::E_rev_leakOptional& HH_cond_exp::
    e_rev_leak () const
    {
      return this->e_rev_leak_;
    }

    HH_cond_exp::E_rev_leakOptional& HH_cond_exp::
    e_rev_leak ()
    {
      return this->e_rev_leak_;
    }

    void HH_cond_exp::
    setE_rev_leak (const E_rev_leakType& x)
    {
      this->e_rev_leak_.set (x);
    }

    void HH_cond_exp::
    setE_rev_leak (const E_rev_leakOptional& x)
    {
      this->e_rev_leak_ = x;
    }

    const HH_cond_exp::G_leakOptional& HH_cond_exp::
    g_leak () const
    {
      return this->g_leak_;
    }

    HH_cond_exp::G_leakOptional& HH_cond_exp::
    g_leak ()
    {
      return this->g_leak_;
    }

    void HH_cond_exp::
    setG_leak (const G_leakType& x)
    {
      this->g_leak_.set (x);
    }

    void HH_cond_exp::
    setG_leak (const G_leakOptional& x)
    {
      this->g_leak_ = x;
    }

    const HH_cond_exp::Gbar_KOptional& HH_cond_exp::
    gbar_K () const
    {
      return this->gbar_K_;
    }

    HH_cond_exp::Gbar_KOptional& HH_cond_exp::
    gbar_K ()
    {
      return this->gbar_K_;
    }

    void HH_cond_exp::
    setGbar_K (const Gbar_KType& x)
    {
      this->gbar_K_.set (x);
    }

    void HH_cond_exp::
    setGbar_K (const Gbar_KOptional& x)
    {
      this->gbar_K_ = x;
    }

    const HH_cond_exp::Gbar_NaOptional& HH_cond_exp::
    gbar_Na () const
    {
      return this->gbar_Na_;
    }

    HH_cond_exp::Gbar_NaOptional& HH_cond_exp::
    gbar_Na ()
    {
      return this->gbar_Na_;
    }

    void HH_cond_exp::
    setGbar_Na (const Gbar_NaType& x)
    {
      this->gbar_Na_.set (x);
    }

    void HH_cond_exp::
    setGbar_Na (const Gbar_NaOptional& x)
    {
      this->gbar_Na_ = x;
    }


    // BasePynnSynapse
    // 

    const BasePynnSynapse::Tau_synOptional& BasePynnSynapse::
    tau_syn () const
    {
      return this->tau_syn_;
    }

    BasePynnSynapse::Tau_synOptional& BasePynnSynapse::
    tau_syn ()
    {
      return this->tau_syn_;
    }

    void BasePynnSynapse::
    setTau_syn (const Tau_synType& x)
    {
      this->tau_syn_.set (x);
    }

    void BasePynnSynapse::
    setTau_syn (const Tau_synOptional& x)
    {
      this->tau_syn_ = x;
    }


    // ExpCondSynapse
    // 

    const ExpCondSynapse::E_revOptional& ExpCondSynapse::
    e_rev () const
    {
      return this->e_rev_;
    }

    ExpCondSynapse::E_revOptional& ExpCondSynapse::
    e_rev ()
    {
      return this->e_rev_;
    }

    void ExpCondSynapse::
    setE_rev (const E_revType& x)
    {
      this->e_rev_.set (x);
    }

    void ExpCondSynapse::
    setE_rev (const E_revOptional& x)
    {
      this->e_rev_ = x;
    }


    // AlphaCondSynapse
    // 

    const AlphaCondSynapse::E_revOptional& AlphaCondSynapse::
    e_rev () const
    {
      return this->e_rev_;
    }

    AlphaCondSynapse::E_revOptional& AlphaCondSynapse::
    e_rev ()
    {
      return this->e_rev_;
    }

    void AlphaCondSynapse::
    setE_rev (const E_revType& x)
    {
      this->e_rev_.set (x);
    }

    void AlphaCondSynapse::
    setE_rev (const E_revOptional& x)
    {
      this->e_rev_ = x;
    }


    // ExpCurrSynapse
    // 


    // AlphaCurrSynapse
    // 


    // SpikeSourcePoisson
    // 

    const SpikeSourcePoisson::StartType& SpikeSourcePoisson::
    start () const
    {
      return this->start_.get ();
    }

    SpikeSourcePoisson::StartType& SpikeSourcePoisson::
    start ()
    {
      return this->start_.get ();
    }

    void SpikeSourcePoisson::
    setStart (const StartType& x)
    {
      this->start_.set (x);
    }

    void SpikeSourcePoisson::
    setStart (::std::unique_ptr< StartType > x)
    {
      this->start_.set (std::move (x));
    }

    const SpikeSourcePoisson::DurationType& SpikeSourcePoisson::
    duration () const
    {
      return this->duration_.get ();
    }

    SpikeSourcePoisson::DurationType& SpikeSourcePoisson::
    duration ()
    {
      return this->duration_.get ();
    }

    void SpikeSourcePoisson::
    setDuration (const DurationType& x)
    {
      this->duration_.set (x);
    }

    void SpikeSourcePoisson::
    setDuration (::std::unique_ptr< DurationType > x)
    {
      this->duration_.set (std::move (x));
    }

    const SpikeSourcePoisson::RateType& SpikeSourcePoisson::
    rate () const
    {
      return this->rate_.get ();
    }

    SpikeSourcePoisson::RateType& SpikeSourcePoisson::
    rate ()
    {
      return this->rate_.get ();
    }

    void SpikeSourcePoisson::
    setRate (const RateType& x)
    {
      this->rate_.set (x);
    }

    void SpikeSourcePoisson::
    setRate (::std::unique_ptr< RateType > x)
    {
      this->rate_.set (std::move (x));
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace neurona
{
  namespace schema
  {
    // NmlId
    //

    NmlId::
    NmlId ()
    : ::xml_schema::String ()
    {
    }

    NmlId::
    NmlId (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NmlId::
    NmlId (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NmlId::
    NmlId (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NmlId::
    NmlId (const NmlId& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    NmlId::
    NmlId (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    NmlId::
    NmlId (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    NmlId::
    NmlId (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    NmlId* NmlId::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NmlId (*this, f, c);
    }

    NmlId::
    ~NmlId ()
    {
    }

    // Nml2Quantity
    //

    Nml2Quantity::
    Nml2Quantity ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity::
    Nml2Quantity (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity::
    Nml2Quantity (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity::
    Nml2Quantity (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity::
    Nml2Quantity (const Nml2Quantity& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity::
    Nml2Quantity (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity::
    Nml2Quantity (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity::
    Nml2Quantity (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity* Nml2Quantity::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity (*this, f, c);
    }

    Nml2Quantity::
    ~Nml2Quantity ()
    {
    }

    // Nml2Quantity_none
    //

    Nml2Quantity_none::
    Nml2Quantity_none ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const Nml2Quantity_none& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_none::
    Nml2Quantity_none (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_none* Nml2Quantity_none::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_none (*this, f, c);
    }

    Nml2Quantity_none::
    ~Nml2Quantity_none ()
    {
    }

    // Nml2Quantity_voltage
    //

    Nml2Quantity_voltage::
    Nml2Quantity_voltage ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const Nml2Quantity_voltage& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_voltage::
    Nml2Quantity_voltage (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_voltage* Nml2Quantity_voltage::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_voltage (*this, f, c);
    }

    Nml2Quantity_voltage::
    ~Nml2Quantity_voltage ()
    {
    }

    // Nml2Quantity_length
    //

    Nml2Quantity_length::
    Nml2Quantity_length ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const Nml2Quantity_length& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_length::
    Nml2Quantity_length (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_length* Nml2Quantity_length::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_length (*this, f, c);
    }

    Nml2Quantity_length::
    ~Nml2Quantity_length ()
    {
    }

    // Nml2Quantity_resistance
    //

    Nml2Quantity_resistance::
    Nml2Quantity_resistance ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const Nml2Quantity_resistance& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_resistance::
    Nml2Quantity_resistance (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_resistance* Nml2Quantity_resistance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_resistance (*this, f, c);
    }

    Nml2Quantity_resistance::
    ~Nml2Quantity_resistance ()
    {
    }

    // Nml2Quantity_conductance
    //

    Nml2Quantity_conductance::
    Nml2Quantity_conductance ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const Nml2Quantity_conductance& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_conductance::
    Nml2Quantity_conductance (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_conductance* Nml2Quantity_conductance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_conductance (*this, f, c);
    }

    Nml2Quantity_conductance::
    ~Nml2Quantity_conductance ()
    {
    }

    // Nml2Quantity_conductanceDensity
    //

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const Nml2Quantity_conductanceDensity& x,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const ::xercesc::DOMElement& e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_conductanceDensity::
    Nml2Quantity_conductanceDensity (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::Flags f,
                                     ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_conductanceDensity* Nml2Quantity_conductanceDensity::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_conductanceDensity (*this, f, c);
    }

    Nml2Quantity_conductanceDensity::
    ~Nml2Quantity_conductanceDensity ()
    {
    }

    // Nml2Quantity_permeability
    //

    Nml2Quantity_permeability::
    Nml2Quantity_permeability ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const Nml2Quantity_permeability& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_permeability::
    Nml2Quantity_permeability (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_permeability* Nml2Quantity_permeability::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_permeability (*this, f, c);
    }

    Nml2Quantity_permeability::
    ~Nml2Quantity_permeability ()
    {
    }

    // Nml2Quantity_time
    //

    Nml2Quantity_time::
    Nml2Quantity_time ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const Nml2Quantity_time& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_time::
    Nml2Quantity_time (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_time* Nml2Quantity_time::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_time (*this, f, c);
    }

    Nml2Quantity_time::
    ~Nml2Quantity_time ()
    {
    }

    // Nml2Quantity_pertime
    //

    Nml2Quantity_pertime::
    Nml2Quantity_pertime ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const Nml2Quantity_pertime& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_pertime::
    Nml2Quantity_pertime (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_pertime* Nml2Quantity_pertime::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_pertime (*this, f, c);
    }

    Nml2Quantity_pertime::
    ~Nml2Quantity_pertime ()
    {
    }

    // Nml2Quantity_capacitance
    //

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const Nml2Quantity_capacitance& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_capacitance::
    Nml2Quantity_capacitance (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_capacitance* Nml2Quantity_capacitance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_capacitance (*this, f, c);
    }

    Nml2Quantity_capacitance::
    ~Nml2Quantity_capacitance ()
    {
    }

    // Nml2Quantity_specificCapacitance
    //

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const Nml2Quantity_specificCapacitance& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_specificCapacitance::
    Nml2Quantity_specificCapacitance (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_specificCapacitance* Nml2Quantity_specificCapacitance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_specificCapacitance (*this, f, c);
    }

    Nml2Quantity_specificCapacitance::
    ~Nml2Quantity_specificCapacitance ()
    {
    }

    // Nml2Quantity_concentration
    //

    Nml2Quantity_concentration::
    Nml2Quantity_concentration ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const Nml2Quantity_concentration& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const ::xercesc::DOMAttr& a,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_concentration::
    Nml2Quantity_concentration (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_concentration* Nml2Quantity_concentration::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_concentration (*this, f, c);
    }

    Nml2Quantity_concentration::
    ~Nml2Quantity_concentration ()
    {
    }

    // Nml2Quantity_current
    //

    Nml2Quantity_current::
    Nml2Quantity_current ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const Nml2Quantity_current& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_current::
    Nml2Quantity_current (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_current* Nml2Quantity_current::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_current (*this, f, c);
    }

    Nml2Quantity_current::
    ~Nml2Quantity_current ()
    {
    }

    // Nml2Quantity_temperature
    //

    Nml2Quantity_temperature::
    Nml2Quantity_temperature ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const Nml2Quantity_temperature& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const ::xercesc::DOMAttr& a,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_temperature::
    Nml2Quantity_temperature (const ::std::string& s,
                              const ::xercesc::DOMElement* e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_temperature* Nml2Quantity_temperature::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_temperature (*this, f, c);
    }

    Nml2Quantity_temperature::
    ~Nml2Quantity_temperature ()
    {
    }

    // Nml2Quantity_rhoFactor
    //

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor ()
    : ::xml_schema::String ()
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const Nml2Quantity_rhoFactor& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const ::xercesc::DOMAttr& a,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Nml2Quantity_rhoFactor::
    Nml2Quantity_rhoFactor (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Nml2Quantity_rhoFactor* Nml2Quantity_rhoFactor::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Nml2Quantity_rhoFactor (*this, f, c);
    }

    Nml2Quantity_rhoFactor::
    ~Nml2Quantity_rhoFactor ()
    {
    }

    // MetaId
    //

    MetaId::
    MetaId ()
    : ::xml_schema::String ()
    {
    }

    MetaId::
    MetaId (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetaId::
    MetaId (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetaId::
    MetaId (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    MetaId::
    MetaId (const MetaId& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    MetaId::
    MetaId (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    MetaId::
    MetaId (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    MetaId::
    MetaId (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    MetaId* MetaId::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MetaId (*this, f, c);
    }

    MetaId::
    ~MetaId ()
    {
    }

    // NeuroLexId
    //

    NeuroLexId::
    NeuroLexId ()
    : ::xml_schema::String ()
    {
    }

    NeuroLexId::
    NeuroLexId (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NeuroLexId::
    NeuroLexId (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NeuroLexId::
    NeuroLexId (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    NeuroLexId::
    NeuroLexId (const NeuroLexId& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    NeuroLexId::
    NeuroLexId (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    NeuroLexId::
    NeuroLexId (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    NeuroLexId::
    NeuroLexId (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    NeuroLexId* NeuroLexId::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NeuroLexId (*this, f, c);
    }

    NeuroLexId::
    ~NeuroLexId ()
    {
    }

    // SegmentId
    //

    SegmentId::
    SegmentId (const ::xml_schema::NonNegativeInteger& _xsd_NonNegativeInteger_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType > (_xsd_NonNegativeInteger_base)
    {
    }

    SegmentId::
    SegmentId (const SegmentId& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType > (x, f, c)
    {
    }

    SegmentId::
    SegmentId (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType > (e, f, c)
    {
    }

    SegmentId::
    SegmentId (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType > (a, f, c)
    {
    }

    SegmentId::
    SegmentId (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType > (s, e, f, c)
    {
    }

    SegmentId* SegmentId::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SegmentId (*this, f, c);
    }

    SegmentId::
    ~SegmentId ()
    {
    }

    // Notes
    //

    Notes::
    Notes ()
    : ::xml_schema::String ()
    {
    }

    Notes::
    Notes (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Notes::
    Notes (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Notes::
    Notes (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    Notes::
    Notes (const Notes& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    Notes::
    Notes (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    Notes::
    Notes (const ::xercesc::DOMAttr& a,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    Notes::
    Notes (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    Notes* Notes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Notes (*this, f, c);
    }

    Notes::
    ~Notes ()
    {
    }

    // Property
    //

    Property::
    Property (const TagType& tag,
              const ValueType& value)
    : ::xml_schema::Type (),
      tag_ (tag, this),
      value_ (value, this)
    {
    }

    Property::
    Property (const Property& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      tag_ (x.tag_, f, this),
      value_ (x.value_, f, this)
    {
    }

    Property::
    Property (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      tag_ (this),
      value_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Property::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tag" && n.namespace_ ().empty ())
        {
          this->tag_.set (TagTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!tag_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tag",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    Property* Property::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Property (*this, f, c);
    }

    Property& Property::
    operator= (const Property& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->tag_ = x.tag_;
        this->value_ = x.value_;
      }

      return *this;
    }

    Property::
    ~Property ()
    {
    }

    // Annotation
    //

    Annotation::
    Annotation ()
    : ::xml_schema::Type ()
    {
    }

    Annotation::
    Annotation (const Annotation& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c)
    {
    }

    Annotation::
    Annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Annotation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }
    }

    Annotation* Annotation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Annotation (*this, f, c);
    }

    Annotation::
    ~Annotation ()
    {
    }

    // ComponentType
    //

    ComponentType::
    ComponentType (const NameType& name)
    : ::xml_schema::Type (),
      name_ (name, this),
      extends_ (this),
      description_ (this)
    {
    }

    ComponentType::
    ComponentType (const ComponentType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      name_ (x.name_, f, this),
      extends_ (x.extends_, f, this),
      description_ (x.description_, f, this)
    {
    }

    ComponentType::
    ComponentType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      name_ (this),
      extends_ (this),
      description_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComponentType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "extends" && n.namespace_ ().empty ())
        {
          this->extends_.set (ExtendsTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "description" && n.namespace_ ().empty ())
        {
          this->description_.set (DescriptionTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }
    }

    ComponentType* ComponentType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ComponentType (*this, f, c);
    }

    ComponentType& ComponentType::
    operator= (const ComponentType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->name_ = x.name_;
        this->extends_ = x.extends_;
        this->description_ = x.description_;
      }

      return *this;
    }

    ComponentType::
    ~ComponentType ()
    {
    }

    // ZeroToOne
    //

    ZeroToOne::
    ZeroToOne (const ::xml_schema::Double& _xsd_Double_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (_xsd_Double_base)
    {
    }

    ZeroToOne::
    ZeroToOne (const ZeroToOne& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
    {
    }

    ZeroToOne::
    ZeroToOne (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
    {
    }

    ZeroToOne::
    ZeroToOne (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
    {
    }

    ZeroToOne::
    ZeroToOne (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
    {
    }

    ZeroToOne* ZeroToOne::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ZeroToOne (*this, f, c);
    }

    ZeroToOne::
    ~ZeroToOne ()
    {
    }

    // BaseWithoutId
    //

    BaseWithoutId::
    BaseWithoutId ()
    : ::xml_schema::Type (),
      neuroLexId_ (this)
    {
    }

    BaseWithoutId::
    BaseWithoutId (const BaseWithoutId& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      neuroLexId_ (x.neuroLexId_, f, this)
    {
    }

    BaseWithoutId::
    BaseWithoutId (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      neuroLexId_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void BaseWithoutId::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "neuroLexId" && n.namespace_ ().empty ())
        {
          this->neuroLexId_.set (NeuroLexIdTraits::create (i, f, this));
          continue;
        }
      }
    }

    BaseWithoutId* BaseWithoutId::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BaseWithoutId (*this, f, c);
    }

    BaseWithoutId& BaseWithoutId::
    operator= (const BaseWithoutId& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->neuroLexId_ = x.neuroLexId_;
      }

      return *this;
    }

    BaseWithoutId::
    ~BaseWithoutId ()
    {
    }

    // Base
    //

    Base::
    Base (const IdType& id)
    : ::neurona::schema::BaseWithoutId (),
      id_ (id, this)
    {
    }

    Base::
    Base (const Base& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::neurona::schema::BaseWithoutId (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    Base::
    Base (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::neurona::schema::BaseWithoutId (e, f | ::xml_schema::Flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Base::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseWithoutId::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    Base* Base::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Base (*this, f, c);
    }

    Base& Base::
    operator= (const Base& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseWithoutId& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    Base::
    ~Base ()
    {
    }

    // Standalone
    //

    Standalone::
    Standalone (const IdType& id)
    : ::neurona::schema::Base (id),
      notes_ (this),
      annotation_ (this),
      metaid_ (this)
    {
    }

    Standalone::
    Standalone (const Standalone& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      annotation_ (x.annotation_, f, this),
      metaid_ (x.metaid_, f, this)
    {
    }

    Standalone::
    Standalone (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      annotation_ (this),
      metaid_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Standalone::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // annotation
        //
        if (n.name () == "annotation" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< AnnotationType > r (
            AnnotationTraits::create (i, f, this));

          if (!this->annotation_)
          {
            this->annotation_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "metaid" && n.namespace_ ().empty ())
        {
          this->metaid_.set (MetaidTraits::create (i, f, this));
          continue;
        }
      }
    }

    Standalone* Standalone::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Standalone (*this, f, c);
    }

    Standalone& Standalone::
    operator= (const Standalone& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->annotation_ = x.annotation_;
        this->metaid_ = x.metaid_;
      }

      return *this;
    }

    Standalone::
    ~Standalone ()
    {
    }

    // NeuroMLDocument
    //

    NeuroMLDocument::
    NeuroMLDocument (const IdType& id)
    : ::neurona::schema::Standalone (id),
      include_ (this),
      extracellularProperties_ (this),
      intracellularProperties_ (this),
      morphology_ (this),
      ionChannel_ (this),
      ionChannelHH_ (this),
      decayingPoolConcentrationModel_ (this),
      fixedFactorConcentrationModel_ (this),
      expOneSynapse_ (this),
      expTwoSynapse_ (this),
      blockingPlasticSynapse_ (this),
      biophysicalProperties_ (this),
      cell_ (this),
      baseCell_ (this),
      iafTauCell_ (this),
      iafTauRefCell_ (this),
      iafCell_ (this),
      iafRefCell_ (this),
      izhikevichCell_ (this),
      adExIaFCell_ (this),
      fitzHughNagumoCell_ (this),
      pulseGenerator_ (this),
      sineGenerator_ (this),
      rampGenerator_ (this),
      voltageClamp_ (this),
      spikeArray_ (this),
      spikeGenerator_ (this),
      spikeGeneratorRandom_ (this),
      spikeGeneratorPoisson_ (this),
      IF_curr_alpha_ (this),
      IF_curr_exp_ (this),
      IF_cond_alpha_ (this),
      IF_cond_exp_ (this),
      EIF_cond_exp_isfa_ista_ (this),
      EIF_cond_alpha_isfa_ista_ (this),
      HH_cond_exp_ (this),
      expCondSynapse_ (this),
      alphaCondSynapse_ (this),
      expCurrSynapse_ (this),
      alphaCurrSynapse_ (this),
      SpikeSourcePoisson_ (this),
      network_ (this),
      ComponentType_ (this)
    {
    }

    NeuroMLDocument::
    NeuroMLDocument (const NeuroMLDocument& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      include_ (x.include_, f, this),
      extracellularProperties_ (x.extracellularProperties_, f, this),
      intracellularProperties_ (x.intracellularProperties_, f, this),
      morphology_ (x.morphology_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      ionChannelHH_ (x.ionChannelHH_, f, this),
      decayingPoolConcentrationModel_ (x.decayingPoolConcentrationModel_, f, this),
      fixedFactorConcentrationModel_ (x.fixedFactorConcentrationModel_, f, this),
      expOneSynapse_ (x.expOneSynapse_, f, this),
      expTwoSynapse_ (x.expTwoSynapse_, f, this),
      blockingPlasticSynapse_ (x.blockingPlasticSynapse_, f, this),
      biophysicalProperties_ (x.biophysicalProperties_, f, this),
      cell_ (x.cell_, f, this),
      baseCell_ (x.baseCell_, f, this),
      iafTauCell_ (x.iafTauCell_, f, this),
      iafTauRefCell_ (x.iafTauRefCell_, f, this),
      iafCell_ (x.iafCell_, f, this),
      iafRefCell_ (x.iafRefCell_, f, this),
      izhikevichCell_ (x.izhikevichCell_, f, this),
      adExIaFCell_ (x.adExIaFCell_, f, this),
      fitzHughNagumoCell_ (x.fitzHughNagumoCell_, f, this),
      pulseGenerator_ (x.pulseGenerator_, f, this),
      sineGenerator_ (x.sineGenerator_, f, this),
      rampGenerator_ (x.rampGenerator_, f, this),
      voltageClamp_ (x.voltageClamp_, f, this),
      spikeArray_ (x.spikeArray_, f, this),
      spikeGenerator_ (x.spikeGenerator_, f, this),
      spikeGeneratorRandom_ (x.spikeGeneratorRandom_, f, this),
      spikeGeneratorPoisson_ (x.spikeGeneratorPoisson_, f, this),
      IF_curr_alpha_ (x.IF_curr_alpha_, f, this),
      IF_curr_exp_ (x.IF_curr_exp_, f, this),
      IF_cond_alpha_ (x.IF_cond_alpha_, f, this),
      IF_cond_exp_ (x.IF_cond_exp_, f, this),
      EIF_cond_exp_isfa_ista_ (x.EIF_cond_exp_isfa_ista_, f, this),
      EIF_cond_alpha_isfa_ista_ (x.EIF_cond_alpha_isfa_ista_, f, this),
      HH_cond_exp_ (x.HH_cond_exp_, f, this),
      expCondSynapse_ (x.expCondSynapse_, f, this),
      alphaCondSynapse_ (x.alphaCondSynapse_, f, this),
      expCurrSynapse_ (x.expCurrSynapse_, f, this),
      alphaCurrSynapse_ (x.alphaCurrSynapse_, f, this),
      SpikeSourcePoisson_ (x.SpikeSourcePoisson_, f, this),
      network_ (x.network_, f, this),
      ComponentType_ (x.ComponentType_, f, this)
    {
    }

    NeuroMLDocument::
    NeuroMLDocument (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      include_ (this),
      extracellularProperties_ (this),
      intracellularProperties_ (this),
      morphology_ (this),
      ionChannel_ (this),
      ionChannelHH_ (this),
      decayingPoolConcentrationModel_ (this),
      fixedFactorConcentrationModel_ (this),
      expOneSynapse_ (this),
      expTwoSynapse_ (this),
      blockingPlasticSynapse_ (this),
      biophysicalProperties_ (this),
      cell_ (this),
      baseCell_ (this),
      iafTauCell_ (this),
      iafTauRefCell_ (this),
      iafCell_ (this),
      iafRefCell_ (this),
      izhikevichCell_ (this),
      adExIaFCell_ (this),
      fitzHughNagumoCell_ (this),
      pulseGenerator_ (this),
      sineGenerator_ (this),
      rampGenerator_ (this),
      voltageClamp_ (this),
      spikeArray_ (this),
      spikeGenerator_ (this),
      spikeGeneratorRandom_ (this),
      spikeGeneratorPoisson_ (this),
      IF_curr_alpha_ (this),
      IF_curr_exp_ (this),
      IF_cond_alpha_ (this),
      IF_cond_exp_ (this),
      EIF_cond_exp_isfa_ista_ (this),
      EIF_cond_alpha_isfa_ista_ (this),
      HH_cond_exp_ (this),
      expCondSynapse_ (this),
      alphaCondSynapse_ (this),
      expCurrSynapse_ (this),
      alphaCurrSynapse_ (this),
      SpikeSourcePoisson_ (this),
      network_ (this),
      ComponentType_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void NeuroMLDocument::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // include
        //
        if (n.name () == "include" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IncludeType > r (
            IncludeTraits::create (i, f, this));

          this->include_.push_back (::std::move (r));
          continue;
        }

        // extracellularProperties
        //
        if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExtracellularPropertiesType > r (
            ExtracellularPropertiesTraits::create (i, f, this));

          this->extracellularProperties_.push_back (::std::move (r));
          continue;
        }

        // intracellularProperties
        //
        if (n.name () == "intracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IntracellularPropertiesType > r (
            IntracellularPropertiesTraits::create (i, f, this));

          this->intracellularProperties_.push_back (::std::move (r));
          continue;
        }

        // morphology
        //
        if (n.name () == "morphology" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< MorphologyType > r (
            MorphologyTraits::create (i, f, this));

          this->morphology_.push_back (::std::move (r));
          continue;
        }

        // ionChannel
        //
        if (n.name () == "ionChannel" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IonChannelType > r (
            IonChannelTraits::create (i, f, this));

          this->ionChannel_.push_back (::std::move (r));
          continue;
        }

        // ionChannelHH
        //
        if (n.name () == "ionChannelHH" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IonChannelHHType > r (
            IonChannelHHTraits::create (i, f, this));

          this->ionChannelHH_.push_back (::std::move (r));
          continue;
        }

        // decayingPoolConcentrationModel
        //
        if (n.name () == "decayingPoolConcentrationModel" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< DecayingPoolConcentrationModelType > r (
            DecayingPoolConcentrationModelTraits::create (i, f, this));

          this->decayingPoolConcentrationModel_.push_back (::std::move (r));
          continue;
        }

        // fixedFactorConcentrationModel
        //
        if (n.name () == "fixedFactorConcentrationModel" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< FixedFactorConcentrationModelType > r (
            FixedFactorConcentrationModelTraits::create (i, f, this));

          this->fixedFactorConcentrationModel_.push_back (::std::move (r));
          continue;
        }

        // expOneSynapse
        //
        if (n.name () == "expOneSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExpOneSynapseType > r (
            ExpOneSynapseTraits::create (i, f, this));

          this->expOneSynapse_.push_back (::std::move (r));
          continue;
        }

        // expTwoSynapse
        //
        if (n.name () == "expTwoSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExpTwoSynapseType > r (
            ExpTwoSynapseTraits::create (i, f, this));

          this->expTwoSynapse_.push_back (::std::move (r));
          continue;
        }

        // blockingPlasticSynapse
        //
        if (n.name () == "blockingPlasticSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< BlockingPlasticSynapseType > r (
            BlockingPlasticSynapseTraits::create (i, f, this));

          this->blockingPlasticSynapse_.push_back (::std::move (r));
          continue;
        }

        // biophysicalProperties
        //
        if (n.name () == "biophysicalProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< BiophysicalPropertiesType > r (
            BiophysicalPropertiesTraits::create (i, f, this));

          this->biophysicalProperties_.push_back (::std::move (r));
          continue;
        }

        // cell
        //
        if (n.name () == "cell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< CellType > r (
            CellTraits::create (i, f, this));

          this->cell_.push_back (::std::move (r));
          continue;
        }

        // baseCell
        //
        if (n.name () == "baseCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< BaseCellType > r (
            BaseCellTraits::create (i, f, this));

          this->baseCell_.push_back (::std::move (r));
          continue;
        }

        // iafTauCell
        //
        if (n.name () == "iafTauCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IafTauCellType > r (
            IafTauCellTraits::create (i, f, this));

          this->iafTauCell_.push_back (::std::move (r));
          continue;
        }

        // iafTauRefCell
        //
        if (n.name () == "iafTauRefCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IafTauRefCellType > r (
            IafTauRefCellTraits::create (i, f, this));

          this->iafTauRefCell_.push_back (::std::move (r));
          continue;
        }

        // iafCell
        //
        if (n.name () == "iafCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IafCellType > r (
            IafCellTraits::create (i, f, this));

          this->iafCell_.push_back (::std::move (r));
          continue;
        }

        // iafRefCell
        //
        if (n.name () == "iafRefCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IafRefCellType > r (
            IafRefCellTraits::create (i, f, this));

          this->iafRefCell_.push_back (::std::move (r));
          continue;
        }

        // izhikevichCell
        //
        if (n.name () == "izhikevichCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IzhikevichCellType > r (
            IzhikevichCellTraits::create (i, f, this));

          this->izhikevichCell_.push_back (::std::move (r));
          continue;
        }

        // adExIaFCell
        //
        if (n.name () == "adExIaFCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< AdExIaFCellType > r (
            AdExIaFCellTraits::create (i, f, this));

          this->adExIaFCell_.push_back (::std::move (r));
          continue;
        }

        // fitzHughNagumoCell
        //
        if (n.name () == "fitzHughNagumoCell" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< FitzHughNagumoCellType > r (
            FitzHughNagumoCellTraits::create (i, f, this));

          this->fitzHughNagumoCell_.push_back (::std::move (r));
          continue;
        }

        // pulseGenerator
        //
        if (n.name () == "pulseGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< PulseGeneratorType > r (
            PulseGeneratorTraits::create (i, f, this));

          this->pulseGenerator_.push_back (::std::move (r));
          continue;
        }

        // sineGenerator
        //
        if (n.name () == "sineGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SineGeneratorType > r (
            SineGeneratorTraits::create (i, f, this));

          this->sineGenerator_.push_back (::std::move (r));
          continue;
        }

        // rampGenerator
        //
        if (n.name () == "rampGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< RampGeneratorType > r (
            RampGeneratorTraits::create (i, f, this));

          this->rampGenerator_.push_back (::std::move (r));
          continue;
        }

        // voltageClamp
        //
        if (n.name () == "voltageClamp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VoltageClampType > r (
            VoltageClampTraits::create (i, f, this));

          this->voltageClamp_.push_back (::std::move (r));
          continue;
        }

        // spikeArray
        //
        if (n.name () == "spikeArray" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeArrayType > r (
            SpikeArrayTraits::create (i, f, this));

          this->spikeArray_.push_back (::std::move (r));
          continue;
        }

        // spikeGenerator
        //
        if (n.name () == "spikeGenerator" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeGeneratorType > r (
            SpikeGeneratorTraits::create (i, f, this));

          this->spikeGenerator_.push_back (::std::move (r));
          continue;
        }

        // spikeGeneratorRandom
        //
        if (n.name () == "spikeGeneratorRandom" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeGeneratorRandomType > r (
            SpikeGeneratorRandomTraits::create (i, f, this));

          this->spikeGeneratorRandom_.push_back (::std::move (r));
          continue;
        }

        // spikeGeneratorPoisson
        //
        if (n.name () == "spikeGeneratorPoisson" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeGeneratorPoissonType > r (
            SpikeGeneratorPoissonTraits::create (i, f, this));

          this->spikeGeneratorPoisson_.push_back (::std::move (r));
          continue;
        }

        // IF_curr_alpha
        //
        if (n.name () == "IF_curr_alpha" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IF_curr_alphaType > r (
            IF_curr_alphaTraits::create (i, f, this));

          this->IF_curr_alpha_.push_back (::std::move (r));
          continue;
        }

        // IF_curr_exp
        //
        if (n.name () == "IF_curr_exp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IF_curr_expType > r (
            IF_curr_expTraits::create (i, f, this));

          this->IF_curr_exp_.push_back (::std::move (r));
          continue;
        }

        // IF_cond_alpha
        //
        if (n.name () == "IF_cond_alpha" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IF_cond_alphaType > r (
            IF_cond_alphaTraits::create (i, f, this));

          this->IF_cond_alpha_.push_back (::std::move (r));
          continue;
        }

        // IF_cond_exp
        //
        if (n.name () == "IF_cond_exp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IF_cond_expType > r (
            IF_cond_expTraits::create (i, f, this));

          this->IF_cond_exp_.push_back (::std::move (r));
          continue;
        }

        // EIF_cond_exp_isfa_ista
        //
        if (n.name () == "EIF_cond_exp_isfa_ista" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< EIF_cond_exp_isfa_istaType > r (
            EIF_cond_exp_isfa_istaTraits::create (i, f, this));

          this->EIF_cond_exp_isfa_ista_.push_back (::std::move (r));
          continue;
        }

        // EIF_cond_alpha_isfa_ista
        //
        if (n.name () == "EIF_cond_alpha_isfa_ista" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< EIF_cond_alpha_isfa_istaType > r (
            EIF_cond_alpha_isfa_istaTraits::create (i, f, this));

          this->EIF_cond_alpha_isfa_ista_.push_back (::std::move (r));
          continue;
        }

        // HH_cond_exp
        //
        if (n.name () == "HH_cond_exp" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< HH_cond_expType > r (
            HH_cond_expTraits::create (i, f, this));

          this->HH_cond_exp_.push_back (::std::move (r));
          continue;
        }

        // expCondSynapse
        //
        if (n.name () == "expCondSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExpCondSynapseType > r (
            ExpCondSynapseTraits::create (i, f, this));

          this->expCondSynapse_.push_back (::std::move (r));
          continue;
        }

        // alphaCondSynapse
        //
        if (n.name () == "alphaCondSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< AlphaCondSynapseType > r (
            AlphaCondSynapseTraits::create (i, f, this));

          this->alphaCondSynapse_.push_back (::std::move (r));
          continue;
        }

        // expCurrSynapse
        //
        if (n.name () == "expCurrSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExpCurrSynapseType > r (
            ExpCurrSynapseTraits::create (i, f, this));

          this->expCurrSynapse_.push_back (::std::move (r));
          continue;
        }

        // alphaCurrSynapse
        //
        if (n.name () == "alphaCurrSynapse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< AlphaCurrSynapseType > r (
            AlphaCurrSynapseTraits::create (i, f, this));

          this->alphaCurrSynapse_.push_back (::std::move (r));
          continue;
        }

        // SpikeSourcePoisson
        //
        if (n.name () == "SpikeSourcePoisson" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeSourcePoissonType > r (
            SpikeSourcePoissonTraits::create (i, f, this));

          this->SpikeSourcePoisson_.push_back (::std::move (r));
          continue;
        }

        // network
        //
        if (n.name () == "network" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NetworkType > r (
            NetworkTraits::create (i, f, this));

          this->network_.push_back (::std::move (r));
          continue;
        }

        // ComponentType
        //
        if (n.name () == "ComponentType" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ComponentTypeType > r (
            ComponentTypeTraits::create (i, f, this));

          this->ComponentType_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    NeuroMLDocument* NeuroMLDocument::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NeuroMLDocument (*this, f, c);
    }

    NeuroMLDocument& NeuroMLDocument::
    operator= (const NeuroMLDocument& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->include_ = x.include_;
        this->extracellularProperties_ = x.extracellularProperties_;
        this->intracellularProperties_ = x.intracellularProperties_;
        this->morphology_ = x.morphology_;
        this->ionChannel_ = x.ionChannel_;
        this->ionChannelHH_ = x.ionChannelHH_;
        this->decayingPoolConcentrationModel_ = x.decayingPoolConcentrationModel_;
        this->fixedFactorConcentrationModel_ = x.fixedFactorConcentrationModel_;
        this->expOneSynapse_ = x.expOneSynapse_;
        this->expTwoSynapse_ = x.expTwoSynapse_;
        this->blockingPlasticSynapse_ = x.blockingPlasticSynapse_;
        this->biophysicalProperties_ = x.biophysicalProperties_;
        this->cell_ = x.cell_;
        this->baseCell_ = x.baseCell_;
        this->iafTauCell_ = x.iafTauCell_;
        this->iafTauRefCell_ = x.iafTauRefCell_;
        this->iafCell_ = x.iafCell_;
        this->iafRefCell_ = x.iafRefCell_;
        this->izhikevichCell_ = x.izhikevichCell_;
        this->adExIaFCell_ = x.adExIaFCell_;
        this->fitzHughNagumoCell_ = x.fitzHughNagumoCell_;
        this->pulseGenerator_ = x.pulseGenerator_;
        this->sineGenerator_ = x.sineGenerator_;
        this->rampGenerator_ = x.rampGenerator_;
        this->voltageClamp_ = x.voltageClamp_;
        this->spikeArray_ = x.spikeArray_;
        this->spikeGenerator_ = x.spikeGenerator_;
        this->spikeGeneratorRandom_ = x.spikeGeneratorRandom_;
        this->spikeGeneratorPoisson_ = x.spikeGeneratorPoisson_;
        this->IF_curr_alpha_ = x.IF_curr_alpha_;
        this->IF_curr_exp_ = x.IF_curr_exp_;
        this->IF_cond_alpha_ = x.IF_cond_alpha_;
        this->IF_cond_exp_ = x.IF_cond_exp_;
        this->EIF_cond_exp_isfa_ista_ = x.EIF_cond_exp_isfa_ista_;
        this->EIF_cond_alpha_isfa_ista_ = x.EIF_cond_alpha_isfa_ista_;
        this->HH_cond_exp_ = x.HH_cond_exp_;
        this->expCondSynapse_ = x.expCondSynapse_;
        this->alphaCondSynapse_ = x.alphaCondSynapse_;
        this->expCurrSynapse_ = x.expCurrSynapse_;
        this->alphaCurrSynapse_ = x.alphaCurrSynapse_;
        this->SpikeSourcePoisson_ = x.SpikeSourcePoisson_;
        this->network_ = x.network_;
        this->ComponentType_ = x.ComponentType_;
      }

      return *this;
    }

    NeuroMLDocument::
    ~NeuroMLDocument ()
    {
    }

    // IncludeType
    //

    IncludeType::
    IncludeType ()
    : ::xml_schema::Type (),
      href_ (this)
    {
    }

    IncludeType::
    IncludeType (const IncludeType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      href_ (x.href_, f, this)
    {
    }

    IncludeType::
    IncludeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      href_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void IncludeType::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "href" && n.namespace_ ().empty ())
        {
          this->href_.set (HrefTraits::create (i, f, this));
          continue;
        }
      }
    }

    IncludeType* IncludeType::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IncludeType (*this, f, c);
    }

    IncludeType& IncludeType::
    operator= (const IncludeType& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->href_ = x.href_;
      }

      return *this;
    }

    IncludeType::
    ~IncludeType ()
    {
    }

    // IonChannel
    //

    IonChannel::
    IonChannel (const IdType& id)
    : ::neurona::schema::Standalone (id),
      gate_ (this),
      gateHHrates_ (this),
      gateHHratesTau_ (this),
      gateHHtauInf_ (this),
      gateHHratesInf_ (this),
      gateHHratesTauInf_ (this),
      species_ (this),
      type_ (this),
      conductance_ (this)
    {
    }

    IonChannel::
    IonChannel (const IonChannel& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      gate_ (x.gate_, f, this),
      gateHHrates_ (x.gateHHrates_, f, this),
      gateHHratesTau_ (x.gateHHratesTau_, f, this),
      gateHHtauInf_ (x.gateHHtauInf_, f, this),
      gateHHratesInf_ (x.gateHHratesInf_, f, this),
      gateHHratesTauInf_ (x.gateHHratesTauInf_, f, this),
      species_ (x.species_, f, this),
      type_ (x.type_, f, this),
      conductance_ (x.conductance_, f, this)
    {
    }

    IonChannel::
    IonChannel (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      gate_ (this),
      gateHHrates_ (this),
      gateHHratesTau_ (this),
      gateHHtauInf_ (this),
      gateHHratesInf_ (this),
      gateHHratesTauInf_ (this),
      species_ (this),
      type_ (this),
      conductance_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IonChannel::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // gate
        //
        if (n.name () == "gate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GateType > r (
            GateTraits::create (i, f, this));

          this->gate_.push_back (::std::move (r));
          continue;
        }

        // gateHHrates
        //
        if (n.name () == "gateHHrates" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GateHHratesType > r (
            GateHHratesTraits::create (i, f, this));

          this->gateHHrates_.push_back (::std::move (r));
          continue;
        }

        // gateHHratesTau
        //
        if (n.name () == "gateHHratesTau" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GateHHratesTauType > r (
            GateHHratesTauTraits::create (i, f, this));

          this->gateHHratesTau_.push_back (::std::move (r));
          continue;
        }

        // gateHHtauInf
        //
        if (n.name () == "gateHHtauInf" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GateHHtauInfType > r (
            GateHHtauInfTraits::create (i, f, this));

          this->gateHHtauInf_.push_back (::std::move (r));
          continue;
        }

        // gateHHratesInf
        //
        if (n.name () == "gateHHratesInf" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GateHHratesInfType > r (
            GateHHratesInfTraits::create (i, f, this));

          this->gateHHratesInf_.push_back (::std::move (r));
          continue;
        }

        // gateHHratesTauInf
        //
        if (n.name () == "gateHHratesTauInf" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GateHHratesTauInfType > r (
            GateHHratesTauInfTraits::create (i, f, this));

          this->gateHHratesTauInf_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "species" && n.namespace_ ().empty ())
        {
          this->species_.set (SpeciesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "conductance" && n.namespace_ ().empty ())
        {
          this->conductance_.set (ConductanceTraits::create (i, f, this));
          continue;
        }
      }
    }

    IonChannel* IonChannel::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IonChannel (*this, f, c);
    }

    IonChannel& IonChannel::
    operator= (const IonChannel& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->gate_ = x.gate_;
        this->gateHHrates_ = x.gateHHrates_;
        this->gateHHratesTau_ = x.gateHHratesTau_;
        this->gateHHtauInf_ = x.gateHHtauInf_;
        this->gateHHratesInf_ = x.gateHHratesInf_;
        this->gateHHratesTauInf_ = x.gateHHratesTauInf_;
        this->species_ = x.species_;
        this->type_ = x.type_;
        this->conductance_ = x.conductance_;
      }

      return *this;
    }

    IonChannel::
    ~IonChannel ()
    {
    }

    // IonChannelHH
    //

    IonChannelHH::
    IonChannelHH (const IdType& id)
    : ::neurona::schema::IonChannel (id)
    {
    }

    IonChannelHH::
    IonChannelHH (const IonChannelHH& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::IonChannel (x, f, c)
    {
    }

    IonChannelHH::
    IonChannelHH (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::IonChannel (e, f, c)
    {
    }

    IonChannelHH* IonChannelHH::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IonChannelHH (*this, f, c);
    }

    IonChannelHH::
    ~IonChannelHH ()
    {
    }

    // ChannelTypes
    //

    ChannelTypes::
    ChannelTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_ChannelTypes_convert ();
    }

    ChannelTypes::
    ChannelTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_ChannelTypes_convert ();
    }

    ChannelTypes::
    ChannelTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_ChannelTypes_convert ();
    }

    ChannelTypes* ChannelTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelTypes (*this, f, c);
    }

    ChannelTypes::Value ChannelTypes::
    _xsd_ChannelTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ChannelTypes_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_ChannelTypes_indexes_,
                        _xsd_ChannelTypes_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_ChannelTypes_indexes_ + 2 || _xsd_ChannelTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const ChannelTypes::
    _xsd_ChannelTypes_literals_[2] =
    {
      "ionChannelPassive",
      "ionChannelHH"
    };

    const ChannelTypes::Value ChannelTypes::
    _xsd_ChannelTypes_indexes_[2] =
    {
      ::neurona::schema::ChannelTypes::ionChannelHH,
      ::neurona::schema::ChannelTypes::ionChannelPassive
    };

    // GateTypes
    //

    GateTypes::
    GateTypes (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_GateTypes_convert ();
    }

    GateTypes::
    GateTypes (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_GateTypes_convert ();
    }

    GateTypes::
    GateTypes (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_GateTypes_convert ();
    }

    GateTypes* GateTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateTypes (*this, f, c);
    }

    GateTypes::Value GateTypes::
    _xsd_GateTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_GateTypes_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_GateTypes_indexes_,
                        _xsd_GateTypes_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_GateTypes_indexes_ + 6 || _xsd_GateTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const GateTypes::
    _xsd_GateTypes_literals_[6] =
    {
      "gateHHrates",
      "gateHHratesTau",
      "gateHHtauInf",
      "gateHHratesInf",
      "gateHHratesTauInf",
      "gateKS"
    };

    const GateTypes::Value GateTypes::
    _xsd_GateTypes_indexes_[6] =
    {
      ::neurona::schema::GateTypes::gateHHrates,
      ::neurona::schema::GateTypes::gateHHratesInf,
      ::neurona::schema::GateTypes::gateHHratesTau,
      ::neurona::schema::GateTypes::gateHHratesTauInf,
      ::neurona::schema::GateTypes::gateHHtauInf,
      ::neurona::schema::GateTypes::gateKS
    };

    // GateHHUndetermined
    //

    GateHHUndetermined::
    GateHHUndetermined (const IdType& id)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (this),
      reverseRate_ (this),
      timeCourse_ (this),
      steadyState_ (this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHUndetermined::
    GateHHUndetermined (const GateHHUndetermined& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      q10Settings_ (x.q10Settings_, f, this),
      forwardRate_ (x.forwardRate_, f, this),
      reverseRate_ (x.reverseRate_, f, this),
      timeCourse_ (x.timeCourse_, f, this),
      steadyState_ (x.steadyState_, f, this),
      instances_ (x.instances_, f, this),
      type_ (x.type_, f, this)
    {
    }

    GateHHUndetermined::
    GateHHUndetermined (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (this),
      reverseRate_ (this),
      timeCourse_ (this),
      steadyState_ (this),
      instances_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GateHHUndetermined::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // q10Settings
        //
        if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< Q10SettingsType > r (
            Q10SettingsTraits::create (i, f, this));

          if (!this->q10Settings_)
          {
            this->q10Settings_.set (::std::move (r));
            continue;
          }
        }

        // forwardRate
        //
        if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ForwardRateType > r (
            ForwardRateTraits::create (i, f, this));

          if (!this->forwardRate_)
          {
            this->forwardRate_.set (::std::move (r));
            continue;
          }
        }

        // reverseRate
        //
        if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ReverseRateType > r (
            ReverseRateTraits::create (i, f, this));

          if (!this->reverseRate_)
          {
            this->reverseRate_.set (::std::move (r));
            continue;
          }
        }

        // timeCourse
        //
        if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< TimeCourseType > r (
            TimeCourseTraits::create (i, f, this));

          if (!this->timeCourse_)
          {
            this->timeCourse_.set (::std::move (r));
            continue;
          }
        }

        // steadyState
        //
        if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SteadyStateType > r (
            SteadyStateTraits::create (i, f, this));

          if (!this->steadyState_)
          {
            this->steadyState_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "instances" && n.namespace_ ().empty ())
        {
          this->instances_.set (InstancesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!instances_.present ())
      {
        this->instances_.set (instancesDefaultValue ());
      }
    }

    GateHHUndetermined* GateHHUndetermined::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateHHUndetermined (*this, f, c);
    }

    GateHHUndetermined& GateHHUndetermined::
    operator= (const GateHHUndetermined& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->q10Settings_ = x.q10Settings_;
        this->forwardRate_ = x.forwardRate_;
        this->reverseRate_ = x.reverseRate_;
        this->timeCourse_ = x.timeCourse_;
        this->steadyState_ = x.steadyState_;
        this->instances_ = x.instances_;
        this->type_ = x.type_;
      }

      return *this;
    }

    GateHHUndetermined::
    ~GateHHUndetermined ()
    {
    }

    // GateHHRates
    //

    GateHHRates::
    GateHHRates (const IdType& id,
                 const ForwardRateType& forwardRate,
                 const ReverseRateType& reverseRate)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (forwardRate, this),
      reverseRate_ (reverseRate, this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRates::
    GateHHRates (const IdType& id,
                 ::std::unique_ptr< ForwardRateType > forwardRate,
                 ::std::unique_ptr< ReverseRateType > reverseRate)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (std::move (forwardRate), this),
      reverseRate_ (std::move (reverseRate), this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRates::
    GateHHRates (const GateHHRates& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      q10Settings_ (x.q10Settings_, f, this),
      forwardRate_ (x.forwardRate_, f, this),
      reverseRate_ (x.reverseRate_, f, this),
      instances_ (x.instances_, f, this),
      type_ (x.type_, f, this)
    {
    }

    GateHHRates::
    GateHHRates (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (this),
      reverseRate_ (this),
      instances_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GateHHRates::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // q10Settings
        //
        if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< Q10SettingsType > r (
            Q10SettingsTraits::create (i, f, this));

          if (!this->q10Settings_)
          {
            this->q10Settings_.set (::std::move (r));
            continue;
          }
        }

        // forwardRate
        //
        if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ForwardRateType > r (
            ForwardRateTraits::create (i, f, this));

          if (!forwardRate_.present ())
          {
            this->forwardRate_.set (::std::move (r));
            continue;
          }
        }

        // reverseRate
        //
        if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ReverseRateType > r (
            ReverseRateTraits::create (i, f, this));

          if (!reverseRate_.present ())
          {
            this->reverseRate_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!forwardRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!reverseRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "instances" && n.namespace_ ().empty ())
        {
          this->instances_.set (InstancesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!instances_.present ())
      {
        this->instances_.set (instancesDefaultValue ());
      }
    }

    GateHHRates* GateHHRates::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateHHRates (*this, f, c);
    }

    GateHHRates& GateHHRates::
    operator= (const GateHHRates& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->q10Settings_ = x.q10Settings_;
        this->forwardRate_ = x.forwardRate_;
        this->reverseRate_ = x.reverseRate_;
        this->instances_ = x.instances_;
        this->type_ = x.type_;
      }

      return *this;
    }

    GateHHRates::
    ~GateHHRates ()
    {
    }

    // GateHHTauInf
    //

    GateHHTauInf::
    GateHHTauInf (const IdType& id,
                  const TimeCourseType& timeCourse,
                  const SteadyStateType& steadyState)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      timeCourse_ (timeCourse, this),
      steadyState_ (steadyState, this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHTauInf::
    GateHHTauInf (const IdType& id,
                  ::std::unique_ptr< TimeCourseType > timeCourse,
                  ::std::unique_ptr< SteadyStateType > steadyState)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      timeCourse_ (std::move (timeCourse), this),
      steadyState_ (std::move (steadyState), this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHTauInf::
    GateHHTauInf (const GateHHTauInf& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      q10Settings_ (x.q10Settings_, f, this),
      timeCourse_ (x.timeCourse_, f, this),
      steadyState_ (x.steadyState_, f, this),
      instances_ (x.instances_, f, this),
      type_ (x.type_, f, this)
    {
    }

    GateHHTauInf::
    GateHHTauInf (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      q10Settings_ (this),
      timeCourse_ (this),
      steadyState_ (this),
      instances_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GateHHTauInf::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // q10Settings
        //
        if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< Q10SettingsType > r (
            Q10SettingsTraits::create (i, f, this));

          if (!this->q10Settings_)
          {
            this->q10Settings_.set (::std::move (r));
            continue;
          }
        }

        // timeCourse
        //
        if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< TimeCourseType > r (
            TimeCourseTraits::create (i, f, this));

          if (!timeCourse_.present ())
          {
            this->timeCourse_.set (::std::move (r));
            continue;
          }
        }

        // steadyState
        //
        if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SteadyStateType > r (
            SteadyStateTraits::create (i, f, this));

          if (!steadyState_.present ())
          {
            this->steadyState_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!timeCourse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!steadyState_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "instances" && n.namespace_ ().empty ())
        {
          this->instances_.set (InstancesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!instances_.present ())
      {
        this->instances_.set (instancesDefaultValue ());
      }
    }

    GateHHTauInf* GateHHTauInf::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateHHTauInf (*this, f, c);
    }

    GateHHTauInf& GateHHTauInf::
    operator= (const GateHHTauInf& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->q10Settings_ = x.q10Settings_;
        this->timeCourse_ = x.timeCourse_;
        this->steadyState_ = x.steadyState_;
        this->instances_ = x.instances_;
        this->type_ = x.type_;
      }

      return *this;
    }

    GateHHTauInf::
    ~GateHHTauInf ()
    {
    }

    // GateHHRatesTauInf
    //

    GateHHRatesTauInf::
    GateHHRatesTauInf (const IdType& id,
                       const ForwardRateType& forwardRate,
                       const ReverseRateType& reverseRate,
                       const TimeCourseType& timeCourse,
                       const SteadyStateType& steadyState)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (forwardRate, this),
      reverseRate_ (reverseRate, this),
      timeCourse_ (timeCourse, this),
      steadyState_ (steadyState, this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRatesTauInf::
    GateHHRatesTauInf (const IdType& id,
                       ::std::unique_ptr< ForwardRateType > forwardRate,
                       ::std::unique_ptr< ReverseRateType > reverseRate,
                       ::std::unique_ptr< TimeCourseType > timeCourse,
                       ::std::unique_ptr< SteadyStateType > steadyState)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (std::move (forwardRate), this),
      reverseRate_ (std::move (reverseRate), this),
      timeCourse_ (std::move (timeCourse), this),
      steadyState_ (std::move (steadyState), this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRatesTauInf::
    GateHHRatesTauInf (const GateHHRatesTauInf& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      q10Settings_ (x.q10Settings_, f, this),
      forwardRate_ (x.forwardRate_, f, this),
      reverseRate_ (x.reverseRate_, f, this),
      timeCourse_ (x.timeCourse_, f, this),
      steadyState_ (x.steadyState_, f, this),
      instances_ (x.instances_, f, this),
      type_ (x.type_, f, this)
    {
    }

    GateHHRatesTauInf::
    GateHHRatesTauInf (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (this),
      reverseRate_ (this),
      timeCourse_ (this),
      steadyState_ (this),
      instances_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GateHHRatesTauInf::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // q10Settings
        //
        if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< Q10SettingsType > r (
            Q10SettingsTraits::create (i, f, this));

          if (!this->q10Settings_)
          {
            this->q10Settings_.set (::std::move (r));
            continue;
          }
        }

        // forwardRate
        //
        if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ForwardRateType > r (
            ForwardRateTraits::create (i, f, this));

          if (!forwardRate_.present ())
          {
            this->forwardRate_.set (::std::move (r));
            continue;
          }
        }

        // reverseRate
        //
        if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ReverseRateType > r (
            ReverseRateTraits::create (i, f, this));

          if (!reverseRate_.present ())
          {
            this->reverseRate_.set (::std::move (r));
            continue;
          }
        }

        // timeCourse
        //
        if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< TimeCourseType > r (
            TimeCourseTraits::create (i, f, this));

          if (!timeCourse_.present ())
          {
            this->timeCourse_.set (::std::move (r));
            continue;
          }
        }

        // steadyState
        //
        if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SteadyStateType > r (
            SteadyStateTraits::create (i, f, this));

          if (!steadyState_.present ())
          {
            this->steadyState_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!forwardRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!reverseRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!timeCourse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!steadyState_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "instances" && n.namespace_ ().empty ())
        {
          this->instances_.set (InstancesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!instances_.present ())
      {
        this->instances_.set (instancesDefaultValue ());
      }
    }

    GateHHRatesTauInf* GateHHRatesTauInf::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateHHRatesTauInf (*this, f, c);
    }

    GateHHRatesTauInf& GateHHRatesTauInf::
    operator= (const GateHHRatesTauInf& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->q10Settings_ = x.q10Settings_;
        this->forwardRate_ = x.forwardRate_;
        this->reverseRate_ = x.reverseRate_;
        this->timeCourse_ = x.timeCourse_;
        this->steadyState_ = x.steadyState_;
        this->instances_ = x.instances_;
        this->type_ = x.type_;
      }

      return *this;
    }

    GateHHRatesTauInf::
    ~GateHHRatesTauInf ()
    {
    }

    // GateHHRatesTau
    //

    GateHHRatesTau::
    GateHHRatesTau (const IdType& id,
                    const ForwardRateType& forwardRate,
                    const ReverseRateType& reverseRate,
                    const TimeCourseType& timeCourse)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (forwardRate, this),
      reverseRate_ (reverseRate, this),
      timeCourse_ (timeCourse, this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRatesTau::
    GateHHRatesTau (const IdType& id,
                    ::std::unique_ptr< ForwardRateType > forwardRate,
                    ::std::unique_ptr< ReverseRateType > reverseRate,
                    ::std::unique_ptr< TimeCourseType > timeCourse)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (std::move (forwardRate), this),
      reverseRate_ (std::move (reverseRate), this),
      timeCourse_ (std::move (timeCourse), this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRatesTau::
    GateHHRatesTau (const GateHHRatesTau& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      q10Settings_ (x.q10Settings_, f, this),
      forwardRate_ (x.forwardRate_, f, this),
      reverseRate_ (x.reverseRate_, f, this),
      timeCourse_ (x.timeCourse_, f, this),
      instances_ (x.instances_, f, this),
      type_ (x.type_, f, this)
    {
    }

    GateHHRatesTau::
    GateHHRatesTau (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (this),
      reverseRate_ (this),
      timeCourse_ (this),
      instances_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GateHHRatesTau::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // q10Settings
        //
        if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< Q10SettingsType > r (
            Q10SettingsTraits::create (i, f, this));

          if (!this->q10Settings_)
          {
            this->q10Settings_.set (::std::move (r));
            continue;
          }
        }

        // forwardRate
        //
        if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ForwardRateType > r (
            ForwardRateTraits::create (i, f, this));

          if (!forwardRate_.present ())
          {
            this->forwardRate_.set (::std::move (r));
            continue;
          }
        }

        // reverseRate
        //
        if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ReverseRateType > r (
            ReverseRateTraits::create (i, f, this));

          if (!reverseRate_.present ())
          {
            this->reverseRate_.set (::std::move (r));
            continue;
          }
        }

        // timeCourse
        //
        if (n.name () == "timeCourse" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< TimeCourseType > r (
            TimeCourseTraits::create (i, f, this));

          if (!timeCourse_.present ())
          {
            this->timeCourse_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!forwardRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!reverseRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!timeCourse_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "timeCourse",
          "http://www.neuroml.org/schema/neuroml2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "instances" && n.namespace_ ().empty ())
        {
          this->instances_.set (InstancesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!instances_.present ())
      {
        this->instances_.set (instancesDefaultValue ());
      }
    }

    GateHHRatesTau* GateHHRatesTau::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateHHRatesTau (*this, f, c);
    }

    GateHHRatesTau& GateHHRatesTau::
    operator= (const GateHHRatesTau& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->q10Settings_ = x.q10Settings_;
        this->forwardRate_ = x.forwardRate_;
        this->reverseRate_ = x.reverseRate_;
        this->timeCourse_ = x.timeCourse_;
        this->instances_ = x.instances_;
        this->type_ = x.type_;
      }

      return *this;
    }

    GateHHRatesTau::
    ~GateHHRatesTau ()
    {
    }

    // GateHHRatesInf
    //

    GateHHRatesInf::
    GateHHRatesInf (const IdType& id,
                    const ForwardRateType& forwardRate,
                    const ReverseRateType& reverseRate,
                    const SteadyStateType& steadyState)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (forwardRate, this),
      reverseRate_ (reverseRate, this),
      steadyState_ (steadyState, this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRatesInf::
    GateHHRatesInf (const IdType& id,
                    ::std::unique_ptr< ForwardRateType > forwardRate,
                    ::std::unique_ptr< ReverseRateType > reverseRate,
                    ::std::unique_ptr< SteadyStateType > steadyState)
    : ::neurona::schema::Base (id),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (std::move (forwardRate), this),
      reverseRate_ (std::move (reverseRate), this),
      steadyState_ (std::move (steadyState), this),
      instances_ (instancesDefaultValue (), this),
      type_ (this)
    {
    }

    GateHHRatesInf::
    GateHHRatesInf (const GateHHRatesInf& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      q10Settings_ (x.q10Settings_, f, this),
      forwardRate_ (x.forwardRate_, f, this),
      reverseRate_ (x.reverseRate_, f, this),
      steadyState_ (x.steadyState_, f, this),
      instances_ (x.instances_, f, this),
      type_ (x.type_, f, this)
    {
    }

    GateHHRatesInf::
    GateHHRatesInf (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      q10Settings_ (this),
      forwardRate_ (this),
      reverseRate_ (this),
      steadyState_ (this),
      instances_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void GateHHRatesInf::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // q10Settings
        //
        if (n.name () == "q10Settings" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< Q10SettingsType > r (
            Q10SettingsTraits::create (i, f, this));

          if (!this->q10Settings_)
          {
            this->q10Settings_.set (::std::move (r));
            continue;
          }
        }

        // forwardRate
        //
        if (n.name () == "forwardRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ForwardRateType > r (
            ForwardRateTraits::create (i, f, this));

          if (!forwardRate_.present ())
          {
            this->forwardRate_.set (::std::move (r));
            continue;
          }
        }

        // reverseRate
        //
        if (n.name () == "reverseRate" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ReverseRateType > r (
            ReverseRateTraits::create (i, f, this));

          if (!reverseRate_.present ())
          {
            this->reverseRate_.set (::std::move (r));
            continue;
          }
        }

        // steadyState
        //
        if (n.name () == "steadyState" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SteadyStateType > r (
            SteadyStateTraits::create (i, f, this));

          if (!steadyState_.present ())
          {
            this->steadyState_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!forwardRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "forwardRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!reverseRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "reverseRate",
          "http://www.neuroml.org/schema/neuroml2");
      }

      if (!steadyState_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "steadyState",
          "http://www.neuroml.org/schema/neuroml2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "instances" && n.namespace_ ().empty ())
        {
          this->instances_.set (InstancesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!instances_.present ())
      {
        this->instances_.set (instancesDefaultValue ());
      }
    }

    GateHHRatesInf* GateHHRatesInf::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GateHHRatesInf (*this, f, c);
    }

    GateHHRatesInf& GateHHRatesInf::
    operator= (const GateHHRatesInf& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->q10Settings_ = x.q10Settings_;
        this->forwardRate_ = x.forwardRate_;
        this->reverseRate_ = x.reverseRate_;
        this->steadyState_ = x.steadyState_;
        this->instances_ = x.instances_;
        this->type_ = x.type_;
      }

      return *this;
    }

    GateHHRatesInf::
    ~GateHHRatesInf ()
    {
    }

    // Q10Settings
    //

    Q10Settings::
    Q10Settings (const TypeType& type)
    : ::xml_schema::Type (),
      type_ (type, this),
      fixedQ10_ (this),
      q10Factor_ (this),
      experimentalTemp_ (this)
    {
    }

    Q10Settings::
    Q10Settings (const Q10Settings& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      fixedQ10_ (x.fixedQ10_, f, this),
      q10Factor_ (x.q10Factor_, f, this),
      experimentalTemp_ (x.experimentalTemp_, f, this)
    {
    }

    Q10Settings::
    Q10Settings (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (this),
      fixedQ10_ (this),
      q10Factor_ (this),
      experimentalTemp_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Q10Settings::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "fixedQ10" && n.namespace_ ().empty ())
        {
          this->fixedQ10_.set (FixedQ10Traits::create (i, f, this));
          continue;
        }

        if (n.name () == "q10Factor" && n.namespace_ ().empty ())
        {
          this->q10Factor_.set (Q10FactorTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "experimentalTemp" && n.namespace_ ().empty ())
        {
          this->experimentalTemp_.set (ExperimentalTempTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    Q10Settings* Q10Settings::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Q10Settings (*this, f, c);
    }

    Q10Settings& Q10Settings::
    operator= (const Q10Settings& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->type_ = x.type_;
        this->fixedQ10_ = x.fixedQ10_;
        this->q10Factor_ = x.q10Factor_;
        this->experimentalTemp_ = x.experimentalTemp_;
      }

      return *this;
    }

    Q10Settings::
    ~Q10Settings ()
    {
    }

    // HHRate
    //

    HHRate::
    HHRate (const TypeType& type)
    : ::xml_schema::Type (),
      type_ (type, this),
      rate_ (this),
      midpoint_ (this),
      scale_ (this)
    {
    }

    HHRate::
    HHRate (const HHRate& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      rate_ (x.rate_, f, this),
      midpoint_ (x.midpoint_, f, this),
      scale_ (x.scale_, f, this)
    {
    }

    HHRate::
    HHRate (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (this),
      rate_ (this),
      midpoint_ (this),
      scale_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void HHRate::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "rate" && n.namespace_ ().empty ())
        {
          this->rate_.set (RateTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "midpoint" && n.namespace_ ().empty ())
        {
          this->midpoint_.set (MidpointTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "scale" && n.namespace_ ().empty ())
        {
          this->scale_.set (ScaleTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    HHRate* HHRate::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HHRate (*this, f, c);
    }

    HHRate& HHRate::
    operator= (const HHRate& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->type_ = x.type_;
        this->rate_ = x.rate_;
        this->midpoint_ = x.midpoint_;
        this->scale_ = x.scale_;
      }

      return *this;
    }

    HHRate::
    ~HHRate ()
    {
    }

    // HHVariable
    //

    HHVariable::
    HHVariable (const TypeType& type)
    : ::xml_schema::Type (),
      type_ (type, this),
      rate_ (this),
      midpoint_ (this),
      scale_ (this)
    {
    }

    HHVariable::
    HHVariable (const HHVariable& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      rate_ (x.rate_, f, this),
      midpoint_ (x.midpoint_, f, this),
      scale_ (x.scale_, f, this)
    {
    }

    HHVariable::
    HHVariable (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (this),
      rate_ (this),
      midpoint_ (this),
      scale_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void HHVariable::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "rate" && n.namespace_ ().empty ())
        {
          this->rate_.set (RateTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "midpoint" && n.namespace_ ().empty ())
        {
          this->midpoint_.set (MidpointTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "scale" && n.namespace_ ().empty ())
        {
          this->scale_.set (ScaleTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    HHVariable* HHVariable::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HHVariable (*this, f, c);
    }

    HHVariable& HHVariable::
    operator= (const HHVariable& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->type_ = x.type_;
        this->rate_ = x.rate_;
        this->midpoint_ = x.midpoint_;
        this->scale_ = x.scale_;
      }

      return *this;
    }

    HHVariable::
    ~HHVariable ()
    {
    }

    // HHTime
    //

    HHTime::
    HHTime (const TypeType& type)
    : ::xml_schema::Type (),
      type_ (type, this),
      rate_ (this),
      midpoint_ (this),
      scale_ (this),
      tau_ (this)
    {
    }

    HHTime::
    HHTime (const HHTime& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      rate_ (x.rate_, f, this),
      midpoint_ (x.midpoint_, f, this),
      scale_ (x.scale_, f, this),
      tau_ (x.tau_, f, this)
    {
    }

    HHTime::
    HHTime (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (this),
      rate_ (this),
      midpoint_ (this),
      scale_ (this),
      tau_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void HHTime::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "rate" && n.namespace_ ().empty ())
        {
          this->rate_.set (RateTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "midpoint" && n.namespace_ ().empty ())
        {
          this->midpoint_.set (MidpointTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "scale" && n.namespace_ ().empty ())
        {
          this->scale_.set (ScaleTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau" && n.namespace_ ().empty ())
        {
          this->tau_.set (TauTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    HHTime* HHTime::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HHTime (*this, f, c);
    }

    HHTime& HHTime::
    operator= (const HHTime& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->type_ = x.type_;
        this->rate_ = x.rate_;
        this->midpoint_ = x.midpoint_;
        this->scale_ = x.scale_;
        this->tau_ = x.tau_;
      }

      return *this;
    }

    HHTime::
    ~HHTime ()
    {
    }

    // DecayingPoolConcentrationModel
    //

    DecayingPoolConcentrationModel::
    DecayingPoolConcentrationModel (const IdType& id,
                                    const IonType& ion,
                                    const RestingConcType& restingConc,
                                    const DecayConstantType& decayConstant,
                                    const ShellThicknessType& shellThickness)
    : ::neurona::schema::Standalone (id),
      ion_ (ion, this),
      restingConc_ (restingConc, this),
      decayConstant_ (decayConstant, this),
      shellThickness_ (shellThickness, this)
    {
    }

    DecayingPoolConcentrationModel::
    DecayingPoolConcentrationModel (const DecayingPoolConcentrationModel& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      ion_ (x.ion_, f, this),
      restingConc_ (x.restingConc_, f, this),
      decayConstant_ (x.decayConstant_, f, this),
      shellThickness_ (x.shellThickness_, f, this)
    {
    }

    DecayingPoolConcentrationModel::
    DecayingPoolConcentrationModel (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      ion_ (this),
      restingConc_ (this),
      decayConstant_ (this),
      shellThickness_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void DecayingPoolConcentrationModel::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "restingConc" && n.namespace_ ().empty ())
        {
          this->restingConc_.set (RestingConcTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "decayConstant" && n.namespace_ ().empty ())
        {
          this->decayConstant_.set (DecayConstantTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "shellThickness" && n.namespace_ ().empty ())
        {
          this->shellThickness_.set (ShellThicknessTraits::create (i, f, this));
          continue;
        }
      }

      if (!ion_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ion",
          "");
      }

      if (!restingConc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "restingConc",
          "");
      }

      if (!decayConstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "decayConstant",
          "");
      }

      if (!shellThickness_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "shellThickness",
          "");
      }
    }

    DecayingPoolConcentrationModel* DecayingPoolConcentrationModel::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DecayingPoolConcentrationModel (*this, f, c);
    }

    DecayingPoolConcentrationModel& DecayingPoolConcentrationModel::
    operator= (const DecayingPoolConcentrationModel& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->ion_ = x.ion_;
        this->restingConc_ = x.restingConc_;
        this->decayConstant_ = x.decayConstant_;
        this->shellThickness_ = x.shellThickness_;
      }

      return *this;
    }

    DecayingPoolConcentrationModel::
    ~DecayingPoolConcentrationModel ()
    {
    }

    // FixedFactorConcentrationModel
    //

    FixedFactorConcentrationModel::
    FixedFactorConcentrationModel (const IdType& id,
                                   const IonType& ion,
                                   const RestingConcType& restingConc,
                                   const DecayConstantType& decayConstant,
                                   const RhoType& rho)
    : ::neurona::schema::Standalone (id),
      ion_ (ion, this),
      restingConc_ (restingConc, this),
      decayConstant_ (decayConstant, this),
      rho_ (rho, this)
    {
    }

    FixedFactorConcentrationModel::
    FixedFactorConcentrationModel (const FixedFactorConcentrationModel& x,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      ion_ (x.ion_, f, this),
      restingConc_ (x.restingConc_, f, this),
      decayConstant_ (x.decayConstant_, f, this),
      rho_ (x.rho_, f, this)
    {
    }

    FixedFactorConcentrationModel::
    FixedFactorConcentrationModel (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f,
                                   ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      ion_ (this),
      restingConc_ (this),
      decayConstant_ (this),
      rho_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FixedFactorConcentrationModel::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "restingConc" && n.namespace_ ().empty ())
        {
          this->restingConc_.set (RestingConcTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "decayConstant" && n.namespace_ ().empty ())
        {
          this->decayConstant_.set (DecayConstantTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "rho" && n.namespace_ ().empty ())
        {
          this->rho_.set (RhoTraits::create (i, f, this));
          continue;
        }
      }

      if (!ion_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ion",
          "");
      }

      if (!restingConc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "restingConc",
          "");
      }

      if (!decayConstant_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "decayConstant",
          "");
      }

      if (!rho_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "rho",
          "");
      }
    }

    FixedFactorConcentrationModel* FixedFactorConcentrationModel::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FixedFactorConcentrationModel (*this, f, c);
    }

    FixedFactorConcentrationModel& FixedFactorConcentrationModel::
    operator= (const FixedFactorConcentrationModel& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->ion_ = x.ion_;
        this->restingConc_ = x.restingConc_;
        this->decayConstant_ = x.decayConstant_;
        this->rho_ = x.rho_;
      }

      return *this;
    }

    FixedFactorConcentrationModel::
    ~FixedFactorConcentrationModel ()
    {
    }

    // BaseSynapse
    //

    BaseSynapse::
    BaseSynapse (const IdType& id)
    : ::neurona::schema::Standalone (id)
    {
    }

    BaseSynapse::
    BaseSynapse (const BaseSynapse& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c)
    {
    }

    BaseSynapse::
    BaseSynapse (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f, c)
    {
    }

    BaseSynapse* BaseSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BaseSynapse (*this, f, c);
    }

    BaseSynapse::
    ~BaseSynapse ()
    {
    }

    // BaseConductanceBasedSynapse
    //

    BaseConductanceBasedSynapse::
    BaseConductanceBasedSynapse (const IdType& id,
                                 const GbaseType& gbase,
                                 const ErevType& erev)
    : ::neurona::schema::BaseSynapse (id),
      gbase_ (gbase, this),
      erev_ (erev, this)
    {
    }

    BaseConductanceBasedSynapse::
    BaseConductanceBasedSynapse (const BaseConductanceBasedSynapse& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::neurona::schema::BaseSynapse (x, f, c),
      gbase_ (x.gbase_, f, this),
      erev_ (x.erev_, f, this)
    {
    }

    BaseConductanceBasedSynapse::
    BaseConductanceBasedSynapse (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
    : ::neurona::schema::BaseSynapse (e, f | ::xml_schema::Flags::base, c),
      gbase_ (this),
      erev_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BaseConductanceBasedSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseSynapse::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "gbase" && n.namespace_ ().empty ())
        {
          this->gbase_.set (GbaseTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "erev" && n.namespace_ ().empty ())
        {
          this->erev_.set (ErevTraits::create (i, f, this));
          continue;
        }
      }

      if (!gbase_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "gbase",
          "");
      }

      if (!erev_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "erev",
          "");
      }
    }

    BaseConductanceBasedSynapse* BaseConductanceBasedSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BaseConductanceBasedSynapse (*this, f, c);
    }

    BaseConductanceBasedSynapse& BaseConductanceBasedSynapse::
    operator= (const BaseConductanceBasedSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseSynapse& > (*this) = x;
        this->gbase_ = x.gbase_;
        this->erev_ = x.erev_;
      }

      return *this;
    }

    BaseConductanceBasedSynapse::
    ~BaseConductanceBasedSynapse ()
    {
    }

    // ExpOneSynapse
    //

    ExpOneSynapse::
    ExpOneSynapse (const IdType& id,
                   const GbaseType& gbase,
                   const ErevType& erev,
                   const TauDecayType& tauDecay)
    : ::neurona::schema::BaseConductanceBasedSynapse (id,
                                                      gbase,
                                                      erev),
      tauDecay_ (tauDecay, this)
    {
    }

    ExpOneSynapse::
    ExpOneSynapse (const ExpOneSynapse& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BaseConductanceBasedSynapse (x, f, c),
      tauDecay_ (x.tauDecay_, f, this)
    {
    }

    ExpOneSynapse::
    ExpOneSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BaseConductanceBasedSynapse (e, f | ::xml_schema::Flags::base, c),
      tauDecay_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExpOneSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseConductanceBasedSynapse::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tauDecay" && n.namespace_ ().empty ())
        {
          this->tauDecay_.set (TauDecayTraits::create (i, f, this));
          continue;
        }
      }

      if (!tauDecay_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tauDecay",
          "");
      }
    }

    ExpOneSynapse* ExpOneSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExpOneSynapse (*this, f, c);
    }

    ExpOneSynapse& ExpOneSynapse::
    operator= (const ExpOneSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseConductanceBasedSynapse& > (*this) = x;
        this->tauDecay_ = x.tauDecay_;
      }

      return *this;
    }

    ExpOneSynapse::
    ~ExpOneSynapse ()
    {
    }

    // ExpTwoSynapse
    //

    ExpTwoSynapse::
    ExpTwoSynapse (const IdType& id,
                   const GbaseType& gbase,
                   const ErevType& erev,
                   const TauDecayType& tauDecay,
                   const TauRiseType& tauRise)
    : ::neurona::schema::BaseConductanceBasedSynapse (id,
                                                      gbase,
                                                      erev),
      tauDecay_ (tauDecay, this),
      tauRise_ (tauRise, this)
    {
    }

    ExpTwoSynapse::
    ExpTwoSynapse (const ExpTwoSynapse& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BaseConductanceBasedSynapse (x, f, c),
      tauDecay_ (x.tauDecay_, f, this),
      tauRise_ (x.tauRise_, f, this)
    {
    }

    ExpTwoSynapse::
    ExpTwoSynapse (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BaseConductanceBasedSynapse (e, f | ::xml_schema::Flags::base, c),
      tauDecay_ (this),
      tauRise_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExpTwoSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseConductanceBasedSynapse::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tauDecay" && n.namespace_ ().empty ())
        {
          this->tauDecay_.set (TauDecayTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tauRise" && n.namespace_ ().empty ())
        {
          this->tauRise_.set (TauRiseTraits::create (i, f, this));
          continue;
        }
      }

      if (!tauDecay_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tauDecay",
          "");
      }

      if (!tauRise_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tauRise",
          "");
      }
    }

    ExpTwoSynapse* ExpTwoSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExpTwoSynapse (*this, f, c);
    }

    ExpTwoSynapse& ExpTwoSynapse::
    operator= (const ExpTwoSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseConductanceBasedSynapse& > (*this) = x;
        this->tauDecay_ = x.tauDecay_;
        this->tauRise_ = x.tauRise_;
      }

      return *this;
    }

    ExpTwoSynapse::
    ~ExpTwoSynapse ()
    {
    }

    // BlockingPlasticSynapse
    //

    BlockingPlasticSynapse::
    BlockingPlasticSynapse (const IdType& id,
                            const GbaseType& gbase,
                            const ErevType& erev,
                            const TauDecayType& tauDecay,
                            const TauRiseType& tauRise)
    : ::neurona::schema::ExpTwoSynapse (id,
                                        gbase,
                                        erev,
                                        tauDecay,
                                        tauRise),
      plasticityMechanism_ (this),
      blockMechanism_ (this)
    {
    }

    BlockingPlasticSynapse::
    BlockingPlasticSynapse (const BlockingPlasticSynapse& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::neurona::schema::ExpTwoSynapse (x, f, c),
      plasticityMechanism_ (x.plasticityMechanism_, f, this),
      blockMechanism_ (x.blockMechanism_, f, this)
    {
    }

    BlockingPlasticSynapse::
    BlockingPlasticSynapse (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::neurona::schema::ExpTwoSynapse (e, f | ::xml_schema::Flags::base, c),
      plasticityMechanism_ (this),
      blockMechanism_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BlockingPlasticSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::ExpTwoSynapse::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // plasticityMechanism
        //
        if (n.name () == "plasticityMechanism" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< PlasticityMechanismType > r (
            PlasticityMechanismTraits::create (i, f, this));

          if (!this->plasticityMechanism_)
          {
            this->plasticityMechanism_.set (::std::move (r));
            continue;
          }
        }

        // blockMechanism
        //
        if (n.name () == "blockMechanism" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< BlockMechanismType > r (
            BlockMechanismTraits::create (i, f, this));

          if (!this->blockMechanism_)
          {
            this->blockMechanism_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    BlockingPlasticSynapse* BlockingPlasticSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BlockingPlasticSynapse (*this, f, c);
    }

    BlockingPlasticSynapse& BlockingPlasticSynapse::
    operator= (const BlockingPlasticSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::ExpTwoSynapse& > (*this) = x;
        this->plasticityMechanism_ = x.plasticityMechanism_;
        this->blockMechanism_ = x.blockMechanism_;
      }

      return *this;
    }

    BlockingPlasticSynapse::
    ~BlockingPlasticSynapse ()
    {
    }

    // BlockTypes
    //

    BlockTypes::
    BlockTypes (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_BlockTypes_convert ();
    }

    BlockTypes::
    BlockTypes (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_BlockTypes_convert ();
    }

    BlockTypes::
    BlockTypes (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_BlockTypes_convert ();
    }

    BlockTypes* BlockTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BlockTypes (*this, f, c);
    }

    BlockTypes::Value BlockTypes::
    _xsd_BlockTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_BlockTypes_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_BlockTypes_indexes_,
                        _xsd_BlockTypes_indexes_ + 1,
                        *this,
                        c));

      if (i == _xsd_BlockTypes_indexes_ + 1 || _xsd_BlockTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const BlockTypes::
    _xsd_BlockTypes_literals_[1] =
    {
      "voltageConcDepBlockMechanism"
    };

    const BlockTypes::Value BlockTypes::
    _xsd_BlockTypes_indexes_[1] =
    {
      ::neurona::schema::BlockTypes::voltageConcDepBlockMechanism
    };

    // BlockMechanism
    //

    BlockMechanism::
    BlockMechanism (const TypeType& type,
                    const SpeciesType& species,
                    const BlockConcentrationType& blockConcentration,
                    const ScalingConcType& scalingConc,
                    const ScalingVoltType& scalingVolt)
    : ::xml_schema::Type (),
      type_ (type, this),
      species_ (species, this),
      blockConcentration_ (blockConcentration, this),
      scalingConc_ (scalingConc, this),
      scalingVolt_ (scalingVolt, this)
    {
    }

    BlockMechanism::
    BlockMechanism (const BlockMechanism& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      species_ (x.species_, f, this),
      blockConcentration_ (x.blockConcentration_, f, this),
      scalingConc_ (x.scalingConc_, f, this),
      scalingVolt_ (x.scalingVolt_, f, this)
    {
    }

    BlockMechanism::
    BlockMechanism (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (this),
      species_ (this),
      blockConcentration_ (this),
      scalingConc_ (this),
      scalingVolt_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void BlockMechanism::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "species" && n.namespace_ ().empty ())
        {
          this->species_.set (SpeciesTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "blockConcentration" && n.namespace_ ().empty ())
        {
          this->blockConcentration_.set (BlockConcentrationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "scalingConc" && n.namespace_ ().empty ())
        {
          this->scalingConc_.set (ScalingConcTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "scalingVolt" && n.namespace_ ().empty ())
        {
          this->scalingVolt_.set (ScalingVoltTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!species_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "species",
          "");
      }

      if (!blockConcentration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "blockConcentration",
          "");
      }

      if (!scalingConc_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "scalingConc",
          "");
      }

      if (!scalingVolt_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "scalingVolt",
          "");
      }
    }

    BlockMechanism* BlockMechanism::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BlockMechanism (*this, f, c);
    }

    BlockMechanism& BlockMechanism::
    operator= (const BlockMechanism& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->type_ = x.type_;
        this->species_ = x.species_;
        this->blockConcentration_ = x.blockConcentration_;
        this->scalingConc_ = x.scalingConc_;
        this->scalingVolt_ = x.scalingVolt_;
      }

      return *this;
    }

    BlockMechanism::
    ~BlockMechanism ()
    {
    }

    // PlasticityTypes
    //

    PlasticityTypes::
    PlasticityTypes (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_PlasticityTypes_convert ();
    }

    PlasticityTypes::
    PlasticityTypes (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_PlasticityTypes_convert ();
    }

    PlasticityTypes::
    PlasticityTypes (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_PlasticityTypes_convert ();
    }

    PlasticityTypes* PlasticityTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PlasticityTypes (*this, f, c);
    }

    PlasticityTypes::Value PlasticityTypes::
    _xsd_PlasticityTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PlasticityTypes_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_PlasticityTypes_indexes_,
                        _xsd_PlasticityTypes_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_PlasticityTypes_indexes_ + 2 || _xsd_PlasticityTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const PlasticityTypes::
    _xsd_PlasticityTypes_literals_[2] =
    {
      "tsodyksMarkramDepMechanism",
      "tsodyksMarkramDepFacMechanism"
    };

    const PlasticityTypes::Value PlasticityTypes::
    _xsd_PlasticityTypes_indexes_[2] =
    {
      ::neurona::schema::PlasticityTypes::tsodyksMarkramDepFacMechanism,
      ::neurona::schema::PlasticityTypes::tsodyksMarkramDepMechanism
    };

    // PlasticityMechanism
    //

    PlasticityMechanism::
    PlasticityMechanism (const TypeType& type,
                         const InitReleaseProbType& initReleaseProb,
                         const TauRecType& tauRec)
    : ::xml_schema::Type (),
      type_ (type, this),
      initReleaseProb_ (initReleaseProb, this),
      tauRec_ (tauRec, this),
      tauFac_ (this)
    {
    }

    PlasticityMechanism::
    PlasticityMechanism (const PlasticityMechanism& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      type_ (x.type_, f, this),
      initReleaseProb_ (x.initReleaseProb_, f, this),
      tauRec_ (x.tauRec_, f, this),
      tauFac_ (x.tauFac_, f, this)
    {
    }

    PlasticityMechanism::
    PlasticityMechanism (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      type_ (this),
      initReleaseProb_ (this),
      tauRec_ (this),
      tauFac_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void PlasticityMechanism::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "initReleaseProb" && n.namespace_ ().empty ())
        {
          this->initReleaseProb_.set (InitReleaseProbTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tauRec" && n.namespace_ ().empty ())
        {
          this->tauRec_.set (TauRecTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tauFac" && n.namespace_ ().empty ())
        {
          this->tauFac_.set (TauFacTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }

      if (!initReleaseProb_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "initReleaseProb",
          "");
      }

      if (!tauRec_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tauRec",
          "");
      }
    }

    PlasticityMechanism* PlasticityMechanism::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PlasticityMechanism (*this, f, c);
    }

    PlasticityMechanism& PlasticityMechanism::
    operator= (const PlasticityMechanism& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->type_ = x.type_;
        this->initReleaseProb_ = x.initReleaseProb_;
        this->tauRec_ = x.tauRec_;
        this->tauFac_ = x.tauFac_;
      }

      return *this;
    }

    PlasticityMechanism::
    ~PlasticityMechanism ()
    {
    }

    // BaseCell
    //

    BaseCell::
    BaseCell (const IdType& id)
    : ::neurona::schema::Standalone (id)
    {
    }

    BaseCell::
    BaseCell (const BaseCell& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c)
    {
    }

    BaseCell::
    BaseCell (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f, c)
    {
    }

    BaseCell* BaseCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BaseCell (*this, f, c);
    }

    BaseCell::
    ~BaseCell ()
    {
    }

    // IafTauCell
    //

    IafTauCell::
    IafTauCell (const IdType& id,
                const LeakReversalType& leakReversal,
                const ThreshType& thresh,
                const ResetType& reset,
                const TauType& tau)
    : ::neurona::schema::BaseCell (id),
      leakReversal_ (leakReversal, this),
      thresh_ (thresh, this),
      reset_ (reset, this),
      tau_ (tau, this)
    {
    }

    IafTauCell::
    IafTauCell (const IafTauCell& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      leakReversal_ (x.leakReversal_, f, this),
      thresh_ (x.thresh_, f, this),
      reset_ (x.reset_, f, this),
      tau_ (x.tau_, f, this)
    {
    }

    IafTauCell::
    IafTauCell (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      leakReversal_ (this),
      thresh_ (this),
      reset_ (this),
      tau_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IafTauCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "leakReversal" && n.namespace_ ().empty ())
        {
          this->leakReversal_.set (LeakReversalTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "thresh" && n.namespace_ ().empty ())
        {
          this->thresh_.set (ThreshTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "reset" && n.namespace_ ().empty ())
        {
          this->reset_.set (ResetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau" && n.namespace_ ().empty ())
        {
          this->tau_.set (TauTraits::create (i, f, this));
          continue;
        }
      }

      if (!leakReversal_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "leakReversal",
          "");
      }

      if (!thresh_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "thresh",
          "");
      }

      if (!reset_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reset",
          "");
      }

      if (!tau_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tau",
          "");
      }
    }

    IafTauCell* IafTauCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IafTauCell (*this, f, c);
    }

    IafTauCell& IafTauCell::
    operator= (const IafTauCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->leakReversal_ = x.leakReversal_;
        this->thresh_ = x.thresh_;
        this->reset_ = x.reset_;
        this->tau_ = x.tau_;
      }

      return *this;
    }

    IafTauCell::
    ~IafTauCell ()
    {
    }

    // IafTauRefCell
    //

    IafTauRefCell::
    IafTauRefCell (const IdType& id,
                   const LeakReversalType& leakReversal,
                   const ThreshType& thresh,
                   const ResetType& reset,
                   const TauType& tau,
                   const RefractType& refract)
    : ::neurona::schema::IafTauCell (id,
                                     leakReversal,
                                     thresh,
                                     reset,
                                     tau),
      refract_ (refract, this)
    {
    }

    IafTauRefCell::
    IafTauRefCell (const IafTauRefCell& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::IafTauCell (x, f, c),
      refract_ (x.refract_, f, this)
    {
    }

    IafTauRefCell::
    IafTauRefCell (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::IafTauCell (e, f | ::xml_schema::Flags::base, c),
      refract_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IafTauRefCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::IafTauCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "refract" && n.namespace_ ().empty ())
        {
          this->refract_.set (RefractTraits::create (i, f, this));
          continue;
        }
      }

      if (!refract_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "refract",
          "");
      }
    }

    IafTauRefCell* IafTauRefCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IafTauRefCell (*this, f, c);
    }

    IafTauRefCell& IafTauRefCell::
    operator= (const IafTauRefCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::IafTauCell& > (*this) = x;
        this->refract_ = x.refract_;
      }

      return *this;
    }

    IafTauRefCell::
    ~IafTauRefCell ()
    {
    }

    // IafCell
    //

    IafCell::
    IafCell (const IdType& id,
             const LeakReversalType& leakReversal,
             const ThreshType& thresh,
             const ResetType& reset,
             const CType& C,
             const LeakConductanceType& leakConductance)
    : ::neurona::schema::BaseCell (id),
      leakReversal_ (leakReversal, this),
      thresh_ (thresh, this),
      reset_ (reset, this),
      C_ (C, this),
      leakConductance_ (leakConductance, this)
    {
    }

    IafCell::
    IafCell (const IafCell& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      leakReversal_ (x.leakReversal_, f, this),
      thresh_ (x.thresh_, f, this),
      reset_ (x.reset_, f, this),
      C_ (x.C_, f, this),
      leakConductance_ (x.leakConductance_, f, this)
    {
    }

    IafCell::
    IafCell (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      leakReversal_ (this),
      thresh_ (this),
      reset_ (this),
      C_ (this),
      leakConductance_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IafCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "leakReversal" && n.namespace_ ().empty ())
        {
          this->leakReversal_.set (LeakReversalTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "thresh" && n.namespace_ ().empty ())
        {
          this->thresh_.set (ThreshTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "reset" && n.namespace_ ().empty ())
        {
          this->reset_.set (ResetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "C" && n.namespace_ ().empty ())
        {
          this->C_.set (CTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "leakConductance" && n.namespace_ ().empty ())
        {
          this->leakConductance_.set (LeakConductanceTraits::create (i, f, this));
          continue;
        }
      }

      if (!leakReversal_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "leakReversal",
          "");
      }

      if (!thresh_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "thresh",
          "");
      }

      if (!reset_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reset",
          "");
      }

      if (!C_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "C",
          "");
      }

      if (!leakConductance_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "leakConductance",
          "");
      }
    }

    IafCell* IafCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IafCell (*this, f, c);
    }

    IafCell& IafCell::
    operator= (const IafCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->leakReversal_ = x.leakReversal_;
        this->thresh_ = x.thresh_;
        this->reset_ = x.reset_;
        this->C_ = x.C_;
        this->leakConductance_ = x.leakConductance_;
      }

      return *this;
    }

    IafCell::
    ~IafCell ()
    {
    }

    // IafRefCell
    //

    IafRefCell::
    IafRefCell (const IdType& id,
                const LeakReversalType& leakReversal,
                const ThreshType& thresh,
                const ResetType& reset,
                const CType& C,
                const LeakConductanceType& leakConductance,
                const RefractType& refract)
    : ::neurona::schema::IafCell (id,
                                  leakReversal,
                                  thresh,
                                  reset,
                                  C,
                                  leakConductance),
      refract_ (refract, this)
    {
    }

    IafRefCell::
    IafRefCell (const IafRefCell& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::IafCell (x, f, c),
      refract_ (x.refract_, f, this)
    {
    }

    IafRefCell::
    IafRefCell (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::IafCell (e, f | ::xml_schema::Flags::base, c),
      refract_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IafRefCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::IafCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "refract" && n.namespace_ ().empty ())
        {
          this->refract_.set (RefractTraits::create (i, f, this));
          continue;
        }
      }

      if (!refract_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "refract",
          "");
      }
    }

    IafRefCell* IafRefCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IafRefCell (*this, f, c);
    }

    IafRefCell& IafRefCell::
    operator= (const IafRefCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::IafCell& > (*this) = x;
        this->refract_ = x.refract_;
      }

      return *this;
    }

    IafRefCell::
    ~IafRefCell ()
    {
    }

    // IzhikevichCell
    //

    IzhikevichCell::
    IzhikevichCell (const IdType& id,
                    const V0Type& v0,
                    const ThreshType& thresh,
                    const AType& a,
                    const BType& b,
                    const CType& c,
                    const DType& d)
    : ::neurona::schema::BaseCell (id),
      v0_ (v0, this),
      thresh_ (thresh, this),
      a_ (a, this),
      b_ (b, this),
      c_ (c, this),
      d_ (d, this)
    {
    }

    IzhikevichCell::
    IzhikevichCell (const IzhikevichCell& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      v0_ (x.v0_, f, this),
      thresh_ (x.thresh_, f, this),
      a_ (x.a_, f, this),
      b_ (x.b_, f, this),
      c_ (x.c_, f, this),
      d_ (x.d_, f, this)
    {
    }

    IzhikevichCell::
    IzhikevichCell (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      v0_ (this),
      thresh_ (this),
      a_ (this),
      b_ (this),
      c_ (this),
      d_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void IzhikevichCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "v0" && n.namespace_ ().empty ())
        {
          this->v0_.set (V0Traits::create (i, f, this));
          continue;
        }

        if (n.name () == "thresh" && n.namespace_ ().empty ())
        {
          this->thresh_.set (ThreshTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "a" && n.namespace_ ().empty ())
        {
          this->a_.set (ATraits::create (i, f, this));
          continue;
        }

        if (n.name () == "b" && n.namespace_ ().empty ())
        {
          this->b_.set (BTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "c" && n.namespace_ ().empty ())
        {
          this->c_.set (CTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "d" && n.namespace_ ().empty ())
        {
          this->d_.set (DTraits::create (i, f, this));
          continue;
        }
      }

      if (!v0_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "v0",
          "");
      }

      if (!thresh_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "thresh",
          "");
      }

      if (!a_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "a",
          "");
      }

      if (!b_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "b",
          "");
      }

      if (!c_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "c",
          "");
      }

      if (!d_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "d",
          "");
      }
    }

    IzhikevichCell* IzhikevichCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IzhikevichCell (*this, f, c);
    }

    IzhikevichCell& IzhikevichCell::
    operator= (const IzhikevichCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->v0_ = x.v0_;
        this->thresh_ = x.thresh_;
        this->a_ = x.a_;
        this->b_ = x.b_;
        this->c_ = x.c_;
        this->d_ = x.d_;
      }

      return *this;
    }

    IzhikevichCell::
    ~IzhikevichCell ()
    {
    }

    // AdExIaFCell
    //

    AdExIaFCell::
    AdExIaFCell (const IdType& id,
                 const CType& C,
                 const GLType& gL,
                 const ELType& EL,
                 const ResetType& reset,
                 const VTType& VT,
                 const ThreshType& thresh,
                 const DelTType& delT,
                 const TauwType& tauw,
                 const RefractType& refract,
                 const AType& a,
                 const BType& b)
    : ::neurona::schema::BaseCell (id),
      C_ (C, this),
      gL_ (gL, this),
      EL_ (EL, this),
      reset_ (reset, this),
      VT_ (VT, this),
      thresh_ (thresh, this),
      delT_ (delT, this),
      tauw_ (tauw, this),
      refract_ (refract, this),
      a_ (a, this),
      b_ (b, this)
    {
    }

    AdExIaFCell::
    AdExIaFCell (const AdExIaFCell& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      C_ (x.C_, f, this),
      gL_ (x.gL_, f, this),
      EL_ (x.EL_, f, this),
      reset_ (x.reset_, f, this),
      VT_ (x.VT_, f, this),
      thresh_ (x.thresh_, f, this),
      delT_ (x.delT_, f, this),
      tauw_ (x.tauw_, f, this),
      refract_ (x.refract_, f, this),
      a_ (x.a_, f, this),
      b_ (x.b_, f, this)
    {
    }

    AdExIaFCell::
    AdExIaFCell (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      C_ (this),
      gL_ (this),
      EL_ (this),
      reset_ (this),
      VT_ (this),
      thresh_ (this),
      delT_ (this),
      tauw_ (this),
      refract_ (this),
      a_ (this),
      b_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AdExIaFCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "C" && n.namespace_ ().empty ())
        {
          this->C_.set (CTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "gL" && n.namespace_ ().empty ())
        {
          this->gL_.set (GLTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "EL" && n.namespace_ ().empty ())
        {
          this->EL_.set (ELTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "reset" && n.namespace_ ().empty ())
        {
          this->reset_.set (ResetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "VT" && n.namespace_ ().empty ())
        {
          this->VT_.set (VTTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "thresh" && n.namespace_ ().empty ())
        {
          this->thresh_.set (ThreshTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "delT" && n.namespace_ ().empty ())
        {
          this->delT_.set (DelTTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tauw" && n.namespace_ ().empty ())
        {
          this->tauw_.set (TauwTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "refract" && n.namespace_ ().empty ())
        {
          this->refract_.set (RefractTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "a" && n.namespace_ ().empty ())
        {
          this->a_.set (ATraits::create (i, f, this));
          continue;
        }

        if (n.name () == "b" && n.namespace_ ().empty ())
        {
          this->b_.set (BTraits::create (i, f, this));
          continue;
        }
      }

      if (!C_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "C",
          "");
      }

      if (!gL_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "gL",
          "");
      }

      if (!EL_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "EL",
          "");
      }

      if (!reset_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "reset",
          "");
      }

      if (!VT_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "VT",
          "");
      }

      if (!thresh_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "thresh",
          "");
      }

      if (!delT_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "delT",
          "");
      }

      if (!tauw_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "tauw",
          "");
      }

      if (!refract_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "refract",
          "");
      }

      if (!a_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "a",
          "");
      }

      if (!b_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "b",
          "");
      }
    }

    AdExIaFCell* AdExIaFCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AdExIaFCell (*this, f, c);
    }

    AdExIaFCell& AdExIaFCell::
    operator= (const AdExIaFCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->C_ = x.C_;
        this->gL_ = x.gL_;
        this->EL_ = x.EL_;
        this->reset_ = x.reset_;
        this->VT_ = x.VT_;
        this->thresh_ = x.thresh_;
        this->delT_ = x.delT_;
        this->tauw_ = x.tauw_;
        this->refract_ = x.refract_;
        this->a_ = x.a_;
        this->b_ = x.b_;
      }

      return *this;
    }

    AdExIaFCell::
    ~AdExIaFCell ()
    {
    }

    // FitzHughNagumoCell
    //

    FitzHughNagumoCell::
    FitzHughNagumoCell (const IdType& id,
                        const IType& I)
    : ::neurona::schema::BaseCell (id),
      I_ (I, this)
    {
    }

    FitzHughNagumoCell::
    FitzHughNagumoCell (const FitzHughNagumoCell& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      I_ (x.I_, f, this)
    {
    }

    FitzHughNagumoCell::
    FitzHughNagumoCell (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      I_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void FitzHughNagumoCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "I" && n.namespace_ ().empty ())
        {
          this->I_.set (ITraits::create (i, f, this));
          continue;
        }
      }

      if (!I_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "I",
          "");
      }
    }

    FitzHughNagumoCell* FitzHughNagumoCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FitzHughNagumoCell (*this, f, c);
    }

    FitzHughNagumoCell& FitzHughNagumoCell::
    operator= (const FitzHughNagumoCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->I_ = x.I_;
      }

      return *this;
    }

    FitzHughNagumoCell::
    ~FitzHughNagumoCell ()
    {
    }

    // Cell
    //

    const Cell::Morphology1Type Cell::morphology1_default_value_ (
      "1");

    const Cell::BiophysicalProperties1Type Cell::biophysicalProperties1_default_value_ (
      "1");

    Cell::
    Cell (const IdType& id)
    : ::neurona::schema::BaseCell (id),
      morphology_ (this),
      biophysicalProperties_ (this),
      morphology1_ (morphology1DefaultValue (), this),
      biophysicalProperties1_ (biophysicalProperties1DefaultValue (), this)
    {
    }

    Cell::
    Cell (const Cell& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      morphology_ (x.morphology_, f, this),
      biophysicalProperties_ (x.biophysicalProperties_, f, this),
      morphology1_ (x.morphology1_, f, this),
      biophysicalProperties1_ (x.biophysicalProperties1_, f, this)
    {
    }

    Cell::
    Cell (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      morphology_ (this),
      biophysicalProperties_ (this),
      morphology1_ (this),
      biophysicalProperties1_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Cell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // morphology
        //
        if (n.name () == "morphology" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< MorphologyType > r (
            MorphologyTraits::create (i, f, this));

          if (!this->morphology_)
          {
            this->morphology_.set (::std::move (r));
            continue;
          }
        }

        // biophysicalProperties
        //
        if (n.name () == "biophysicalProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< BiophysicalPropertiesType > r (
            BiophysicalPropertiesTraits::create (i, f, this));

          if (!this->biophysicalProperties_)
          {
            this->biophysicalProperties_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "morphology" && n.namespace_ ().empty ())
        {
          this->morphology1_.set (Morphology1Traits::create (i, f, this));
          continue;
        }

        if (n.name () == "biophysicalProperties" && n.namespace_ ().empty ())
        {
          this->biophysicalProperties1_.set (BiophysicalProperties1Traits::create (i, f, this));
          continue;
        }
      }

      if (!morphology1_.present ())
      {
        this->morphology1_.set (morphology1DefaultValue ());
      }

      if (!biophysicalProperties1_.present ())
      {
        this->biophysicalProperties1_.set (biophysicalProperties1DefaultValue ());
      }
    }

    Cell* Cell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Cell (*this, f, c);
    }

    Cell& Cell::
    operator= (const Cell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->morphology_ = x.morphology_;
        this->biophysicalProperties_ = x.biophysicalProperties_;
        this->morphology1_ = x.morphology1_;
        this->biophysicalProperties1_ = x.biophysicalProperties1_;
      }

      return *this;
    }

    Cell::
    ~Cell ()
    {
    }

    // Morphology
    //

    Morphology::
    Morphology (const IdType& id)
    : ::neurona::schema::Standalone (id),
      segment_ (this),
      segmentGroup_ (this)
    {
    }

    Morphology::
    Morphology (const Morphology& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      segment_ (x.segment_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this)
    {
    }

    Morphology::
    Morphology (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      segment_ (this),
      segmentGroup_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Morphology::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // segment
        //
        if (n.name () == "segment" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SegmentType > r (
            SegmentTraits::create (i, f, this));

          this->segment_.push_back (::std::move (r));
          continue;
        }

        // segmentGroup
        //
        if (n.name () == "segmentGroup" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SegmentGroupType > r (
            SegmentGroupTraits::create (i, f, this));

          this->segmentGroup_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    Morphology* Morphology::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Morphology (*this, f, c);
    }

    Morphology& Morphology::
    operator= (const Morphology& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->segment_ = x.segment_;
        this->segmentGroup_ = x.segmentGroup_;
      }

      return *this;
    }

    Morphology::
    ~Morphology ()
    {
    }

    // Segment
    //

    Segment::
    Segment (const DistalType& distal,
             const IdType& id)
    : ::neurona::schema::BaseWithoutId (),
      parent_ (this),
      proximal_ (this),
      distal_ (distal, this),
      id_ (id, this),
      name_ (this)
    {
    }

    Segment::
    Segment (::std::unique_ptr< DistalType > distal,
             const IdType& id)
    : ::neurona::schema::BaseWithoutId (),
      parent_ (this),
      proximal_ (this),
      distal_ (std::move (distal), this),
      id_ (id, this),
      name_ (this)
    {
    }

    Segment::
    Segment (const Segment& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::BaseWithoutId (x, f, c),
      parent_ (x.parent_, f, this),
      proximal_ (x.proximal_, f, this),
      distal_ (x.distal_, f, this),
      id_ (x.id_, f, this),
      name_ (x.name_, f, this)
    {
    }

    Segment::
    Segment (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::BaseWithoutId (e, f | ::xml_schema::Flags::base, c),
      parent_ (this),
      proximal_ (this),
      distal_ (this),
      id_ (this),
      name_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Segment::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseWithoutId::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // parent
        //
        if (n.name () == "parent" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ParentType > r (
            ParentTraits::create (i, f, this));

          if (!this->parent_)
          {
            this->parent_.set (::std::move (r));
            continue;
          }
        }

        // proximal
        //
        if (n.name () == "proximal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ProximalType > r (
            ProximalTraits::create (i, f, this));

          if (!this->proximal_)
          {
            this->proximal_.set (::std::move (r));
            continue;
          }
        }

        // distal
        //
        if (n.name () == "distal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< DistalType > r (
            DistalTraits::create (i, f, this));

          if (!distal_.present ())
          {
            this->distal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!distal_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "distal",
          "http://www.neuroml.org/schema/neuroml2");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    Segment* Segment::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Segment (*this, f, c);
    }

    Segment& Segment::
    operator= (const Segment& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseWithoutId& > (*this) = x;
        this->parent_ = x.parent_;
        this->proximal_ = x.proximal_;
        this->distal_ = x.distal_;
        this->id_ = x.id_;
        this->name_ = x.name_;
      }

      return *this;
    }

    Segment::
    ~Segment ()
    {
    }

    // SegmentParent
    //

    SegmentParent::
    SegmentParent (const SegmentType& segment)
    : ::xml_schema::Type (),
      segment_ (segment, this),
      fractionAlong_ (fractionAlongDefaultValue (), this)
    {
    }

    SegmentParent::
    SegmentParent (const SegmentParent& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      segment_ (x.segment_, f, this),
      fractionAlong_ (x.fractionAlong_, f, this)
    {
    }

    SegmentParent::
    SegmentParent (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      segment_ (this),
      fractionAlong_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SegmentParent::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "fractionAlong" && n.namespace_ ().empty ())
        {
          this->fractionAlong_.set (FractionAlongTraits::create (i, f, this));
          continue;
        }
      }

      if (!segment_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "segment",
          "");
      }

      if (!fractionAlong_.present ())
      {
        this->fractionAlong_.set (fractionAlongDefaultValue ());
      }
    }

    SegmentParent* SegmentParent::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SegmentParent (*this, f, c);
    }

    SegmentParent& SegmentParent::
    operator= (const SegmentParent& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->segment_ = x.segment_;
        this->fractionAlong_ = x.fractionAlong_;
      }

      return *this;
    }

    SegmentParent::
    ~SegmentParent ()
    {
    }

    // Point3DWithDiam
    //

    Point3DWithDiam::
    Point3DWithDiam (const XType& x,
                     const YType& y,
                     const ZType& z,
                     const DiameterType& diameter)
    : ::xml_schema::Type (),
      x_ (x, this),
      y_ (y, this),
      z_ (z, this),
      diameter_ (diameter, this)
    {
    }

    Point3DWithDiam::
    Point3DWithDiam (const Point3DWithDiam& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this),
      diameter_ (x.diameter_, f, this)
    {
    }

    Point3DWithDiam::
    Point3DWithDiam (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      x_ (this),
      y_ (this),
      z_ (this),
      diameter_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Point3DWithDiam::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (XTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (YTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "z" && n.namespace_ ().empty ())
        {
          this->z_.set (ZTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "diameter" && n.namespace_ ().empty ())
        {
          this->diameter_.set (DiameterTraits::create (i, f, this));
          continue;
        }
      }

      if (!x_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "x",
          "");
      }

      if (!y_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "y",
          "");
      }

      if (!z_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "z",
          "");
      }

      if (!diameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "diameter",
          "");
      }
    }

    Point3DWithDiam* Point3DWithDiam::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Point3DWithDiam (*this, f, c);
    }

    Point3DWithDiam& Point3DWithDiam::
    operator= (const Point3DWithDiam& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
        this->diameter_ = x.diameter_;
      }

      return *this;
    }

    Point3DWithDiam::
    ~Point3DWithDiam ()
    {
    }

    // SegmentGroup
    //

    SegmentGroup::
    SegmentGroup (const IdType& id)
    : ::neurona::schema::Base (id),
      notes_ (this),
      annotation_ (this),
      member_ (this),
      include_ (this),
      path_ (this),
      subTree_ (this),
      inhomogeneousParameter_ (this)
    {
    }

    SegmentGroup::
    SegmentGroup (const SegmentGroup& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      notes_ (x.notes_, f, this),
      annotation_ (x.annotation_, f, this),
      member_ (x.member_, f, this),
      include_ (x.include_, f, this),
      path_ (x.path_, f, this),
      subTree_ (x.subTree_, f, this),
      inhomogeneousParameter_ (x.inhomogeneousParameter_, f, this)
    {
    }

    SegmentGroup::
    SegmentGroup (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      notes_ (this),
      annotation_ (this),
      member_ (this),
      include_ (this),
      path_ (this),
      subTree_ (this),
      inhomogeneousParameter_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SegmentGroup::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // notes
        //
        if (n.name () == "notes" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< NotesType > r (
            NotesTraits::create (i, f, this));

          if (!this->notes_)
          {
            this->notes_.set (::std::move (r));
            continue;
          }
        }

        // annotation
        //
        if (n.name () == "annotation" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< AnnotationType > r (
            AnnotationTraits::create (i, f, this));

          if (!this->annotation_)
          {
            this->annotation_.set (::std::move (r));
            continue;
          }
        }

        // member
        //
        if (n.name () == "member" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< MemberType > r (
            MemberTraits::create (i, f, this));

          this->member_.push_back (::std::move (r));
          continue;
        }

        // include
        //
        if (n.name () == "include" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IncludeType > r (
            IncludeTraits::create (i, f, this));

          this->include_.push_back (::std::move (r));
          continue;
        }

        // path
        //
        if (n.name () == "path" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< PathType > r (
            PathTraits::create (i, f, this));

          this->path_.push_back (::std::move (r));
          continue;
        }

        // subTree
        //
        if (n.name () == "subTree" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SubTreeType > r (
            SubTreeTraits::create (i, f, this));

          this->subTree_.push_back (::std::move (r));
          continue;
        }

        // inhomogeneousParameter
        //
        if (n.name () == "inhomogeneousParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< InhomogeneousParameterType > r (
            InhomogeneousParameterTraits::create (i, f, this));

          this->inhomogeneousParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    SegmentGroup* SegmentGroup::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SegmentGroup (*this, f, c);
    }

    SegmentGroup& SegmentGroup::
    operator= (const SegmentGroup& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->notes_ = x.notes_;
        this->annotation_ = x.annotation_;
        this->member_ = x.member_;
        this->include_ = x.include_;
        this->path_ = x.path_;
        this->subTree_ = x.subTree_;
        this->inhomogeneousParameter_ = x.inhomogeneousParameter_;
      }

      return *this;
    }

    SegmentGroup::
    ~SegmentGroup ()
    {
    }

    // InhomogeneousParameter
    //

    InhomogeneousParameter::
    InhomogeneousParameter (const IdType& id,
                            const VariableType& variable,
                            const MetricType& metric)
    : ::neurona::schema::Base (id),
      proximal_ (this),
      distal_ (this),
      variable_ (variable, this),
      metric_ (metric, this)
    {
    }

    InhomogeneousParameter::
    InhomogeneousParameter (const InhomogeneousParameter& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      proximal_ (x.proximal_, f, this),
      distal_ (x.distal_, f, this),
      variable_ (x.variable_, f, this),
      metric_ (x.metric_, f, this)
    {
    }

    InhomogeneousParameter::
    InhomogeneousParameter (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      proximal_ (this),
      distal_ (this),
      variable_ (this),
      metric_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void InhomogeneousParameter::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // proximal
        //
        if (n.name () == "proximal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ProximalType > r (
            ProximalTraits::create (i, f, this));

          if (!this->proximal_)
          {
            this->proximal_.set (::std::move (r));
            continue;
          }
        }

        // distal
        //
        if (n.name () == "distal" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< DistalType > r (
            DistalTraits::create (i, f, this));

          if (!this->distal_)
          {
            this->distal_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "variable" && n.namespace_ ().empty ())
        {
          this->variable_.set (VariableTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "metric" && n.namespace_ ().empty ())
        {
          this->metric_.set (MetricTraits::create (i, f, this));
          continue;
        }
      }

      if (!variable_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "variable",
          "");
      }

      if (!metric_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "metric",
          "");
      }
    }

    InhomogeneousParameter* InhomogeneousParameter::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class InhomogeneousParameter (*this, f, c);
    }

    InhomogeneousParameter& InhomogeneousParameter::
    operator= (const InhomogeneousParameter& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->proximal_ = x.proximal_;
        this->distal_ = x.distal_;
        this->variable_ = x.variable_;
        this->metric_ = x.metric_;
      }

      return *this;
    }

    InhomogeneousParameter::
    ~InhomogeneousParameter ()
    {
    }

    // Metric
    //

    Metric::
    Metric (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_Metric_convert ();
    }

    Metric::
    Metric (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_Metric_convert ();
    }

    Metric::
    Metric (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_Metric_convert ();
    }

    Metric* Metric::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Metric (*this, f, c);
    }

    Metric::Value Metric::
    _xsd_Metric_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Metric_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_Metric_indexes_,
                        _xsd_Metric_indexes_ + 1,
                        *this,
                        c));

      if (i == _xsd_Metric_indexes_ + 1 || _xsd_Metric_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const Metric::
    _xsd_Metric_literals_[1] =
    {
      "Path Length from root"
    };

    const Metric::Value Metric::
    _xsd_Metric_indexes_[1] =
    {
      ::neurona::schema::Metric::Path_Length_from_root
    };

    // ProximalDetails
    //

    ProximalDetails::
    ProximalDetails (const TranslationStartType& translationStart)
    : ::xml_schema::Type (),
      translationStart_ (translationStart, this)
    {
    }

    ProximalDetails::
    ProximalDetails (const ProximalDetails& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      translationStart_ (x.translationStart_, f, this)
    {
    }

    ProximalDetails::
    ProximalDetails (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      translationStart_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ProximalDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "translationStart" && n.namespace_ ().empty ())
        {
          this->translationStart_.set (TranslationStartTraits::create (i, f, this));
          continue;
        }
      }

      if (!translationStart_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "translationStart",
          "");
      }
    }

    ProximalDetails* ProximalDetails::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ProximalDetails (*this, f, c);
    }

    ProximalDetails& ProximalDetails::
    operator= (const ProximalDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->translationStart_ = x.translationStart_;
      }

      return *this;
    }

    ProximalDetails::
    ~ProximalDetails ()
    {
    }

    // DistalDetails
    //

    DistalDetails::
    DistalDetails (const NormalizationEndType& normalizationEnd)
    : ::xml_schema::Type (),
      normalizationEnd_ (normalizationEnd, this)
    {
    }

    DistalDetails::
    DistalDetails (const DistalDetails& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      normalizationEnd_ (x.normalizationEnd_, f, this)
    {
    }

    DistalDetails::
    DistalDetails (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      normalizationEnd_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DistalDetails::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "normalizationEnd" && n.namespace_ ().empty ())
        {
          this->normalizationEnd_.set (NormalizationEndTraits::create (i, f, this));
          continue;
        }
      }

      if (!normalizationEnd_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "normalizationEnd",
          "");
      }
    }

    DistalDetails* DistalDetails::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DistalDetails (*this, f, c);
    }

    DistalDetails& DistalDetails::
    operator= (const DistalDetails& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->normalizationEnd_ = x.normalizationEnd_;
      }

      return *this;
    }

    DistalDetails::
    ~DistalDetails ()
    {
    }

    // Member
    //

    Member::
    Member (const SegmentType& segment)
    : ::xml_schema::Type (),
      segment_ (segment, this)
    {
    }

    Member::
    Member (const Member& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      segment_ (x.segment_, f, this)
    {
    }

    Member::
    Member (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      segment_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Member::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }
      }

      if (!segment_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "segment",
          "");
      }
    }

    Member* Member::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Member (*this, f, c);
    }

    Member& Member::
    operator= (const Member& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->segment_ = x.segment_;
      }

      return *this;
    }

    Member::
    ~Member ()
    {
    }

    // Include
    //

    Include::
    Include (const SegmentGroupType& segmentGroup)
    : ::xml_schema::Type (),
      segmentGroup_ (segmentGroup, this)
    {
    }

    Include::
    Include (const Include& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      segmentGroup_ (x.segmentGroup_, f, this)
    {
    }

    Include::
    Include (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      segmentGroup_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Include::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }
      }

      if (!segmentGroup_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "segmentGroup",
          "");
      }
    }

    Include* Include::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Include (*this, f, c);
    }

    Include& Include::
    operator= (const Include& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->segmentGroup_ = x.segmentGroup_;
      }

      return *this;
    }

    Include::
    ~Include ()
    {
    }

    // Path
    //

    Path::
    Path ()
    : ::xml_schema::Type (),
      from_ (this),
      to_ (this)
    {
    }

    Path::
    Path (const Path& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      from_ (x.from_, f, this),
      to_ (x.to_, f, this)
    {
    }

    Path::
    Path (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      from_ (this),
      to_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Path::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // from
        //
        if (n.name () == "from" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< FromType > r (
            FromTraits::create (i, f, this));

          if (!this->from_)
          {
            this->from_.set (::std::move (r));
            continue;
          }
        }

        // to
        //
        if (n.name () == "to" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ToType > r (
            ToTraits::create (i, f, this));

          if (!this->to_)
          {
            this->to_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Path* Path::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Path (*this, f, c);
    }

    Path& Path::
    operator= (const Path& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->from_ = x.from_;
        this->to_ = x.to_;
      }

      return *this;
    }

    Path::
    ~Path ()
    {
    }

    // SubTree
    //

    SubTree::
    SubTree ()
    : ::xml_schema::Type (),
      from_ (this),
      to_ (this)
    {
    }

    SubTree::
    SubTree (const SubTree& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      from_ (x.from_, f, this),
      to_ (x.to_, f, this)
    {
    }

    SubTree::
    SubTree (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      from_ (this),
      to_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SubTree::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // from
        //
        if (n.name () == "from" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< FromType > r (
            FromTraits::create (i, f, this));

          if (!this->from_)
          {
            this->from_.set (::std::move (r));
            continue;
          }
        }

        // to
        //
        if (n.name () == "to" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ToType > r (
            ToTraits::create (i, f, this));

          if (!this->to_)
          {
            this->to_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SubTree* SubTree::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SubTree (*this, f, c);
    }

    SubTree& SubTree::
    operator= (const SubTree& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->from_ = x.from_;
        this->to_ = x.to_;
      }

      return *this;
    }

    SubTree::
    ~SubTree ()
    {
    }

    // SegmentEndPoint
    //

    SegmentEndPoint::
    SegmentEndPoint (const SegmentType& segment)
    : ::xml_schema::Type (),
      segment_ (segment, this)
    {
    }

    SegmentEndPoint::
    SegmentEndPoint (const SegmentEndPoint& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      segment_ (x.segment_, f, this)
    {
    }

    SegmentEndPoint::
    SegmentEndPoint (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      segment_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SegmentEndPoint::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }
      }

      if (!segment_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "segment",
          "");
      }
    }

    SegmentEndPoint* SegmentEndPoint::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SegmentEndPoint (*this, f, c);
    }

    SegmentEndPoint& SegmentEndPoint::
    operator= (const SegmentEndPoint& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->segment_ = x.segment_;
      }

      return *this;
    }

    SegmentEndPoint::
    ~SegmentEndPoint ()
    {
    }

    // BiophysicalProperties
    //

    BiophysicalProperties::
    BiophysicalProperties (const IdType& id,
                           const MembranePropertiesType& membraneProperties)
    : ::neurona::schema::Standalone (id),
      membraneProperties_ (membraneProperties, this),
      intracellularProperties_ (this),
      extracellularProperties_ (this)
    {
    }

    BiophysicalProperties::
    BiophysicalProperties (const IdType& id,
                           ::std::unique_ptr< MembranePropertiesType > membraneProperties)
    : ::neurona::schema::Standalone (id),
      membraneProperties_ (std::move (membraneProperties), this),
      intracellularProperties_ (this),
      extracellularProperties_ (this)
    {
    }

    BiophysicalProperties::
    BiophysicalProperties (const BiophysicalProperties& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      membraneProperties_ (x.membraneProperties_, f, this),
      intracellularProperties_ (x.intracellularProperties_, f, this),
      extracellularProperties_ (x.extracellularProperties_, f, this)
    {
    }

    BiophysicalProperties::
    BiophysicalProperties (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      membraneProperties_ (this),
      intracellularProperties_ (this),
      extracellularProperties_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BiophysicalProperties::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // membraneProperties
        //
        if (n.name () == "membraneProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< MembranePropertiesType > r (
            MembranePropertiesTraits::create (i, f, this));

          if (!membraneProperties_.present ())
          {
            this->membraneProperties_.set (::std::move (r));
            continue;
          }
        }

        // intracellularProperties
        //
        if (n.name () == "intracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< IntracellularPropertiesType > r (
            IntracellularPropertiesTraits::create (i, f, this));

          if (!this->intracellularProperties_)
          {
            this->intracellularProperties_.set (::std::move (r));
            continue;
          }
        }

        // extracellularProperties
        //
        if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExtracellularPropertiesType > r (
            ExtracellularPropertiesTraits::create (i, f, this));

          if (!this->extracellularProperties_)
          {
            this->extracellularProperties_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!membraneProperties_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "membraneProperties",
          "http://www.neuroml.org/schema/neuroml2");
      }
    }

    BiophysicalProperties* BiophysicalProperties::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BiophysicalProperties (*this, f, c);
    }

    BiophysicalProperties& BiophysicalProperties::
    operator= (const BiophysicalProperties& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->membraneProperties_ = x.membraneProperties_;
        this->intracellularProperties_ = x.intracellularProperties_;
        this->extracellularProperties_ = x.extracellularProperties_;
      }

      return *this;
    }

    BiophysicalProperties::
    ~BiophysicalProperties ()
    {
    }

    // MembraneProperties
    //

    MembraneProperties::
    MembraneProperties ()
    : ::xml_schema::Type (),
      channelPopulation_ (this),
      channelDensity_ (this),
      channelDensityNernst_ (this),
      channelDensityGHK_ (this),
      channelDensityNonUniform_ (this),
      channelDensityNonUniformNernst_ (this),
      spikeThresh_ (this),
      specificCapacitance_ (this),
      initMembPotential_ (this)
    {
    }

    MembraneProperties::
    MembraneProperties (const MembraneProperties& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      channelPopulation_ (x.channelPopulation_, f, this),
      channelDensity_ (x.channelDensity_, f, this),
      channelDensityNernst_ (x.channelDensityNernst_, f, this),
      channelDensityGHK_ (x.channelDensityGHK_, f, this),
      channelDensityNonUniform_ (x.channelDensityNonUniform_, f, this),
      channelDensityNonUniformNernst_ (x.channelDensityNonUniformNernst_, f, this),
      spikeThresh_ (x.spikeThresh_, f, this),
      specificCapacitance_ (x.specificCapacitance_, f, this),
      initMembPotential_ (x.initMembPotential_, f, this)
    {
    }

    MembraneProperties::
    MembraneProperties (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      channelPopulation_ (this),
      channelDensity_ (this),
      channelDensityNernst_ (this),
      channelDensityGHK_ (this),
      channelDensityNonUniform_ (this),
      channelDensityNonUniformNernst_ (this),
      spikeThresh_ (this),
      specificCapacitance_ (this),
      initMembPotential_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void MembraneProperties::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // channelPopulation
        //
        if (n.name () == "channelPopulation" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ChannelPopulationType > r (
            ChannelPopulationTraits::create (i, f, this));

          this->channelPopulation_.push_back (::std::move (r));
          continue;
        }

        // channelDensity
        //
        if (n.name () == "channelDensity" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ChannelDensityType > r (
            ChannelDensityTraits::create (i, f, this));

          this->channelDensity_.push_back (::std::move (r));
          continue;
        }

        // channelDensityNernst
        //
        if (n.name () == "channelDensityNernst" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ChannelDensityNernstType > r (
            ChannelDensityNernstTraits::create (i, f, this));

          this->channelDensityNernst_.push_back (::std::move (r));
          continue;
        }

        // channelDensityGHK
        //
        if (n.name () == "channelDensityGHK" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ChannelDensityGHKType > r (
            ChannelDensityGHKTraits::create (i, f, this));

          this->channelDensityGHK_.push_back (::std::move (r));
          continue;
        }

        // channelDensityNonUniform
        //
        if (n.name () == "channelDensityNonUniform" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ChannelDensityNonUniformType > r (
            ChannelDensityNonUniformTraits::create (i, f, this));

          this->channelDensityNonUniform_.push_back (::std::move (r));
          continue;
        }

        // channelDensityNonUniformNernst
        //
        if (n.name () == "channelDensityNonUniformNernst" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ChannelDensityNonUniformNernstType > r (
            ChannelDensityNonUniformNernstTraits::create (i, f, this));

          this->channelDensityNonUniformNernst_.push_back (::std::move (r));
          continue;
        }

        // spikeThresh
        //
        if (n.name () == "spikeThresh" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeThreshType > r (
            SpikeThreshTraits::create (i, f, this));

          this->spikeThresh_.push_back (::std::move (r));
          continue;
        }

        // specificCapacitance
        //
        if (n.name () == "specificCapacitance" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpecificCapacitanceType > r (
            SpecificCapacitanceTraits::create (i, f, this));

          this->specificCapacitance_.push_back (::std::move (r));
          continue;
        }

        // initMembPotential
        //
        if (n.name () == "initMembPotential" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< InitMembPotentialType > r (
            InitMembPotentialTraits::create (i, f, this));

          this->initMembPotential_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    MembraneProperties* MembraneProperties::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MembraneProperties (*this, f, c);
    }

    MembraneProperties& MembraneProperties::
    operator= (const MembraneProperties& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->channelPopulation_ = x.channelPopulation_;
        this->channelDensity_ = x.channelDensity_;
        this->channelDensityNernst_ = x.channelDensityNernst_;
        this->channelDensityGHK_ = x.channelDensityGHK_;
        this->channelDensityNonUniform_ = x.channelDensityNonUniform_;
        this->channelDensityNonUniformNernst_ = x.channelDensityNonUniformNernst_;
        this->spikeThresh_ = x.spikeThresh_;
        this->specificCapacitance_ = x.specificCapacitance_;
        this->initMembPotential_ = x.initMembPotential_;
      }

      return *this;
    }

    MembraneProperties::
    ~MembraneProperties ()
    {
    }

    // ValueAcrossSegOrSegGroup
    //

    const ValueAcrossSegOrSegGroup::SegmentGroupType ValueAcrossSegOrSegGroup::segmentGroup_default_value_ (
      "all");

    ValueAcrossSegOrSegGroup::
    ValueAcrossSegOrSegGroup ()
    : ::xml_schema::Type (),
      value_ (this),
      segmentGroup_ (segmentGroupDefaultValue (), this),
      segment_ (this)
    {
    }

    ValueAcrossSegOrSegGroup::
    ValueAcrossSegOrSegGroup (const ValueAcrossSegOrSegGroup& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      value_ (x.value_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this),
      segment_ (x.segment_, f, this)
    {
    }

    ValueAcrossSegOrSegGroup::
    ValueAcrossSegOrSegGroup (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      value_ (this),
      segmentGroup_ (this),
      segment_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ValueAcrossSegOrSegGroup::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }
      }

      if (!segmentGroup_.present ())
      {
        this->segmentGroup_.set (segmentGroupDefaultValue ());
      }
    }

    ValueAcrossSegOrSegGroup* ValueAcrossSegOrSegGroup::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ValueAcrossSegOrSegGroup (*this, f, c);
    }

    ValueAcrossSegOrSegGroup& ValueAcrossSegOrSegGroup::
    operator= (const ValueAcrossSegOrSegGroup& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->value_ = x.value_;
        this->segmentGroup_ = x.segmentGroup_;
        this->segment_ = x.segment_;
      }

      return *this;
    }

    ValueAcrossSegOrSegGroup::
    ~ValueAcrossSegOrSegGroup ()
    {
    }

    // SpikeThresh
    //

    SpikeThresh::
    SpikeThresh ()
    : ::neurona::schema::ValueAcrossSegOrSegGroup ()
    {
    }

    SpikeThresh::
    SpikeThresh (const SpikeThresh& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (x, f, c)
    {
    }

    SpikeThresh::
    SpikeThresh (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (e, f, c)
    {
    }

    SpikeThresh* SpikeThresh::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpikeThresh (*this, f, c);
    }

    SpikeThresh::
    ~SpikeThresh ()
    {
    }

    // SpecificCapacitance
    //

    SpecificCapacitance::
    SpecificCapacitance ()
    : ::neurona::schema::ValueAcrossSegOrSegGroup ()
    {
    }

    SpecificCapacitance::
    SpecificCapacitance (const SpecificCapacitance& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (x, f, c)
    {
    }

    SpecificCapacitance::
    SpecificCapacitance (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (e, f, c)
    {
    }

    SpecificCapacitance* SpecificCapacitance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpecificCapacitance (*this, f, c);
    }

    SpecificCapacitance::
    ~SpecificCapacitance ()
    {
    }

    // InitMembPotential
    //

    InitMembPotential::
    InitMembPotential ()
    : ::neurona::schema::ValueAcrossSegOrSegGroup ()
    {
    }

    InitMembPotential::
    InitMembPotential (const InitMembPotential& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (x, f, c)
    {
    }

    InitMembPotential::
    InitMembPotential (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (e, f, c)
    {
    }

    InitMembPotential* InitMembPotential::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class InitMembPotential (*this, f, c);
    }

    InitMembPotential::
    ~InitMembPotential ()
    {
    }

    // Resistivity
    //

    Resistivity::
    Resistivity ()
    : ::neurona::schema::ValueAcrossSegOrSegGroup ()
    {
    }

    Resistivity::
    Resistivity (const Resistivity& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (x, f, c)
    {
    }

    Resistivity::
    Resistivity (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (e, f, c)
    {
    }

    Resistivity* Resistivity::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Resistivity (*this, f, c);
    }

    Resistivity::
    ~Resistivity ()
    {
    }

    // ChannelPopulation
    //

    const ChannelPopulation::SegmentGroupType ChannelPopulation::segmentGroup_default_value_ (
      "all");

    ChannelPopulation::
    ChannelPopulation (const IdType& id,
                       const IonChannelType& ionChannel,
                       const NumberType& number,
                       const ErevType& erev)
    : ::neurona::schema::Base (id),
      variableParameter_ (this),
      ionChannel_ (ionChannel, this),
      number_ (number, this),
      erev_ (erev, this),
      segmentGroup_ (segmentGroupDefaultValue (), this),
      segment_ (this),
      ion_ (this)
    {
    }

    ChannelPopulation::
    ChannelPopulation (const ChannelPopulation& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      variableParameter_ (x.variableParameter_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      number_ (x.number_, f, this),
      erev_ (x.erev_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this),
      segment_ (x.segment_, f, this),
      ion_ (x.ion_, f, this)
    {
    }

    ChannelPopulation::
    ChannelPopulation (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      variableParameter_ (this),
      ionChannel_ (this),
      number_ (this),
      erev_ (this),
      segmentGroup_ (this),
      segment_ (this),
      ion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChannelPopulation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // variableParameter
        //
        if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VariableParameterType > r (
            VariableParameterTraits::create (i, f, this));

          this->variableParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ionChannel" && n.namespace_ ().empty ())
        {
          this->ionChannel_.set (IonChannelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "number" && n.namespace_ ().empty ())
        {
          this->number_.set (NumberTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "erev" && n.namespace_ ().empty ())
        {
          this->erev_.set (ErevTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }
      }

      if (!ionChannel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ionChannel",
          "");
      }

      if (!number_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "number",
          "");
      }

      if (!erev_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "erev",
          "");
      }

      if (!segmentGroup_.present ())
      {
        this->segmentGroup_.set (segmentGroupDefaultValue ());
      }
    }

    ChannelPopulation* ChannelPopulation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelPopulation (*this, f, c);
    }

    ChannelPopulation& ChannelPopulation::
    operator= (const ChannelPopulation& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->variableParameter_ = x.variableParameter_;
        this->ionChannel_ = x.ionChannel_;
        this->number_ = x.number_;
        this->erev_ = x.erev_;
        this->segmentGroup_ = x.segmentGroup_;
        this->segment_ = x.segment_;
        this->ion_ = x.ion_;
      }

      return *this;
    }

    ChannelPopulation::
    ~ChannelPopulation ()
    {
    }

    // ChannelDensityNonUniform
    //

    ChannelDensityNonUniform::
    ChannelDensityNonUniform (const IdType& id,
                              const IonChannelType& ionChannel,
                              const ErevType& erev)
    : ::neurona::schema::Base (id),
      variableParameter_ (this),
      ionChannel_ (ionChannel, this),
      erev_ (erev, this),
      ion_ (this)
    {
    }

    ChannelDensityNonUniform::
    ChannelDensityNonUniform (const ChannelDensityNonUniform& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      variableParameter_ (x.variableParameter_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      erev_ (x.erev_, f, this),
      ion_ (x.ion_, f, this)
    {
    }

    ChannelDensityNonUniform::
    ChannelDensityNonUniform (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      variableParameter_ (this),
      ionChannel_ (this),
      erev_ (this),
      ion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChannelDensityNonUniform::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // variableParameter
        //
        if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VariableParameterType > r (
            VariableParameterTraits::create (i, f, this));

          this->variableParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ionChannel" && n.namespace_ ().empty ())
        {
          this->ionChannel_.set (IonChannelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "erev" && n.namespace_ ().empty ())
        {
          this->erev_.set (ErevTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }
      }

      if (!ionChannel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ionChannel",
          "");
      }

      if (!erev_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "erev",
          "");
      }
    }

    ChannelDensityNonUniform* ChannelDensityNonUniform::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelDensityNonUniform (*this, f, c);
    }

    ChannelDensityNonUniform& ChannelDensityNonUniform::
    operator= (const ChannelDensityNonUniform& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->variableParameter_ = x.variableParameter_;
        this->ionChannel_ = x.ionChannel_;
        this->erev_ = x.erev_;
        this->ion_ = x.ion_;
      }

      return *this;
    }

    ChannelDensityNonUniform::
    ~ChannelDensityNonUniform ()
    {
    }

    // ChannelDensityNonUniformNernst
    //

    ChannelDensityNonUniformNernst::
    ChannelDensityNonUniformNernst (const IdType& id,
                                    const IonChannelType& ionChannel)
    : ::neurona::schema::Base (id),
      variableParameter_ (this),
      ionChannel_ (ionChannel, this),
      ion_ (this)
    {
    }

    ChannelDensityNonUniformNernst::
    ChannelDensityNonUniformNernst (const ChannelDensityNonUniformNernst& x,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      variableParameter_ (x.variableParameter_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      ion_ (x.ion_, f, this)
    {
    }

    ChannelDensityNonUniformNernst::
    ChannelDensityNonUniformNernst (const ::xercesc::DOMElement& e,
                                    ::xml_schema::Flags f,
                                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      variableParameter_ (this),
      ionChannel_ (this),
      ion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChannelDensityNonUniformNernst::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // variableParameter
        //
        if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VariableParameterType > r (
            VariableParameterTraits::create (i, f, this));

          this->variableParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ionChannel" && n.namespace_ ().empty ())
        {
          this->ionChannel_.set (IonChannelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }
      }

      if (!ionChannel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ionChannel",
          "");
      }
    }

    ChannelDensityNonUniformNernst* ChannelDensityNonUniformNernst::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelDensityNonUniformNernst (*this, f, c);
    }

    ChannelDensityNonUniformNernst& ChannelDensityNonUniformNernst::
    operator= (const ChannelDensityNonUniformNernst& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->variableParameter_ = x.variableParameter_;
        this->ionChannel_ = x.ionChannel_;
        this->ion_ = x.ion_;
      }

      return *this;
    }

    ChannelDensityNonUniformNernst::
    ~ChannelDensityNonUniformNernst ()
    {
    }

    // ChannelDensity
    //

    const ChannelDensity::SegmentGroupType ChannelDensity::segmentGroup_default_value_ (
      "all");

    ChannelDensity::
    ChannelDensity (const IdType& id,
                    const IonChannelType& ionChannel,
                    const ErevType& erev)
    : ::neurona::schema::Base (id),
      variableParameter_ (this),
      ionChannel_ (ionChannel, this),
      condDensity_ (this),
      erev_ (erev, this),
      segmentGroup_ (segmentGroupDefaultValue (), this),
      segment_ (this),
      ion_ (this)
    {
    }

    ChannelDensity::
    ChannelDensity (const ChannelDensity& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      variableParameter_ (x.variableParameter_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      condDensity_ (x.condDensity_, f, this),
      erev_ (x.erev_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this),
      segment_ (x.segment_, f, this),
      ion_ (x.ion_, f, this)
    {
    }

    ChannelDensity::
    ChannelDensity (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      variableParameter_ (this),
      ionChannel_ (this),
      condDensity_ (this),
      erev_ (this),
      segmentGroup_ (this),
      segment_ (this),
      ion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChannelDensity::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // variableParameter
        //
        if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VariableParameterType > r (
            VariableParameterTraits::create (i, f, this));

          this->variableParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ionChannel" && n.namespace_ ().empty ())
        {
          this->ionChannel_.set (IonChannelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "condDensity" && n.namespace_ ().empty ())
        {
          this->condDensity_.set (CondDensityTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "erev" && n.namespace_ ().empty ())
        {
          this->erev_.set (ErevTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }
      }

      if (!ionChannel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ionChannel",
          "");
      }

      if (!erev_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "erev",
          "");
      }

      if (!segmentGroup_.present ())
      {
        this->segmentGroup_.set (segmentGroupDefaultValue ());
      }
    }

    ChannelDensity* ChannelDensity::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelDensity (*this, f, c);
    }

    ChannelDensity& ChannelDensity::
    operator= (const ChannelDensity& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->variableParameter_ = x.variableParameter_;
        this->ionChannel_ = x.ionChannel_;
        this->condDensity_ = x.condDensity_;
        this->erev_ = x.erev_;
        this->segmentGroup_ = x.segmentGroup_;
        this->segment_ = x.segment_;
        this->ion_ = x.ion_;
      }

      return *this;
    }

    ChannelDensity::
    ~ChannelDensity ()
    {
    }

    // ChannelDensityNernst
    //

    const ChannelDensityNernst::SegmentGroupType ChannelDensityNernst::segmentGroup_default_value_ (
      "all");

    ChannelDensityNernst::
    ChannelDensityNernst (const IdType& id,
                          const IonChannelType& ionChannel)
    : ::neurona::schema::Base (id),
      variableParameter_ (this),
      ionChannel_ (ionChannel, this),
      condDensity_ (this),
      segmentGroup_ (segmentGroupDefaultValue (), this),
      segment_ (this),
      ion_ (this)
    {
    }

    ChannelDensityNernst::
    ChannelDensityNernst (const ChannelDensityNernst& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      variableParameter_ (x.variableParameter_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      condDensity_ (x.condDensity_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this),
      segment_ (x.segment_, f, this),
      ion_ (x.ion_, f, this)
    {
    }

    ChannelDensityNernst::
    ChannelDensityNernst (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      variableParameter_ (this),
      ionChannel_ (this),
      condDensity_ (this),
      segmentGroup_ (this),
      segment_ (this),
      ion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChannelDensityNernst::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // variableParameter
        //
        if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VariableParameterType > r (
            VariableParameterTraits::create (i, f, this));

          this->variableParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ionChannel" && n.namespace_ ().empty ())
        {
          this->ionChannel_.set (IonChannelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "condDensity" && n.namespace_ ().empty ())
        {
          this->condDensity_.set (CondDensityTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }
      }

      if (!ionChannel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ionChannel",
          "");
      }

      if (!segmentGroup_.present ())
      {
        this->segmentGroup_.set (segmentGroupDefaultValue ());
      }
    }

    ChannelDensityNernst* ChannelDensityNernst::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelDensityNernst (*this, f, c);
    }

    ChannelDensityNernst& ChannelDensityNernst::
    operator= (const ChannelDensityNernst& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->variableParameter_ = x.variableParameter_;
        this->ionChannel_ = x.ionChannel_;
        this->condDensity_ = x.condDensity_;
        this->segmentGroup_ = x.segmentGroup_;
        this->segment_ = x.segment_;
        this->ion_ = x.ion_;
      }

      return *this;
    }

    ChannelDensityNernst::
    ~ChannelDensityNernst ()
    {
    }

    // ChannelDensityGHK
    //

    const ChannelDensityGHK::SegmentGroupType ChannelDensityGHK::segmentGroup_default_value_ (
      "all");

    ChannelDensityGHK::
    ChannelDensityGHK (const IdType& id,
                       const IonChannelType& ionChannel,
                       const PermeabilityType& permeability)
    : ::neurona::schema::Base (id),
      variableParameter_ (this),
      ionChannel_ (ionChannel, this),
      permeability_ (permeability, this),
      segmentGroup_ (segmentGroupDefaultValue (), this),
      segment_ (this),
      ion_ (this)
    {
    }

    ChannelDensityGHK::
    ChannelDensityGHK (const ChannelDensityGHK& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      variableParameter_ (x.variableParameter_, f, this),
      ionChannel_ (x.ionChannel_, f, this),
      permeability_ (x.permeability_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this),
      segment_ (x.segment_, f, this),
      ion_ (x.ion_, f, this)
    {
    }

    ChannelDensityGHK::
    ChannelDensityGHK (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      variableParameter_ (this),
      ionChannel_ (this),
      permeability_ (this),
      segmentGroup_ (this),
      segment_ (this),
      ion_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ChannelDensityGHK::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // variableParameter
        //
        if (n.name () == "variableParameter" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< VariableParameterType > r (
            VariableParameterTraits::create (i, f, this));

          this->variableParameter_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ionChannel" && n.namespace_ ().empty ())
        {
          this->ionChannel_.set (IonChannelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "permeability" && n.namespace_ ().empty ())
        {
          this->permeability_.set (PermeabilityTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segment" && n.namespace_ ().empty ())
        {
          this->segment_.set (SegmentTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }
      }

      if (!ionChannel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ionChannel",
          "");
      }

      if (!permeability_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "permeability",
          "");
      }

      if (!segmentGroup_.present ())
      {
        this->segmentGroup_.set (segmentGroupDefaultValue ());
      }
    }

    ChannelDensityGHK* ChannelDensityGHK::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ChannelDensityGHK (*this, f, c);
    }

    ChannelDensityGHK& ChannelDensityGHK::
    operator= (const ChannelDensityGHK& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->variableParameter_ = x.variableParameter_;
        this->ionChannel_ = x.ionChannel_;
        this->permeability_ = x.permeability_;
        this->segmentGroup_ = x.segmentGroup_;
        this->segment_ = x.segment_;
        this->ion_ = x.ion_;
      }

      return *this;
    }

    ChannelDensityGHK::
    ~ChannelDensityGHK ()
    {
    }

    // VariableParameter
    //

    VariableParameter::
    VariableParameter (const ParameterType& parameter,
                       const SegmentGroupType& segmentGroup)
    : ::xml_schema::Type (),
      inhomogeneousValue_ (this),
      parameter_ (parameter, this),
      segmentGroup_ (segmentGroup, this)
    {
    }

    VariableParameter::
    VariableParameter (const VariableParameter& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      inhomogeneousValue_ (x.inhomogeneousValue_, f, this),
      parameter_ (x.parameter_, f, this),
      segmentGroup_ (x.segmentGroup_, f, this)
    {
    }

    VariableParameter::
    VariableParameter (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      inhomogeneousValue_ (this),
      parameter_ (this),
      segmentGroup_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VariableParameter::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // inhomogeneousValue
        //
        if (n.name () == "inhomogeneousValue" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< InhomogeneousValueType > r (
            InhomogeneousValueTraits::create (i, f, this));

          if (!this->inhomogeneousValue_)
          {
            this->inhomogeneousValue_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "parameter" && n.namespace_ ().empty ())
        {
          this->parameter_.set (ParameterTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentGroup" && n.namespace_ ().empty ())
        {
          this->segmentGroup_.set (SegmentGroupTraits::create (i, f, this));
          continue;
        }
      }

      if (!parameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "parameter",
          "");
      }

      if (!segmentGroup_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "segmentGroup",
          "");
      }
    }

    VariableParameter* VariableParameter::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class VariableParameter (*this, f, c);
    }

    VariableParameter& VariableParameter::
    operator= (const VariableParameter& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->inhomogeneousValue_ = x.inhomogeneousValue_;
        this->parameter_ = x.parameter_;
        this->segmentGroup_ = x.segmentGroup_;
      }

      return *this;
    }

    VariableParameter::
    ~VariableParameter ()
    {
    }

    // InhomogeneousValue
    //

    InhomogeneousValue::
    InhomogeneousValue (const InhomogeneousParameterType& inhomogeneousParameter,
                        const ValueType& value)
    : ::xml_schema::Type (),
      inhomogeneousParameter_ (inhomogeneousParameter, this),
      value_ (value, this)
    {
    }

    InhomogeneousValue::
    InhomogeneousValue (const InhomogeneousValue& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      inhomogeneousParameter_ (x.inhomogeneousParameter_, f, this),
      value_ (x.value_, f, this)
    {
    }

    InhomogeneousValue::
    InhomogeneousValue (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      inhomogeneousParameter_ (this),
      value_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void InhomogeneousValue::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "inhomogeneousParameter" && n.namespace_ ().empty ())
        {
          this->inhomogeneousParameter_.set (InhomogeneousParameterTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!inhomogeneousParameter_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "inhomogeneousParameter",
          "");
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    InhomogeneousValue* InhomogeneousValue::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class InhomogeneousValue (*this, f, c);
    }

    InhomogeneousValue& InhomogeneousValue::
    operator= (const InhomogeneousValue& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->inhomogeneousParameter_ = x.inhomogeneousParameter_;
        this->value_ = x.value_;
      }

      return *this;
    }

    InhomogeneousValue::
    ~InhomogeneousValue ()
    {
    }

    // Species
    //

    Species::
    Species (const IdType& id,
             const ConcentrationModelType& concentrationModel,
             const InitialConcentrationType& initialConcentration,
             const InitialExtConcentrationType& initialExtConcentration)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (),
      id_ (id, this),
      concentrationModel_ (concentrationModel, this),
      ion_ (this),
      initialConcentration_ (initialConcentration, this),
      initialExtConcentration_ (initialExtConcentration, this)
    {
    }

    Species::
    Species (const Species& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (x, f, c),
      id_ (x.id_, f, this),
      concentrationModel_ (x.concentrationModel_, f, this),
      ion_ (x.ion_, f, this),
      initialConcentration_ (x.initialConcentration_, f, this),
      initialExtConcentration_ (x.initialExtConcentration_, f, this)
    {
    }

    Species::
    Species (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::ValueAcrossSegOrSegGroup (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      concentrationModel_ (this),
      ion_ (this),
      initialConcentration_ (this),
      initialExtConcentration_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Species::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::ValueAcrossSegOrSegGroup::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "concentrationModel" && n.namespace_ ().empty ())
        {
          this->concentrationModel_.set (ConcentrationModelTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ion" && n.namespace_ ().empty ())
        {
          this->ion_.set (IonTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "initialConcentration" && n.namespace_ ().empty ())
        {
          this->initialConcentration_.set (InitialConcentrationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "initialExtConcentration" && n.namespace_ ().empty ())
        {
          this->initialExtConcentration_.set (InitialExtConcentrationTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!concentrationModel_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "concentrationModel",
          "");
      }

      if (!initialConcentration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "initialConcentration",
          "");
      }

      if (!initialExtConcentration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "initialExtConcentration",
          "");
      }
    }

    Species* Species::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Species (*this, f, c);
    }

    Species& Species::
    operator= (const Species& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::ValueAcrossSegOrSegGroup& > (*this) = x;
        this->id_ = x.id_;
        this->concentrationModel_ = x.concentrationModel_;
        this->ion_ = x.ion_;
        this->initialConcentration_ = x.initialConcentration_;
        this->initialExtConcentration_ = x.initialExtConcentration_;
      }

      return *this;
    }

    Species::
    ~Species ()
    {
    }

    // ConcentrationModel_D
    //

    const ConcentrationModel_D::TypeType ConcentrationModel_D::type_default_value_ (
      ::xml_schema::SimpleType ("decayingPoolConcentrationModel"));

    ConcentrationModel_D::
    ConcentrationModel_D (const IdType& id,
                          const IonType& ion,
                          const RestingConcType& restingConc,
                          const DecayConstantType& decayConstant,
                          const ShellThicknessType& shellThickness)
    : ::neurona::schema::DecayingPoolConcentrationModel (id,
                                                         ion,
                                                         restingConc,
                                                         decayConstant,
                                                         shellThickness),
      type_ (typeDefaultValue (), this)
    {
    }

    ConcentrationModel_D::
    ConcentrationModel_D (const ConcentrationModel_D& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::neurona::schema::DecayingPoolConcentrationModel (x, f, c),
      type_ (x.type_, f, this)
    {
    }

    ConcentrationModel_D::
    ConcentrationModel_D (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::neurona::schema::DecayingPoolConcentrationModel (e, f | ::xml_schema::Flags::base, c),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ConcentrationModel_D::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::DecayingPoolConcentrationModel::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!type_.present ())
      {
        this->type_.set (typeDefaultValue ());
      }
    }

    ConcentrationModel_D* ConcentrationModel_D::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ConcentrationModel_D (*this, f, c);
    }

    ConcentrationModel_D& ConcentrationModel_D::
    operator= (const ConcentrationModel_D& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::DecayingPoolConcentrationModel& > (*this) = x;
        this->type_ = x.type_;
      }

      return *this;
    }

    ConcentrationModel_D::
    ~ConcentrationModel_D ()
    {
    }

    // IntracellularProperties
    //

    IntracellularProperties::
    IntracellularProperties ()
    : ::xml_schema::Type (),
      species_ (this),
      resistivity_ (this)
    {
    }

    IntracellularProperties::
    IntracellularProperties (const IntracellularProperties& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      species_ (x.species_, f, this),
      resistivity_ (x.resistivity_, f, this)
    {
    }

    IntracellularProperties::
    IntracellularProperties (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      species_ (this),
      resistivity_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void IntracellularProperties::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // species
        //
        if (n.name () == "species" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpeciesType > r (
            SpeciesTraits::create (i, f, this));

          this->species_.push_back (::std::move (r));
          continue;
        }

        // resistivity
        //
        if (n.name () == "resistivity" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ResistivityType > r (
            ResistivityTraits::create (i, f, this));

          this->resistivity_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    IntracellularProperties* IntracellularProperties::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IntracellularProperties (*this, f, c);
    }

    IntracellularProperties& IntracellularProperties::
    operator= (const IntracellularProperties& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->species_ = x.species_;
        this->resistivity_ = x.resistivity_;
      }

      return *this;
    }

    IntracellularProperties::
    ~IntracellularProperties ()
    {
    }

    // ExtracellularProperties
    //

    ExtracellularProperties::
    ExtracellularProperties (const IdType& id)
    : ::neurona::schema::Base (id),
      species_ (this)
    {
    }

    ExtracellularProperties::
    ExtracellularProperties (const ExtracellularProperties& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      species_ (x.species_, f, this)
    {
    }

    ExtracellularProperties::
    ExtracellularProperties (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      species_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExtracellularProperties::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // species
        //
        if (n.name () == "species" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpeciesType > r (
            SpeciesTraits::create (i, f, this));

          this->species_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ExtracellularProperties* ExtracellularProperties::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExtracellularProperties (*this, f, c);
    }

    ExtracellularProperties& ExtracellularProperties::
    operator= (const ExtracellularProperties& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->species_ = x.species_;
      }

      return *this;
    }

    ExtracellularProperties::
    ~ExtracellularProperties ()
    {
    }

    // ExtracellularPropertiesLocal
    //

    ExtracellularPropertiesLocal::
    ExtracellularPropertiesLocal ()
    : ::xml_schema::Type (),
      species_ (this)
    {
    }

    ExtracellularPropertiesLocal::
    ExtracellularPropertiesLocal (const ExtracellularPropertiesLocal& x,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      species_ (x.species_, f, this)
    {
    }

    ExtracellularPropertiesLocal::
    ExtracellularPropertiesLocal (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f,
                                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      species_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void ExtracellularPropertiesLocal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // species
        //
        if (n.name () == "species" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpeciesType > r (
            SpeciesTraits::create (i, f, this));

          this->species_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    ExtracellularPropertiesLocal* ExtracellularPropertiesLocal::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExtracellularPropertiesLocal (*this, f, c);
    }

    ExtracellularPropertiesLocal& ExtracellularPropertiesLocal::
    operator= (const ExtracellularPropertiesLocal& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->species_ = x.species_;
      }

      return *this;
    }

    ExtracellularPropertiesLocal::
    ~ExtracellularPropertiesLocal ()
    {
    }

    // ReactionScheme
    //

    ReactionScheme::
    ReactionScheme (const IdType& id,
                    const SourceType& source,
                    const TypeType& type)
    : ::neurona::schema::Base (id),
      source_ (source, this),
      type_ (type, this)
    {
    }

    ReactionScheme::
    ReactionScheme (const ReactionScheme& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      source_ (x.source_, f, this),
      type_ (x.type_, f, this)
    {
    }

    ReactionScheme::
    ReactionScheme (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      source_ (this),
      type_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ReactionScheme::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "source" && n.namespace_ ().empty ())
        {
          this->source_.set (SourceTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }
      }

      if (!source_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "source",
          "");
      }

      if (!type_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "type",
          "");
      }
    }

    ReactionScheme* ReactionScheme::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ReactionScheme (*this, f, c);
    }

    ReactionScheme& ReactionScheme::
    operator= (const ReactionScheme& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->source_ = x.source_;
        this->type_ = x.type_;
      }

      return *this;
    }

    ReactionScheme::
    ~ReactionScheme ()
    {
    }

    // PulseGenerator
    //

    PulseGenerator::
    PulseGenerator (const IdType& id,
                    const DelayType& delay,
                    const DurationType& duration,
                    const AmplitudeType& amplitude)
    : ::neurona::schema::Standalone (id),
      delay_ (delay, this),
      duration_ (duration, this),
      amplitude_ (amplitude, this)
    {
    }

    PulseGenerator::
    PulseGenerator (const PulseGenerator& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      delay_ (x.delay_, f, this),
      duration_ (x.duration_, f, this),
      amplitude_ (x.amplitude_, f, this)
    {
    }

    PulseGenerator::
    PulseGenerator (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      delay_ (this),
      duration_ (this),
      amplitude_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PulseGenerator::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "delay" && n.namespace_ ().empty ())
        {
          this->delay_.set (DelayTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "duration" && n.namespace_ ().empty ())
        {
          this->duration_.set (DurationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "amplitude" && n.namespace_ ().empty ())
        {
          this->amplitude_.set (AmplitudeTraits::create (i, f, this));
          continue;
        }
      }

      if (!delay_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "delay",
          "");
      }

      if (!duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "duration",
          "");
      }

      if (!amplitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "amplitude",
          "");
      }
    }

    PulseGenerator* PulseGenerator::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PulseGenerator (*this, f, c);
    }

    PulseGenerator& PulseGenerator::
    operator= (const PulseGenerator& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->delay_ = x.delay_;
        this->duration_ = x.duration_;
        this->amplitude_ = x.amplitude_;
      }

      return *this;
    }

    PulseGenerator::
    ~PulseGenerator ()
    {
    }

    // SineGenerator
    //

    SineGenerator::
    SineGenerator (const IdType& id,
                   const DelayType& delay,
                   const PhaseType& phase,
                   const DurationType& duration,
                   const AmplitudeType& amplitude,
                   const PeriodType& period)
    : ::neurona::schema::Standalone (id),
      delay_ (delay, this),
      phase_ (phase, this),
      duration_ (duration, this),
      amplitude_ (amplitude, this),
      period_ (period, this)
    {
    }

    SineGenerator::
    SineGenerator (const SineGenerator& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      delay_ (x.delay_, f, this),
      phase_ (x.phase_, f, this),
      duration_ (x.duration_, f, this),
      amplitude_ (x.amplitude_, f, this),
      period_ (x.period_, f, this)
    {
    }

    SineGenerator::
    SineGenerator (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      delay_ (this),
      phase_ (this),
      duration_ (this),
      amplitude_ (this),
      period_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SineGenerator::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "delay" && n.namespace_ ().empty ())
        {
          this->delay_.set (DelayTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "phase" && n.namespace_ ().empty ())
        {
          this->phase_.set (PhaseTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "duration" && n.namespace_ ().empty ())
        {
          this->duration_.set (DurationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "amplitude" && n.namespace_ ().empty ())
        {
          this->amplitude_.set (AmplitudeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "period" && n.namespace_ ().empty ())
        {
          this->period_.set (PeriodTraits::create (i, f, this));
          continue;
        }
      }

      if (!delay_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "delay",
          "");
      }

      if (!phase_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "phase",
          "");
      }

      if (!duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "duration",
          "");
      }

      if (!amplitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "amplitude",
          "");
      }

      if (!period_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "period",
          "");
      }
    }

    SineGenerator* SineGenerator::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SineGenerator (*this, f, c);
    }

    SineGenerator& SineGenerator::
    operator= (const SineGenerator& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->delay_ = x.delay_;
        this->phase_ = x.phase_;
        this->duration_ = x.duration_;
        this->amplitude_ = x.amplitude_;
        this->period_ = x.period_;
      }

      return *this;
    }

    SineGenerator::
    ~SineGenerator ()
    {
    }

    // RampGenerator
    //

    RampGenerator::
    RampGenerator (const IdType& id,
                   const DelayType& delay,
                   const DurationType& duration,
                   const StartAmplitudeType& startAmplitude,
                   const FinishAmplitudeType& finishAmplitude,
                   const BaselineAmplitudeType& baselineAmplitude)
    : ::neurona::schema::Standalone (id),
      delay_ (delay, this),
      duration_ (duration, this),
      startAmplitude_ (startAmplitude, this),
      finishAmplitude_ (finishAmplitude, this),
      baselineAmplitude_ (baselineAmplitude, this)
    {
    }

    RampGenerator::
    RampGenerator (const RampGenerator& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      delay_ (x.delay_, f, this),
      duration_ (x.duration_, f, this),
      startAmplitude_ (x.startAmplitude_, f, this),
      finishAmplitude_ (x.finishAmplitude_, f, this),
      baselineAmplitude_ (x.baselineAmplitude_, f, this)
    {
    }

    RampGenerator::
    RampGenerator (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      delay_ (this),
      duration_ (this),
      startAmplitude_ (this),
      finishAmplitude_ (this),
      baselineAmplitude_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void RampGenerator::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "delay" && n.namespace_ ().empty ())
        {
          this->delay_.set (DelayTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "duration" && n.namespace_ ().empty ())
        {
          this->duration_.set (DurationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "startAmplitude" && n.namespace_ ().empty ())
        {
          this->startAmplitude_.set (StartAmplitudeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "finishAmplitude" && n.namespace_ ().empty ())
        {
          this->finishAmplitude_.set (FinishAmplitudeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "baselineAmplitude" && n.namespace_ ().empty ())
        {
          this->baselineAmplitude_.set (BaselineAmplitudeTraits::create (i, f, this));
          continue;
        }
      }

      if (!delay_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "delay",
          "");
      }

      if (!duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "duration",
          "");
      }

      if (!startAmplitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "startAmplitude",
          "");
      }

      if (!finishAmplitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "finishAmplitude",
          "");
      }

      if (!baselineAmplitude_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "baselineAmplitude",
          "");
      }
    }

    RampGenerator* RampGenerator::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RampGenerator (*this, f, c);
    }

    RampGenerator& RampGenerator::
    operator= (const RampGenerator& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->delay_ = x.delay_;
        this->duration_ = x.duration_;
        this->startAmplitude_ = x.startAmplitude_;
        this->finishAmplitude_ = x.finishAmplitude_;
        this->baselineAmplitude_ = x.baselineAmplitude_;
      }

      return *this;
    }

    RampGenerator::
    ~RampGenerator ()
    {
    }

    // VoltageClamp
    //

    VoltageClamp::
    VoltageClamp (const IdType& id,
                  const DelayType& delay,
                  const DurationType& duration,
                  const TargetVoltageType& targetVoltage,
                  const SimpleSeriesResistanceType& simpleSeriesResistance)
    : ::neurona::schema::Standalone (id),
      delay_ (delay, this),
      duration_ (duration, this),
      targetVoltage_ (targetVoltage, this),
      simpleSeriesResistance_ (simpleSeriesResistance, this)
    {
    }

    VoltageClamp::
    VoltageClamp (const VoltageClamp& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      delay_ (x.delay_, f, this),
      duration_ (x.duration_, f, this),
      targetVoltage_ (x.targetVoltage_, f, this),
      simpleSeriesResistance_ (x.simpleSeriesResistance_, f, this)
    {
    }

    VoltageClamp::
    VoltageClamp (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      delay_ (this),
      duration_ (this),
      targetVoltage_ (this),
      simpleSeriesResistance_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void VoltageClamp::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "delay" && n.namespace_ ().empty ())
        {
          this->delay_.set (DelayTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "duration" && n.namespace_ ().empty ())
        {
          this->duration_.set (DurationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "targetVoltage" && n.namespace_ ().empty ())
        {
          this->targetVoltage_.set (TargetVoltageTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "simpleSeriesResistance" && n.namespace_ ().empty ())
        {
          this->simpleSeriesResistance_.set (SimpleSeriesResistanceTraits::create (i, f, this));
          continue;
        }
      }

      if (!delay_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "delay",
          "");
      }

      if (!duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "duration",
          "");
      }

      if (!targetVoltage_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "targetVoltage",
          "");
      }

      if (!simpleSeriesResistance_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "simpleSeriesResistance",
          "");
      }
    }

    VoltageClamp* VoltageClamp::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class VoltageClamp (*this, f, c);
    }

    VoltageClamp& VoltageClamp::
    operator= (const VoltageClamp& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->delay_ = x.delay_;
        this->duration_ = x.duration_;
        this->targetVoltage_ = x.targetVoltage_;
        this->simpleSeriesResistance_ = x.simpleSeriesResistance_;
      }

      return *this;
    }

    VoltageClamp::
    ~VoltageClamp ()
    {
    }

    // Spike
    //

    Spike::
    Spike (const IdType& id,
           const TimeType& time)
    : ::neurona::schema::Standalone (id),
      time_ (time, this)
    {
    }

    Spike::
    Spike (const Spike& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      time_ (x.time_, f, this)
    {
    }

    Spike::
    Spike (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      time_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Spike::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "time" && n.namespace_ ().empty ())
        {
          this->time_.set (TimeTraits::create (i, f, this));
          continue;
        }
      }

      if (!time_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "time",
          "");
      }
    }

    Spike* Spike::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Spike (*this, f, c);
    }

    Spike& Spike::
    operator= (const Spike& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->time_ = x.time_;
      }

      return *this;
    }

    Spike::
    ~Spike ()
    {
    }

    // SpikeArray
    //

    SpikeArray::
    SpikeArray (const IdType& id)
    : ::neurona::schema::Standalone (id),
      spike_ (this)
    {
    }

    SpikeArray::
    SpikeArray (const SpikeArray& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      spike_ (x.spike_, f, this)
    {
    }

    SpikeArray::
    SpikeArray (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      spike_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpikeArray::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // spike
        //
        if (n.name () == "spike" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpikeType > r (
            SpikeTraits::create (i, f, this));

          this->spike_.push_back (::std::move (r));
          continue;
        }

        break;
      }
    }

    SpikeArray* SpikeArray::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpikeArray (*this, f, c);
    }

    SpikeArray& SpikeArray::
    operator= (const SpikeArray& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->spike_ = x.spike_;
      }

      return *this;
    }

    SpikeArray::
    ~SpikeArray ()
    {
    }

    // SpikeGenerator
    //

    SpikeGenerator::
    SpikeGenerator (const IdType& id,
                    const PeriodType& period)
    : ::neurona::schema::Standalone (id),
      period_ (period, this)
    {
    }

    SpikeGenerator::
    SpikeGenerator (const SpikeGenerator& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      period_ (x.period_, f, this)
    {
    }

    SpikeGenerator::
    SpikeGenerator (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      period_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpikeGenerator::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "period" && n.namespace_ ().empty ())
        {
          this->period_.set (PeriodTraits::create (i, f, this));
          continue;
        }
      }

      if (!period_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "period",
          "");
      }
    }

    SpikeGenerator* SpikeGenerator::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpikeGenerator (*this, f, c);
    }

    SpikeGenerator& SpikeGenerator::
    operator= (const SpikeGenerator& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->period_ = x.period_;
      }

      return *this;
    }

    SpikeGenerator::
    ~SpikeGenerator ()
    {
    }

    // SpikeGeneratorRandom
    //

    SpikeGeneratorRandom::
    SpikeGeneratorRandom (const IdType& id,
                          const MaxISIType& maxISI,
                          const MinISIType& minISI)
    : ::neurona::schema::Standalone (id),
      maxISI_ (maxISI, this),
      minISI_ (minISI, this)
    {
    }

    SpikeGeneratorRandom::
    SpikeGeneratorRandom (const SpikeGeneratorRandom& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      maxISI_ (x.maxISI_, f, this),
      minISI_ (x.minISI_, f, this)
    {
    }

    SpikeGeneratorRandom::
    SpikeGeneratorRandom (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      maxISI_ (this),
      minISI_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpikeGeneratorRandom::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "maxISI" && n.namespace_ ().empty ())
        {
          this->maxISI_.set (MaxISITraits::create (i, f, this));
          continue;
        }

        if (n.name () == "minISI" && n.namespace_ ().empty ())
        {
          this->minISI_.set (MinISITraits::create (i, f, this));
          continue;
        }
      }

      if (!maxISI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "maxISI",
          "");
      }

      if (!minISI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "minISI",
          "");
      }
    }

    SpikeGeneratorRandom* SpikeGeneratorRandom::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpikeGeneratorRandom (*this, f, c);
    }

    SpikeGeneratorRandom& SpikeGeneratorRandom::
    operator= (const SpikeGeneratorRandom& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->maxISI_ = x.maxISI_;
        this->minISI_ = x.minISI_;
      }

      return *this;
    }

    SpikeGeneratorRandom::
    ~SpikeGeneratorRandom ()
    {
    }

    // SpikeGeneratorPoisson
    //

    SpikeGeneratorPoisson::
    SpikeGeneratorPoisson (const IdType& id,
                           const AverageRateType& averageRate)
    : ::neurona::schema::Standalone (id),
      averageRate_ (averageRate, this)
    {
    }

    SpikeGeneratorPoisson::
    SpikeGeneratorPoisson (const SpikeGeneratorPoisson& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      averageRate_ (x.averageRate_, f, this)
    {
    }

    SpikeGeneratorPoisson::
    SpikeGeneratorPoisson (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      averageRate_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpikeGeneratorPoisson::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "averageRate" && n.namespace_ ().empty ())
        {
          this->averageRate_.set (AverageRateTraits::create (i, f, this));
          continue;
        }
      }

      if (!averageRate_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "averageRate",
          "");
      }
    }

    SpikeGeneratorPoisson* SpikeGeneratorPoisson::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpikeGeneratorPoisson (*this, f, c);
    }

    SpikeGeneratorPoisson& SpikeGeneratorPoisson::
    operator= (const SpikeGeneratorPoisson& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->averageRate_ = x.averageRate_;
      }

      return *this;
    }

    SpikeGeneratorPoisson::
    ~SpikeGeneratorPoisson ()
    {
    }

    // Network
    //

    Network::
    Network (const IdType& id)
    : ::neurona::schema::Standalone (id),
      space_ (this),
      region_ (this),
      extracellularProperties_ (this),
      population_ (this),
      cellSet_ (this),
      synapticConnection_ (this),
      projection_ (this),
      explicitInput_ (this),
      inputList_ (this),
      type_ (this),
      temperature_ (this)
    {
    }

    Network::
    Network (const Network& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      space_ (x.space_, f, this),
      region_ (x.region_, f, this),
      extracellularProperties_ (x.extracellularProperties_, f, this),
      population_ (x.population_, f, this),
      cellSet_ (x.cellSet_, f, this),
      synapticConnection_ (x.synapticConnection_, f, this),
      projection_ (x.projection_, f, this),
      explicitInput_ (x.explicitInput_, f, this),
      inputList_ (x.inputList_, f, this),
      type_ (x.type_, f, this),
      temperature_ (x.temperature_, f, this)
    {
    }

    Network::
    Network (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      space_ (this),
      region_ (this),
      extracellularProperties_ (this),
      population_ (this),
      cellSet_ (this),
      synapticConnection_ (this),
      projection_ (this),
      explicitInput_ (this),
      inputList_ (this),
      type_ (this),
      temperature_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Network::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // space
        //
        if (n.name () == "space" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SpaceType > r (
            SpaceTraits::create (i, f, this));

          this->space_.push_back (::std::move (r));
          continue;
        }

        // region
        //
        if (n.name () == "region" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< RegionType > r (
            RegionTraits::create (i, f, this));

          this->region_.push_back (::std::move (r));
          continue;
        }

        // extracellularProperties
        //
        if (n.name () == "extracellularProperties" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExtracellularPropertiesType > r (
            ExtracellularPropertiesTraits::create (i, f, this));

          this->extracellularProperties_.push_back (::std::move (r));
          continue;
        }

        // population
        //
        if (n.name () == "population" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< PopulationType > r (
            PopulationTraits::create (i, f, this));

          this->population_.push_back (::std::move (r));
          continue;
        }

        // cellSet
        //
        if (n.name () == "cellSet" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< CellSetType > r (
            CellSetTraits::create (i, f, this));

          this->cellSet_.push_back (::std::move (r));
          continue;
        }

        // synapticConnection
        //
        if (n.name () == "synapticConnection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< SynapticConnectionType > r (
            SynapticConnectionTraits::create (i, f, this));

          this->synapticConnection_.push_back (::std::move (r));
          continue;
        }

        // projection
        //
        if (n.name () == "projection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ProjectionType > r (
            ProjectionTraits::create (i, f, this));

          this->projection_.push_back (::std::move (r));
          continue;
        }

        // explicitInput
        //
        if (n.name () == "explicitInput" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ExplicitInputType > r (
            ExplicitInputTraits::create (i, f, this));

          this->explicitInput_.push_back (::std::move (r));
          continue;
        }

        // inputList
        //
        if (n.name () == "inputList" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< InputListType > r (
            InputListTraits::create (i, f, this));

          this->inputList_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "temperature" && n.namespace_ ().empty ())
        {
          this->temperature_.set (TemperatureTraits::create (i, f, this));
          continue;
        }
      }
    }

    Network* Network::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Network (*this, f, c);
    }

    Network& Network::
    operator= (const Network& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->space_ = x.space_;
        this->region_ = x.region_;
        this->extracellularProperties_ = x.extracellularProperties_;
        this->population_ = x.population_;
        this->cellSet_ = x.cellSet_;
        this->synapticConnection_ = x.synapticConnection_;
        this->projection_ = x.projection_;
        this->explicitInput_ = x.explicitInput_;
        this->inputList_ = x.inputList_;
        this->type_ = x.type_;
        this->temperature_ = x.temperature_;
      }

      return *this;
    }

    Network::
    ~Network ()
    {
    }

    // NetworkTypes
    //

    NetworkTypes::
    NetworkTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_NetworkTypes_convert ();
    }

    NetworkTypes::
    NetworkTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_NetworkTypes_convert ();
    }

    NetworkTypes::
    NetworkTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_NetworkTypes_convert ();
    }

    NetworkTypes* NetworkTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class NetworkTypes (*this, f, c);
    }

    NetworkTypes::Value NetworkTypes::
    _xsd_NetworkTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_NetworkTypes_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_NetworkTypes_indexes_,
                        _xsd_NetworkTypes_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_NetworkTypes_indexes_ + 2 || _xsd_NetworkTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const NetworkTypes::
    _xsd_NetworkTypes_literals_[2] =
    {
      "network",
      "networkWithTemperature"
    };

    const NetworkTypes::Value NetworkTypes::
    _xsd_NetworkTypes_indexes_[2] =
    {
      ::neurona::schema::NetworkTypes::network,
      ::neurona::schema::NetworkTypes::networkWithTemperature
    };

    // Space
    //

    Space::
    Space (const IdType& id)
    : ::neurona::schema::Base (id),
      structure_ (this),
      basedOn_ (this)
    {
    }

    Space::
    Space (const Space& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      structure_ (x.structure_, f, this),
      basedOn_ (x.basedOn_, f, this)
    {
    }

    Space::
    Space (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      structure_ (this),
      basedOn_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Space::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // structure
        //
        if (n.name () == "structure" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< StructureType > r (
            StructureTraits::create (i, f, this));

          if (!this->structure_)
          {
            this->structure_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "basedOn" && n.namespace_ ().empty ())
        {
          this->basedOn_.set (BasedOnTraits::create (i, f, this));
          continue;
        }
      }
    }

    Space* Space::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Space (*this, f, c);
    }

    Space& Space::
    operator= (const Space& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->structure_ = x.structure_;
        this->basedOn_ = x.basedOn_;
      }

      return *this;
    }

    Space::
    ~Space ()
    {
    }

    // SpaceStructure
    //

    SpaceStructure::
    SpaceStructure ()
    : ::xml_schema::Type (),
      xSpacing_ (this),
      ySpacing_ (this),
      zSpacing_ (this),
      xStart_ (xStartDefaultValue (), this),
      yStart_ (yStartDefaultValue (), this),
      zStart_ (zStartDefaultValue (), this)
    {
    }

    SpaceStructure::
    SpaceStructure (const SpaceStructure& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      xSpacing_ (x.xSpacing_, f, this),
      ySpacing_ (x.ySpacing_, f, this),
      zSpacing_ (x.zSpacing_, f, this),
      xStart_ (x.xStart_, f, this),
      yStart_ (x.yStart_, f, this),
      zStart_ (x.zStart_, f, this)
    {
    }

    SpaceStructure::
    SpaceStructure (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      xSpacing_ (this),
      ySpacing_ (this),
      zSpacing_ (this),
      xStart_ (this),
      yStart_ (this),
      zStart_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SpaceStructure::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "xSpacing" && n.namespace_ ().empty ())
        {
          this->xSpacing_.set (XSpacingTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySpacing" && n.namespace_ ().empty ())
        {
          this->ySpacing_.set (YSpacingTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSpacing" && n.namespace_ ().empty ())
        {
          this->zSpacing_.set (ZSpacingTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "xStart" && n.namespace_ ().empty ())
        {
          this->xStart_.set (XStartTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "yStart" && n.namespace_ ().empty ())
        {
          this->yStart_.set (YStartTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "zStart" && n.namespace_ ().empty ())
        {
          this->zStart_.set (ZStartTraits::create (i, f, this));
          continue;
        }
      }

      if (!xStart_.present ())
      {
        this->xStart_.set (xStartDefaultValue ());
      }

      if (!yStart_.present ())
      {
        this->yStart_.set (yStartDefaultValue ());
      }

      if (!zStart_.present ())
      {
        this->zStart_.set (zStartDefaultValue ());
      }
    }

    SpaceStructure* SpaceStructure::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpaceStructure (*this, f, c);
    }

    SpaceStructure& SpaceStructure::
    operator= (const SpaceStructure& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->xSpacing_ = x.xSpacing_;
        this->ySpacing_ = x.ySpacing_;
        this->zSpacing_ = x.zSpacing_;
        this->xStart_ = x.xStart_;
        this->yStart_ = x.yStart_;
        this->zStart_ = x.zStart_;
      }

      return *this;
    }

    SpaceStructure::
    ~SpaceStructure ()
    {
    }

    // AllowedSpaces
    //

    AllowedSpaces::
    AllowedSpaces (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_AllowedSpaces_convert ();
    }

    AllowedSpaces::
    AllowedSpaces (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_AllowedSpaces_convert ();
    }

    AllowedSpaces::
    AllowedSpaces (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_AllowedSpaces_convert ();
    }

    AllowedSpaces* AllowedSpaces::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AllowedSpaces (*this, f, c);
    }

    AllowedSpaces::Value AllowedSpaces::
    _xsd_AllowedSpaces_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AllowedSpaces_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_AllowedSpaces_indexes_,
                        _xsd_AllowedSpaces_indexes_ + 6,
                        *this,
                        c));

      if (i == _xsd_AllowedSpaces_indexes_ + 6 || _xsd_AllowedSpaces_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const AllowedSpaces::
    _xsd_AllowedSpaces_literals_[6] =
    {
      "Euclidean_1D",
      "Euclidean_2D",
      "Euclidean_3D",
      "Grid_1D",
      "Grid_2D",
      "Grid_3D"
    };

    const AllowedSpaces::Value AllowedSpaces::
    _xsd_AllowedSpaces_indexes_[6] =
    {
      ::neurona::schema::AllowedSpaces::Euclidean_1D,
      ::neurona::schema::AllowedSpaces::Euclidean_2D,
      ::neurona::schema::AllowedSpaces::Euclidean_3D,
      ::neurona::schema::AllowedSpaces::Grid_1D,
      ::neurona::schema::AllowedSpaces::Grid_2D,
      ::neurona::schema::AllowedSpaces::Grid_3D
    };

    // Region
    //

    Region::
    Region (const IdType& id)
    : ::neurona::schema::Base (id),
      space_ (this)
    {
    }

    Region::
    Region (const Region& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      space_ (x.space_, f, this)
    {
    }

    Region::
    Region (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      space_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Region::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "space" && n.namespace_ ().empty ())
        {
          this->space_.set (SpaceTraits::create (i, f, this));
          continue;
        }
      }
    }

    Region* Region::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Region (*this, f, c);
    }

    Region& Region::
    operator= (const Region& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->space_ = x.space_;
      }

      return *this;
    }

    Region::
    ~Region ()
    {
    }

    // Population
    //

    Population::
    Population (const IdType& id)
    : ::neurona::schema::Standalone (id),
      layout_ (this),
      instance_ (this),
      cell_ (this),
      network_ (this),
      component_ (this),
      size_ (this),
      type_ (this),
      extracellularProperties_ (this)
    {
    }

    Population::
    Population (const Population& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      layout_ (x.layout_, f, this),
      instance_ (x.instance_, f, this),
      cell_ (x.cell_, f, this),
      network_ (x.network_, f, this),
      component_ (x.component_, f, this),
      size_ (x.size_, f, this),
      type_ (x.type_, f, this),
      extracellularProperties_ (x.extracellularProperties_, f, this)
    {
    }

    Population::
    Population (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      layout_ (this),
      instance_ (this),
      cell_ (this),
      network_ (this),
      component_ (this),
      size_ (this),
      type_ (this),
      extracellularProperties_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Population::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // layout
        //
        if (n.name () == "layout" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< LayoutType > r (
            LayoutTraits::create (i, f, this));

          if (!this->layout_)
          {
            this->layout_.set (::std::move (r));
            continue;
          }
        }

        // instance
        //
        if (n.name () == "instance" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< InstanceType > r (
            InstanceTraits::create (i, f, this));

          this->instance_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "cell" && n.namespace_ ().empty ())
        {
          this->cell_.set (CellTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "network" && n.namespace_ ().empty ())
        {
          this->network_.set (NetworkTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "component" && n.namespace_ ().empty ())
        {
          this->component_.set (ComponentTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "size" && n.namespace_ ().empty ())
        {
          this->size_.set (SizeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "type" && n.namespace_ ().empty ())
        {
          this->type_.set (TypeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "extracellularProperties" && n.namespace_ ().empty ())
        {
          this->extracellularProperties_.set (ExtracellularPropertiesTraits::create (i, f, this));
          continue;
        }
      }
    }

    Population* Population::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Population (*this, f, c);
    }

    Population& Population::
    operator= (const Population& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->layout_ = x.layout_;
        this->instance_ = x.instance_;
        this->cell_ = x.cell_;
        this->network_ = x.network_;
        this->component_ = x.component_;
        this->size_ = x.size_;
        this->type_ = x.type_;
        this->extracellularProperties_ = x.extracellularProperties_;
      }

      return *this;
    }

    Population::
    ~Population ()
    {
    }

    // PopulationTypes
    //

    PopulationTypes::
    PopulationTypes (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
      _xsd_PopulationTypes_convert ();
    }

    PopulationTypes::
    PopulationTypes (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
      _xsd_PopulationTypes_convert ();
    }

    PopulationTypes::
    PopulationTypes (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
      _xsd_PopulationTypes_convert ();
    }

    PopulationTypes* PopulationTypes::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PopulationTypes (*this, f, c);
    }

    PopulationTypes::Value PopulationTypes::
    _xsd_PopulationTypes_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PopulationTypes_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_PopulationTypes_indexes_,
                        _xsd_PopulationTypes_indexes_ + 2,
                        *this,
                        c));

      if (i == _xsd_PopulationTypes_indexes_ + 2 || _xsd_PopulationTypes_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const PopulationTypes::
    _xsd_PopulationTypes_literals_[2] =
    {
      "population",
      "populationList"
    };

    const PopulationTypes::Value PopulationTypes::
    _xsd_PopulationTypes_indexes_[2] =
    {
      ::neurona::schema::PopulationTypes::population,
      ::neurona::schema::PopulationTypes::populationList
    };

    // Layout
    //

    Layout::
    Layout ()
    : ::xml_schema::Type (),
      random_ (this),
      grid_ (this),
      unstructured_ (this),
      space_ (this)
    {
    }

    Layout::
    Layout (const Layout& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      random_ (x.random_, f, this),
      grid_ (x.grid_, f, this),
      unstructured_ (x.unstructured_, f, this),
      space_ (x.space_, f, this)
    {
    }

    Layout::
    Layout (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      random_ (this),
      grid_ (this),
      unstructured_ (this),
      space_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Layout::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // random
        //
        if (n.name () == "random" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< RandomType > r (
            RandomTraits::create (i, f, this));

          if (!this->random_)
          {
            this->random_.set (::std::move (r));
            continue;
          }
        }

        // grid
        //
        if (n.name () == "grid" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< GridType > r (
            GridTraits::create (i, f, this));

          if (!this->grid_)
          {
            this->grid_.set (::std::move (r));
            continue;
          }
        }

        // unstructured
        //
        if (n.name () == "unstructured" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< UnstructuredType > r (
            UnstructuredTraits::create (i, f, this));

          if (!this->unstructured_)
          {
            this->unstructured_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "space" && n.namespace_ ().empty ())
        {
          this->space_.set (SpaceTraits::create (i, f, this));
          continue;
        }
      }
    }

    Layout* Layout::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Layout (*this, f, c);
    }

    Layout& Layout::
    operator= (const Layout& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->random_ = x.random_;
        this->grid_ = x.grid_;
        this->unstructured_ = x.unstructured_;
        this->space_ = x.space_;
      }

      return *this;
    }

    Layout::
    ~Layout ()
    {
    }

    // UnstructuredLayout
    //

    UnstructuredLayout::
    UnstructuredLayout ()
    : ::xml_schema::Type (),
      number_ (this)
    {
    }

    UnstructuredLayout::
    UnstructuredLayout (const UnstructuredLayout& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      number_ (x.number_, f, this)
    {
    }

    UnstructuredLayout::
    UnstructuredLayout (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      number_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void UnstructuredLayout::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "number" && n.namespace_ ().empty ())
        {
          this->number_.set (NumberTraits::create (i, f, this));
          continue;
        }
      }
    }

    UnstructuredLayout* UnstructuredLayout::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class UnstructuredLayout (*this, f, c);
    }

    UnstructuredLayout& UnstructuredLayout::
    operator= (const UnstructuredLayout& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->number_ = x.number_;
      }

      return *this;
    }

    UnstructuredLayout::
    ~UnstructuredLayout ()
    {
    }

    // RandomLayout
    //

    RandomLayout::
    RandomLayout ()
    : ::xml_schema::Type (),
      number_ (this),
      region_ (this)
    {
    }

    RandomLayout::
    RandomLayout (const RandomLayout& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      number_ (x.number_, f, this),
      region_ (x.region_, f, this)
    {
    }

    RandomLayout::
    RandomLayout (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      number_ (this),
      region_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void RandomLayout::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "number" && n.namespace_ ().empty ())
        {
          this->number_.set (NumberTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "region" && n.namespace_ ().empty ())
        {
          this->region_.set (RegionTraits::create (i, f, this));
          continue;
        }
      }
    }

    RandomLayout* RandomLayout::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RandomLayout (*this, f, c);
    }

    RandomLayout& RandomLayout::
    operator= (const RandomLayout& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->number_ = x.number_;
        this->region_ = x.region_;
      }

      return *this;
    }

    RandomLayout::
    ~RandomLayout ()
    {
    }

    // GridLayout
    //

    GridLayout::
    GridLayout ()
    : ::xml_schema::Type (),
      xSize_ (this),
      ySize_ (this),
      zSize_ (this)
    {
    }

    GridLayout::
    GridLayout (const GridLayout& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      xSize_ (x.xSize_, f, this),
      ySize_ (x.ySize_, f, this),
      zSize_ (x.zSize_, f, this)
    {
    }

    GridLayout::
    GridLayout (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      xSize_ (this),
      ySize_ (this),
      zSize_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void GridLayout::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "xSize" && n.namespace_ ().empty ())
        {
          this->xSize_.set (XSizeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "ySize" && n.namespace_ ().empty ())
        {
          this->ySize_.set (YSizeTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "zSize" && n.namespace_ ().empty ())
        {
          this->zSize_.set (ZSizeTraits::create (i, f, this));
          continue;
        }
      }
    }

    GridLayout* GridLayout::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GridLayout (*this, f, c);
    }

    GridLayout& GridLayout::
    operator= (const GridLayout& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->xSize_ = x.xSize_;
        this->ySize_ = x.ySize_;
        this->zSize_ = x.zSize_;
      }

      return *this;
    }

    GridLayout::
    ~GridLayout ()
    {
    }

    // Instance
    //

    Instance::
    Instance (const LocationType& location)
    : ::xml_schema::Type (),
      location_ (location, this),
      id_ (this),
      i_ (this),
      j_ (this),
      k_ (this)
    {
    }

    Instance::
    Instance (::std::unique_ptr< LocationType > location)
    : ::xml_schema::Type (),
      location_ (std::move (location), this),
      id_ (this),
      i_ (this),
      j_ (this),
      k_ (this)
    {
    }

    Instance::
    Instance (const Instance& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      location_ (x.location_, f, this),
      id_ (x.id_, f, this),
      i_ (x.i_, f, this),
      j_ (x.j_, f, this),
      k_ (x.k_, f, this)
    {
    }

    Instance::
    Instance (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      location_ (this),
      id_ (this),
      i_ (this),
      j_ (this),
      k_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Instance::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // location
        //
        if (n.name () == "location" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< LocationType > r (
            LocationTraits::create (i, f, this));

          if (!location_.present ())
          {
            this->location_.set (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!location_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "location",
          "http://www.neuroml.org/schema/neuroml2");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "i" && n.namespace_ ().empty ())
        {
          this->i_.set (ITraits::create (i, f, this));
          continue;
        }

        if (n.name () == "j" && n.namespace_ ().empty ())
        {
          this->j_.set (JTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "k" && n.namespace_ ().empty ())
        {
          this->k_.set (KTraits::create (i, f, this));
          continue;
        }
      }
    }

    Instance* Instance::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Instance (*this, f, c);
    }

    Instance& Instance::
    operator= (const Instance& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->location_ = x.location_;
        this->id_ = x.id_;
        this->i_ = x.i_;
        this->j_ = x.j_;
        this->k_ = x.k_;
      }

      return *this;
    }

    Instance::
    ~Instance ()
    {
    }

    // Location
    //

    Location::
    Location ()
    : ::xml_schema::Type (),
      x_ (this),
      y_ (this),
      z_ (this)
    {
    }

    Location::
    Location (const Location& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      x_ (x.x_, f, this),
      y_ (x.y_, f, this),
      z_ (x.z_, f, this)
    {
    }

    Location::
    Location (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      x_ (this),
      y_ (this),
      z_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Location::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "x" && n.namespace_ ().empty ())
        {
          this->x_.set (XTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "y" && n.namespace_ ().empty ())
        {
          this->y_.set (YTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "z" && n.namespace_ ().empty ())
        {
          this->z_.set (ZTraits::create (i, f, this));
          continue;
        }
      }
    }

    Location* Location::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Location (*this, f, c);
    }

    Location& Location::
    operator= (const Location& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
      }

      return *this;
    }

    Location::
    ~Location ()
    {
    }

    // CellSet
    //

    CellSet::
    CellSet (const IdType& id,
             const SelectType& select)
    : ::neurona::schema::Base (id),
      select_ (select, this)
    {
    }

    CellSet::
    CellSet (const CellSet& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      select_ (x.select_, f, this)
    {
    }

    CellSet::
    CellSet (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      select_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void CellSet::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "select" && n.namespace_ ().empty ())
        {
          this->select_.set (SelectTraits::create (i, f, this));
          continue;
        }
      }

      if (!select_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "select",
          "");
      }
    }

    CellSet* CellSet::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CellSet (*this, f, c);
    }

    CellSet& CellSet::
    operator= (const CellSet& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->select_ = x.select_;
      }

      return *this;
    }

    CellSet::
    ~CellSet ()
    {
    }

    // SynapticConnection
    //

    SynapticConnection::
    SynapticConnection ()
    : ::xml_schema::Type (),
      from_ (this),
      to_ (this),
      synapse_ (this),
      destination_ (this)
    {
    }

    SynapticConnection::
    SynapticConnection (const SynapticConnection& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      from_ (x.from_, f, this),
      to_ (x.to_, f, this),
      synapse_ (x.synapse_, f, this),
      destination_ (x.destination_, f, this)
    {
    }

    SynapticConnection::
    SynapticConnection (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      from_ (this),
      to_ (this),
      synapse_ (this),
      destination_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SynapticConnection::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "from" && n.namespace_ ().empty ())
        {
          this->from_.set (FromTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "to" && n.namespace_ ().empty ())
        {
          this->to_.set (ToTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "synapse" && n.namespace_ ().empty ())
        {
          this->synapse_.set (SynapseTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "destination" && n.namespace_ ().empty ())
        {
          this->destination_.set (DestinationTraits::create (i, f, this));
          continue;
        }
      }
    }

    SynapticConnection* SynapticConnection::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SynapticConnection (*this, f, c);
    }

    SynapticConnection& SynapticConnection::
    operator= (const SynapticConnection& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->from_ = x.from_;
        this->to_ = x.to_;
        this->synapse_ = x.synapse_;
        this->destination_ = x.destination_;
      }

      return *this;
    }

    SynapticConnection::
    ~SynapticConnection ()
    {
    }

    // Projection
    //

    Projection::
    Projection (const IdType& id)
    : ::neurona::schema::Base (id),
      connection_ (this),
      presynapticPopulation_ (this),
      postsynapticPopulation_ (this),
      synapse_ (this)
    {
    }

    Projection::
    Projection (const Projection& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      connection_ (x.connection_, f, this),
      presynapticPopulation_ (x.presynapticPopulation_, f, this),
      postsynapticPopulation_ (x.postsynapticPopulation_, f, this),
      synapse_ (x.synapse_, f, this)
    {
    }

    Projection::
    Projection (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      connection_ (this),
      presynapticPopulation_ (this),
      postsynapticPopulation_ (this),
      synapse_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Projection::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // connection
        //
        if (n.name () == "connection" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< ConnectionType > r (
            ConnectionTraits::create (i, f, this));

          this->connection_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "presynapticPopulation" && n.namespace_ ().empty ())
        {
          this->presynapticPopulation_.set (PresynapticPopulationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "postsynapticPopulation" && n.namespace_ ().empty ())
        {
          this->postsynapticPopulation_.set (PostsynapticPopulationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "synapse" && n.namespace_ ().empty ())
        {
          this->synapse_.set (SynapseTraits::create (i, f, this));
          continue;
        }
      }
    }

    Projection* Projection::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Projection (*this, f, c);
    }

    Projection& Projection::
    operator= (const Projection& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->connection_ = x.connection_;
        this->presynapticPopulation_ = x.presynapticPopulation_;
        this->postsynapticPopulation_ = x.postsynapticPopulation_;
        this->synapse_ = x.synapse_;
      }

      return *this;
    }

    Projection::
    ~Projection ()
    {
    }

    // Connection
    //

    Connection::
    Connection ()
    : ::xml_schema::Type (),
      id_ (this),
      preCellId_ (this),
      preSegmentId_ (this),
      preFractionAlong_ (this),
      postCellId_ (this),
      postSegmentId_ (this),
      postFractionAlong_ (this)
    {
    }

    Connection::
    Connection (const Connection& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      preCellId_ (x.preCellId_, f, this),
      preSegmentId_ (x.preSegmentId_, f, this),
      preFractionAlong_ (x.preFractionAlong_, f, this),
      postCellId_ (x.postCellId_, f, this),
      postSegmentId_ (x.postSegmentId_, f, this),
      postFractionAlong_ (x.postFractionAlong_, f, this)
    {
    }

    Connection::
    Connection (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      preCellId_ (this),
      preSegmentId_ (this),
      preFractionAlong_ (this),
      postCellId_ (this),
      postSegmentId_ (this),
      postFractionAlong_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Connection::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "preCellId" && n.namespace_ ().empty ())
        {
          this->preCellId_.set (PreCellIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "preSegmentId" && n.namespace_ ().empty ())
        {
          this->preSegmentId_.set (PreSegmentIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "preFractionAlong" && n.namespace_ ().empty ())
        {
          this->preFractionAlong_.set (PreFractionAlongTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "postCellId" && n.namespace_ ().empty ())
        {
          this->postCellId_.set (PostCellIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "postSegmentId" && n.namespace_ ().empty ())
        {
          this->postSegmentId_.set (PostSegmentIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "postFractionAlong" && n.namespace_ ().empty ())
        {
          this->postFractionAlong_.set (PostFractionAlongTraits::create (i, f, this));
          continue;
        }
      }
    }

    Connection* Connection::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Connection (*this, f, c);
    }

    Connection& Connection::
    operator= (const Connection& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->preCellId_ = x.preCellId_;
        this->preSegmentId_ = x.preSegmentId_;
        this->preFractionAlong_ = x.preFractionAlong_;
        this->postCellId_ = x.postCellId_;
        this->postSegmentId_ = x.postSegmentId_;
        this->postFractionAlong_ = x.postFractionAlong_;
      }

      return *this;
    }

    Connection::
    ~Connection ()
    {
    }

    // ExplicitInput
    //

    ExplicitInput::
    ExplicitInput ()
    : ::xml_schema::Type (),
      target_ (this),
      input_ (this),
      destination_ (this)
    {
    }

    ExplicitInput::
    ExplicitInput (const ExplicitInput& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      target_ (x.target_, f, this),
      input_ (x.input_, f, this),
      destination_ (x.destination_, f, this)
    {
    }

    ExplicitInput::
    ExplicitInput (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      target_ (this),
      input_ (this),
      destination_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ExplicitInput::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "target" && n.namespace_ ().empty ())
        {
          this->target_.set (TargetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "input" && n.namespace_ ().empty ())
        {
          this->input_.set (InputTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "destination" && n.namespace_ ().empty ())
        {
          this->destination_.set (DestinationTraits::create (i, f, this));
          continue;
        }
      }
    }

    ExplicitInput* ExplicitInput::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExplicitInput (*this, f, c);
    }

    ExplicitInput& ExplicitInput::
    operator= (const ExplicitInput& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->target_ = x.target_;
        this->input_ = x.input_;
        this->destination_ = x.destination_;
      }

      return *this;
    }

    ExplicitInput::
    ~ExplicitInput ()
    {
    }

    // InputList
    //

    InputList::
    InputList (const IdType& id)
    : ::neurona::schema::Base (id),
      input_ (this),
      population_ (this),
      component_ (this)
    {
    }

    InputList::
    InputList (const InputList& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::neurona::schema::Base (x, f, c),
      input_ (x.input_, f, this),
      population_ (x.population_, f, this),
      component_ (x.component_, f, this)
    {
    }

    InputList::
    InputList (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::neurona::schema::Base (e, f | ::xml_schema::Flags::base, c),
      input_ (this),
      population_ (this),
      component_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void InputList::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Base::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // input
        //
        if (n.name () == "input" && n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
        {
          ::std::unique_ptr< InputType > r (
            InputTraits::create (i, f, this));

          this->input_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "population" && n.namespace_ ().empty ())
        {
          this->population_.set (PopulationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "component" && n.namespace_ ().empty ())
        {
          this->component_.set (ComponentTraits::create (i, f, this));
          continue;
        }
      }
    }

    InputList* InputList::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class InputList (*this, f, c);
    }

    InputList& InputList::
    operator= (const InputList& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Base& > (*this) = x;
        this->input_ = x.input_;
        this->population_ = x.population_;
        this->component_ = x.component_;
      }

      return *this;
    }

    InputList::
    ~InputList ()
    {
    }

    // Input
    //

    Input::
    Input ()
    : ::xml_schema::Type (),
      id_ (this),
      target_ (this),
      destination_ (this),
      segmentId_ (this),
      fractionAlong_ (this)
    {
    }

    Input::
    Input (const Input& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      target_ (x.target_, f, this),
      destination_ (x.destination_, f, this),
      segmentId_ (x.segmentId_, f, this),
      fractionAlong_ (x.fractionAlong_, f, this)
    {
    }

    Input::
    Input (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      target_ (this),
      destination_ (this),
      segmentId_ (this),
      fractionAlong_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Input::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "target" && n.namespace_ ().empty ())
        {
          this->target_.set (TargetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "destination" && n.namespace_ ().empty ())
        {
          this->destination_.set (DestinationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "segmentId" && n.namespace_ ().empty ())
        {
          this->segmentId_.set (SegmentIdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "fractionAlong" && n.namespace_ ().empty ())
        {
          this->fractionAlong_.set (FractionAlongTraits::create (i, f, this));
          continue;
        }
      }
    }

    Input* Input::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Input (*this, f, c);
    }

    Input& Input::
    operator= (const Input& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->target_ = x.target_;
        this->destination_ = x.destination_;
        this->segmentId_ = x.segmentId_;
        this->fractionAlong_ = x.fractionAlong_;
      }

      return *this;
    }

    Input::
    ~Input ()
    {
    }

    // BasePyNNCell
    //

    BasePyNNCell::
    BasePyNNCell (const IdType& id)
    : ::neurona::schema::BaseCell (id),
      cm_ (this),
      i_offset_ (this),
      tau_syn_E_ (this),
      tau_syn_I_ (this),
      v_init_ (this)
    {
    }

    BasePyNNCell::
    BasePyNNCell (const BasePyNNCell& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (x, f, c),
      cm_ (x.cm_, f, this),
      i_offset_ (x.i_offset_, f, this),
      tau_syn_E_ (x.tau_syn_E_, f, this),
      tau_syn_I_ (x.tau_syn_I_, f, this),
      v_init_ (x.v_init_, f, this)
    {
    }

    BasePyNNCell::
    BasePyNNCell (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::neurona::schema::BaseCell (e, f | ::xml_schema::Flags::base, c),
      cm_ (this),
      i_offset_ (this),
      tau_syn_E_ (this),
      tau_syn_I_ (this),
      v_init_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BasePyNNCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "cm" && n.namespace_ ().empty ())
        {
          this->cm_.set (CmTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "i_offset" && n.namespace_ ().empty ())
        {
          this->i_offset_.set (I_offsetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau_syn_E" && n.namespace_ ().empty ())
        {
          this->tau_syn_E_.set (Tau_syn_ETraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau_syn_I" && n.namespace_ ().empty ())
        {
          this->tau_syn_I_.set (Tau_syn_ITraits::create (i, f, this));
          continue;
        }

        if (n.name () == "v_init" && n.namespace_ ().empty ())
        {
          this->v_init_.set (V_initTraits::create (i, f, this));
          continue;
        }
      }
    }

    BasePyNNCell* BasePyNNCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BasePyNNCell (*this, f, c);
    }

    BasePyNNCell& BasePyNNCell::
    operator= (const BasePyNNCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseCell& > (*this) = x;
        this->cm_ = x.cm_;
        this->i_offset_ = x.i_offset_;
        this->tau_syn_E_ = x.tau_syn_E_;
        this->tau_syn_I_ = x.tau_syn_I_;
        this->v_init_ = x.v_init_;
      }

      return *this;
    }

    BasePyNNCell::
    ~BasePyNNCell ()
    {
    }

    // BasePyNNIaFCell
    //

    BasePyNNIaFCell::
    BasePyNNIaFCell (const IdType& id)
    : ::neurona::schema::BasePyNNCell (id),
      tau_m_ (this),
      tau_refrac_ (this),
      v_reset_ (this),
      v_rest_ (this),
      v_thresh_ (this)
    {
    }

    BasePyNNIaFCell::
    BasePyNNIaFCell (const BasePyNNIaFCell& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNCell (x, f, c),
      tau_m_ (x.tau_m_, f, this),
      tau_refrac_ (x.tau_refrac_, f, this),
      v_reset_ (x.v_reset_, f, this),
      v_rest_ (x.v_rest_, f, this),
      v_thresh_ (x.v_thresh_, f, this)
    {
    }

    BasePyNNIaFCell::
    BasePyNNIaFCell (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNCell (e, f | ::xml_schema::Flags::base, c),
      tau_m_ (this),
      tau_refrac_ (this),
      v_reset_ (this),
      v_rest_ (this),
      v_thresh_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BasePyNNIaFCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePyNNCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tau_m" && n.namespace_ ().empty ())
        {
          this->tau_m_.set (Tau_mTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau_refrac" && n.namespace_ ().empty ())
        {
          this->tau_refrac_.set (Tau_refracTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "v_reset" && n.namespace_ ().empty ())
        {
          this->v_reset_.set (V_resetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "v_rest" && n.namespace_ ().empty ())
        {
          this->v_rest_.set (V_restTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "v_thresh" && n.namespace_ ().empty ())
        {
          this->v_thresh_.set (V_threshTraits::create (i, f, this));
          continue;
        }
      }
    }

    BasePyNNIaFCell* BasePyNNIaFCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BasePyNNIaFCell (*this, f, c);
    }

    BasePyNNIaFCell& BasePyNNIaFCell::
    operator= (const BasePyNNIaFCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePyNNCell& > (*this) = x;
        this->tau_m_ = x.tau_m_;
        this->tau_refrac_ = x.tau_refrac_;
        this->v_reset_ = x.v_reset_;
        this->v_rest_ = x.v_rest_;
        this->v_thresh_ = x.v_thresh_;
      }

      return *this;
    }

    BasePyNNIaFCell::
    ~BasePyNNIaFCell ()
    {
    }

    // BasePyNNIaFCondCell
    //

    BasePyNNIaFCondCell::
    BasePyNNIaFCondCell (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCell (id),
      e_rev_E_ (this),
      e_rev_I_ (this)
    {
    }

    BasePyNNIaFCondCell::
    BasePyNNIaFCondCell (const BasePyNNIaFCondCell& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCell (x, f, c),
      e_rev_E_ (x.e_rev_E_, f, this),
      e_rev_I_ (x.e_rev_I_, f, this)
    {
    }

    BasePyNNIaFCondCell::
    BasePyNNIaFCondCell (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCell (e, f | ::xml_schema::Flags::base, c),
      e_rev_E_ (this),
      e_rev_I_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BasePyNNIaFCondCell::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePyNNIaFCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "e_rev_E" && n.namespace_ ().empty ())
        {
          this->e_rev_E_.set (E_rev_ETraits::create (i, f, this));
          continue;
        }

        if (n.name () == "e_rev_I" && n.namespace_ ().empty ())
        {
          this->e_rev_I_.set (E_rev_ITraits::create (i, f, this));
          continue;
        }
      }
    }

    BasePyNNIaFCondCell* BasePyNNIaFCondCell::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BasePyNNIaFCondCell (*this, f, c);
    }

    BasePyNNIaFCondCell& BasePyNNIaFCondCell::
    operator= (const BasePyNNIaFCondCell& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePyNNIaFCell& > (*this) = x;
        this->e_rev_E_ = x.e_rev_E_;
        this->e_rev_I_ = x.e_rev_I_;
      }

      return *this;
    }

    BasePyNNIaFCondCell::
    ~BasePyNNIaFCondCell ()
    {
    }

    // IF_curr_alpha
    //

    IF_curr_alpha::
    IF_curr_alpha (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCell (id)
    {
    }

    IF_curr_alpha::
    IF_curr_alpha (const IF_curr_alpha& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCell (x, f, c)
    {
    }

    IF_curr_alpha::
    IF_curr_alpha (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCell (e, f, c)
    {
    }

    IF_curr_alpha* IF_curr_alpha::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IF_curr_alpha (*this, f, c);
    }

    IF_curr_alpha::
    ~IF_curr_alpha ()
    {
    }

    // IF_curr_exp
    //

    IF_curr_exp::
    IF_curr_exp (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCell (id)
    {
    }

    IF_curr_exp::
    IF_curr_exp (const IF_curr_exp& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCell (x, f, c)
    {
    }

    IF_curr_exp::
    IF_curr_exp (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCell (e, f, c)
    {
    }

    IF_curr_exp* IF_curr_exp::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IF_curr_exp (*this, f, c);
    }

    IF_curr_exp::
    ~IF_curr_exp ()
    {
    }

    // IF_cond_alpha
    //

    IF_cond_alpha::
    IF_cond_alpha (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCondCell (id)
    {
    }

    IF_cond_alpha::
    IF_cond_alpha (const IF_cond_alpha& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (x, f, c)
    {
    }

    IF_cond_alpha::
    IF_cond_alpha (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (e, f, c)
    {
    }

    IF_cond_alpha* IF_cond_alpha::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IF_cond_alpha (*this, f, c);
    }

    IF_cond_alpha::
    ~IF_cond_alpha ()
    {
    }

    // IF_cond_exp
    //

    IF_cond_exp::
    IF_cond_exp (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCondCell (id)
    {
    }

    IF_cond_exp::
    IF_cond_exp (const IF_cond_exp& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (x, f, c)
    {
    }

    IF_cond_exp::
    IF_cond_exp (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (e, f, c)
    {
    }

    IF_cond_exp* IF_cond_exp::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class IF_cond_exp (*this, f, c);
    }

    IF_cond_exp::
    ~IF_cond_exp ()
    {
    }

    // EIF_cond_exp_isfa_ista
    //

    EIF_cond_exp_isfa_ista::
    EIF_cond_exp_isfa_ista (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCondCell (id),
      a_ (this),
      b_ (this),
      delta_T_ (this),
      tau_w_ (this),
      v_spike_ (this)
    {
    }

    EIF_cond_exp_isfa_ista::
    EIF_cond_exp_isfa_ista (const EIF_cond_exp_isfa_ista& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (x, f, c),
      a_ (x.a_, f, this),
      b_ (x.b_, f, this),
      delta_T_ (x.delta_T_, f, this),
      tau_w_ (x.tau_w_, f, this),
      v_spike_ (x.v_spike_, f, this)
    {
    }

    EIF_cond_exp_isfa_ista::
    EIF_cond_exp_isfa_ista (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (e, f | ::xml_schema::Flags::base, c),
      a_ (this),
      b_ (this),
      delta_T_ (this),
      tau_w_ (this),
      v_spike_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EIF_cond_exp_isfa_ista::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePyNNIaFCondCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "a" && n.namespace_ ().empty ())
        {
          this->a_.set (ATraits::create (i, f, this));
          continue;
        }

        if (n.name () == "b" && n.namespace_ ().empty ())
        {
          this->b_.set (BTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "delta_T" && n.namespace_ ().empty ())
        {
          this->delta_T_.set (Delta_TTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau_w" && n.namespace_ ().empty ())
        {
          this->tau_w_.set (Tau_wTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "v_spike" && n.namespace_ ().empty ())
        {
          this->v_spike_.set (V_spikeTraits::create (i, f, this));
          continue;
        }
      }
    }

    EIF_cond_exp_isfa_ista* EIF_cond_exp_isfa_ista::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EIF_cond_exp_isfa_ista (*this, f, c);
    }

    EIF_cond_exp_isfa_ista& EIF_cond_exp_isfa_ista::
    operator= (const EIF_cond_exp_isfa_ista& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePyNNIaFCondCell& > (*this) = x;
        this->a_ = x.a_;
        this->b_ = x.b_;
        this->delta_T_ = x.delta_T_;
        this->tau_w_ = x.tau_w_;
        this->v_spike_ = x.v_spike_;
      }

      return *this;
    }

    EIF_cond_exp_isfa_ista::
    ~EIF_cond_exp_isfa_ista ()
    {
    }

    // EIF_cond_alpha_isfa_ista
    //

    EIF_cond_alpha_isfa_ista::
    EIF_cond_alpha_isfa_ista (const IdType& id)
    : ::neurona::schema::BasePyNNIaFCondCell (id),
      a_ (this),
      b_ (this),
      delta_T_ (this),
      tau_w_ (this),
      v_spike_ (this)
    {
    }

    EIF_cond_alpha_isfa_ista::
    EIF_cond_alpha_isfa_ista (const EIF_cond_alpha_isfa_ista& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (x, f, c),
      a_ (x.a_, f, this),
      b_ (x.b_, f, this),
      delta_T_ (x.delta_T_, f, this),
      tau_w_ (x.tau_w_, f, this),
      v_spike_ (x.v_spike_, f, this)
    {
    }

    EIF_cond_alpha_isfa_ista::
    EIF_cond_alpha_isfa_ista (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNIaFCondCell (e, f | ::xml_schema::Flags::base, c),
      a_ (this),
      b_ (this),
      delta_T_ (this),
      tau_w_ (this),
      v_spike_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EIF_cond_alpha_isfa_ista::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePyNNIaFCondCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "a" && n.namespace_ ().empty ())
        {
          this->a_.set (ATraits::create (i, f, this));
          continue;
        }

        if (n.name () == "b" && n.namespace_ ().empty ())
        {
          this->b_.set (BTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "delta_T" && n.namespace_ ().empty ())
        {
          this->delta_T_.set (Delta_TTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "tau_w" && n.namespace_ ().empty ())
        {
          this->tau_w_.set (Tau_wTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "v_spike" && n.namespace_ ().empty ())
        {
          this->v_spike_.set (V_spikeTraits::create (i, f, this));
          continue;
        }
      }
    }

    EIF_cond_alpha_isfa_ista* EIF_cond_alpha_isfa_ista::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EIF_cond_alpha_isfa_ista (*this, f, c);
    }

    EIF_cond_alpha_isfa_ista& EIF_cond_alpha_isfa_ista::
    operator= (const EIF_cond_alpha_isfa_ista& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePyNNIaFCondCell& > (*this) = x;
        this->a_ = x.a_;
        this->b_ = x.b_;
        this->delta_T_ = x.delta_T_;
        this->tau_w_ = x.tau_w_;
        this->v_spike_ = x.v_spike_;
      }

      return *this;
    }

    EIF_cond_alpha_isfa_ista::
    ~EIF_cond_alpha_isfa_ista ()
    {
    }

    // HH_cond_exp
    //

    HH_cond_exp::
    HH_cond_exp (const IdType& id)
    : ::neurona::schema::BasePyNNCell (id),
      v_offset_ (this),
      e_rev_E_ (this),
      e_rev_I_ (this),
      e_rev_K_ (this),
      e_rev_Na_ (this),
      e_rev_leak_ (this),
      g_leak_ (this),
      gbar_K_ (this),
      gbar_Na_ (this)
    {
    }

    HH_cond_exp::
    HH_cond_exp (const HH_cond_exp& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNCell (x, f, c),
      v_offset_ (x.v_offset_, f, this),
      e_rev_E_ (x.e_rev_E_, f, this),
      e_rev_I_ (x.e_rev_I_, f, this),
      e_rev_K_ (x.e_rev_K_, f, this),
      e_rev_Na_ (x.e_rev_Na_, f, this),
      e_rev_leak_ (x.e_rev_leak_, f, this),
      g_leak_ (x.g_leak_, f, this),
      gbar_K_ (x.gbar_K_, f, this),
      gbar_Na_ (x.gbar_Na_, f, this)
    {
    }

    HH_cond_exp::
    HH_cond_exp (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::neurona::schema::BasePyNNCell (e, f | ::xml_schema::Flags::base, c),
      v_offset_ (this),
      e_rev_E_ (this),
      e_rev_I_ (this),
      e_rev_K_ (this),
      e_rev_Na_ (this),
      e_rev_leak_ (this),
      g_leak_ (this),
      gbar_K_ (this),
      gbar_Na_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void HH_cond_exp::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePyNNCell::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "v_offset" && n.namespace_ ().empty ())
        {
          this->v_offset_.set (V_offsetTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "e_rev_E" && n.namespace_ ().empty ())
        {
          this->e_rev_E_.set (E_rev_ETraits::create (i, f, this));
          continue;
        }

        if (n.name () == "e_rev_I" && n.namespace_ ().empty ())
        {
          this->e_rev_I_.set (E_rev_ITraits::create (i, f, this));
          continue;
        }

        if (n.name () == "e_rev_K" && n.namespace_ ().empty ())
        {
          this->e_rev_K_.set (E_rev_KTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "e_rev_Na" && n.namespace_ ().empty ())
        {
          this->e_rev_Na_.set (E_rev_NaTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "e_rev_leak" && n.namespace_ ().empty ())
        {
          this->e_rev_leak_.set (E_rev_leakTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "g_leak" && n.namespace_ ().empty ())
        {
          this->g_leak_.set (G_leakTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "gbar_K" && n.namespace_ ().empty ())
        {
          this->gbar_K_.set (Gbar_KTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "gbar_Na" && n.namespace_ ().empty ())
        {
          this->gbar_Na_.set (Gbar_NaTraits::create (i, f, this));
          continue;
        }
      }
    }

    HH_cond_exp* HH_cond_exp::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class HH_cond_exp (*this, f, c);
    }

    HH_cond_exp& HH_cond_exp::
    operator= (const HH_cond_exp& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePyNNCell& > (*this) = x;
        this->v_offset_ = x.v_offset_;
        this->e_rev_E_ = x.e_rev_E_;
        this->e_rev_I_ = x.e_rev_I_;
        this->e_rev_K_ = x.e_rev_K_;
        this->e_rev_Na_ = x.e_rev_Na_;
        this->e_rev_leak_ = x.e_rev_leak_;
        this->g_leak_ = x.g_leak_;
        this->gbar_K_ = x.gbar_K_;
        this->gbar_Na_ = x.gbar_Na_;
      }

      return *this;
    }

    HH_cond_exp::
    ~HH_cond_exp ()
    {
    }

    // BasePynnSynapse
    //

    BasePynnSynapse::
    BasePynnSynapse (const IdType& id)
    : ::neurona::schema::BaseSynapse (id),
      tau_syn_ (this)
    {
    }

    BasePynnSynapse::
    BasePynnSynapse (const BasePynnSynapse& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::neurona::schema::BaseSynapse (x, f, c),
      tau_syn_ (x.tau_syn_, f, this)
    {
    }

    BasePynnSynapse::
    BasePynnSynapse (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::neurona::schema::BaseSynapse (e, f | ::xml_schema::Flags::base, c),
      tau_syn_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BasePynnSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BaseSynapse::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "tau_syn" && n.namespace_ ().empty ())
        {
          this->tau_syn_.set (Tau_synTraits::create (i, f, this));
          continue;
        }
      }
    }

    BasePynnSynapse* BasePynnSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BasePynnSynapse (*this, f, c);
    }

    BasePynnSynapse& BasePynnSynapse::
    operator= (const BasePynnSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BaseSynapse& > (*this) = x;
        this->tau_syn_ = x.tau_syn_;
      }

      return *this;
    }

    BasePynnSynapse::
    ~BasePynnSynapse ()
    {
    }

    // ExpCondSynapse
    //

    ExpCondSynapse::
    ExpCondSynapse (const IdType& id)
    : ::neurona::schema::BasePynnSynapse (id),
      e_rev_ (this)
    {
    }

    ExpCondSynapse::
    ExpCondSynapse (const ExpCondSynapse& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (x, f, c),
      e_rev_ (x.e_rev_, f, this)
    {
    }

    ExpCondSynapse::
    ExpCondSynapse (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (e, f | ::xml_schema::Flags::base, c),
      e_rev_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ExpCondSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePynnSynapse::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "e_rev" && n.namespace_ ().empty ())
        {
          this->e_rev_.set (E_revTraits::create (i, f, this));
          continue;
        }
      }
    }

    ExpCondSynapse* ExpCondSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExpCondSynapse (*this, f, c);
    }

    ExpCondSynapse& ExpCondSynapse::
    operator= (const ExpCondSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePynnSynapse& > (*this) = x;
        this->e_rev_ = x.e_rev_;
      }

      return *this;
    }

    ExpCondSynapse::
    ~ExpCondSynapse ()
    {
    }

    // AlphaCondSynapse
    //

    AlphaCondSynapse::
    AlphaCondSynapse (const IdType& id)
    : ::neurona::schema::BasePynnSynapse (id),
      e_rev_ (this)
    {
    }

    AlphaCondSynapse::
    AlphaCondSynapse (const AlphaCondSynapse& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (x, f, c),
      e_rev_ (x.e_rev_, f, this)
    {
    }

    AlphaCondSynapse::
    AlphaCondSynapse (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (e, f | ::xml_schema::Flags::base, c),
      e_rev_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void AlphaCondSynapse::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::BasePynnSynapse::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "e_rev" && n.namespace_ ().empty ())
        {
          this->e_rev_.set (E_revTraits::create (i, f, this));
          continue;
        }
      }
    }

    AlphaCondSynapse* AlphaCondSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AlphaCondSynapse (*this, f, c);
    }

    AlphaCondSynapse& AlphaCondSynapse::
    operator= (const AlphaCondSynapse& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::BasePynnSynapse& > (*this) = x;
        this->e_rev_ = x.e_rev_;
      }

      return *this;
    }

    AlphaCondSynapse::
    ~AlphaCondSynapse ()
    {
    }

    // ExpCurrSynapse
    //

    ExpCurrSynapse::
    ExpCurrSynapse (const IdType& id)
    : ::neurona::schema::BasePynnSynapse (id)
    {
    }

    ExpCurrSynapse::
    ExpCurrSynapse (const ExpCurrSynapse& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (x, f, c)
    {
    }

    ExpCurrSynapse::
    ExpCurrSynapse (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (e, f, c)
    {
    }

    ExpCurrSynapse* ExpCurrSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ExpCurrSynapse (*this, f, c);
    }

    ExpCurrSynapse::
    ~ExpCurrSynapse ()
    {
    }

    // AlphaCurrSynapse
    //

    AlphaCurrSynapse::
    AlphaCurrSynapse (const IdType& id)
    : ::neurona::schema::BasePynnSynapse (id)
    {
    }

    AlphaCurrSynapse::
    AlphaCurrSynapse (const AlphaCurrSynapse& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (x, f, c)
    {
    }

    AlphaCurrSynapse::
    AlphaCurrSynapse (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::neurona::schema::BasePynnSynapse (e, f, c)
    {
    }

    AlphaCurrSynapse* AlphaCurrSynapse::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class AlphaCurrSynapse (*this, f, c);
    }

    AlphaCurrSynapse::
    ~AlphaCurrSynapse ()
    {
    }

    // SpikeSourcePoisson
    //

    SpikeSourcePoisson::
    SpikeSourcePoisson (const IdType& id,
                        const StartType& start,
                        const DurationType& duration,
                        const RateType& rate)
    : ::neurona::schema::Standalone (id),
      start_ (start, this),
      duration_ (duration, this),
      rate_ (rate, this)
    {
    }

    SpikeSourcePoisson::
    SpikeSourcePoisson (const SpikeSourcePoisson& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (x, f, c),
      start_ (x.start_, f, this),
      duration_ (x.duration_, f, this),
      rate_ (x.rate_, f, this)
    {
    }

    SpikeSourcePoisson::
    SpikeSourcePoisson (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::neurona::schema::Standalone (e, f | ::xml_schema::Flags::base, c),
      start_ (this),
      duration_ (this),
      rate_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SpikeSourcePoisson::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::neurona::schema::Standalone::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "start" && n.namespace_ ().empty ())
        {
          this->start_.set (StartTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "duration" && n.namespace_ ().empty ())
        {
          this->duration_.set (DurationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "rate" && n.namespace_ ().empty ())
        {
          this->rate_.set (RateTraits::create (i, f, this));
          continue;
        }
      }

      if (!start_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "start",
          "");
      }

      if (!duration_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "duration",
          "");
      }

      if (!rate_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "rate",
          "");
      }
    }

    SpikeSourcePoisson* SpikeSourcePoisson::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SpikeSourcePoisson (*this, f, c);
    }

    SpikeSourcePoisson& SpikeSourcePoisson::
    operator= (const SpikeSourcePoisson& x)
    {
      if (this != &x)
      {
        static_cast< ::neurona::schema::Standalone& > (*this) = x;
        this->start_ = x.start_;
        this->duration_ = x.duration_;
        this->rate_ = x.rate_;
      }

      return *this;
    }

    SpikeSourcePoisson::
    ~SpikeSourcePoisson ()
    {
    }
  }
}

#include <ostream>

namespace neurona
{
  namespace schema
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const NmlId& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_none& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_voltage& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_length& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_resistance& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_conductance& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_conductanceDensity& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_permeability& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_time& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_pertime& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_capacitance& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_specificCapacitance& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_concentration& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_current& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_temperature& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Nml2Quantity_rhoFactor& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const MetaId& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const NeuroLexId& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SegmentId& i)
    {
      o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::NonNegativeInteger, char, ::xml_schema::SimpleType >& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Notes& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Property& i)
    {
      o << ::std::endl << "tag: " << i.tag ();
      o << ::std::endl << "value: " << i.value ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Annotation&)
    {
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ComponentType& i)
    {
      o << ::std::endl << "name: " << i.name ();
      if (i.extends ())
      {
        o << ::std::endl << "extends: " << *i.extends ();
      }

      if (i.description ())
      {
        o << ::std::endl << "description: " << *i.description ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ZeroToOne& i)
    {
      o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BaseWithoutId& i)
    {
      if (i.neuroLexId ())
      {
        o << ::std::endl << "neuroLexId: " << *i.neuroLexId ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Base& i)
    {
      o << static_cast< const ::neurona::schema::BaseWithoutId& > (i);

      o << ::std::endl << "id: " << i.id ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Standalone& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.annotation ())
      {
        o << ::std::endl << "annotation: " << *i.annotation ();
      }

      if (i.metaid ())
      {
        o << ::std::endl << "metaid: " << *i.metaid ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const NeuroMLDocument& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      for (NeuroMLDocument::IncludeConstIterator
           b (i.includes ().begin ()), e (i.includes ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "include: " << *b;
      }

      for (NeuroMLDocument::ExtracellularPropertiesConstIterator
           b (i.extracellularPropertiess ().begin ()), e (i.extracellularPropertiess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "extracellularProperties: " << *b;
      }

      for (NeuroMLDocument::IntracellularPropertiesConstIterator
           b (i.intracellularPropertiess ().begin ()), e (i.intracellularPropertiess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "intracellularProperties: " << *b;
      }

      for (NeuroMLDocument::MorphologyConstIterator
           b (i.morphologys ().begin ()), e (i.morphologys ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "morphology: " << *b;
      }

      for (NeuroMLDocument::IonChannelConstIterator
           b (i.ionChannels ().begin ()), e (i.ionChannels ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "ionChannel: " << *b;
      }

      for (NeuroMLDocument::IonChannelHHConstIterator
           b (i.ionChannelHHs ().begin ()), e (i.ionChannelHHs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "ionChannelHH: " << *b;
      }

      for (NeuroMLDocument::DecayingPoolConcentrationModelConstIterator
           b (i.decayingPoolConcentrationModels ().begin ()), e (i.decayingPoolConcentrationModels ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "decayingPoolConcentrationModel: " << *b;
      }

      for (NeuroMLDocument::FixedFactorConcentrationModelConstIterator
           b (i.fixedFactorConcentrationModels ().begin ()), e (i.fixedFactorConcentrationModels ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "fixedFactorConcentrationModel: " << *b;
      }

      for (NeuroMLDocument::ExpOneSynapseConstIterator
           b (i.expOneSynapses ().begin ()), e (i.expOneSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "expOneSynapse: " << *b;
      }

      for (NeuroMLDocument::ExpTwoSynapseConstIterator
           b (i.expTwoSynapses ().begin ()), e (i.expTwoSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "expTwoSynapse: " << *b;
      }

      for (NeuroMLDocument::BlockingPlasticSynapseConstIterator
           b (i.blockingPlasticSynapses ().begin ()), e (i.blockingPlasticSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "blockingPlasticSynapse: " << *b;
      }

      for (NeuroMLDocument::BiophysicalPropertiesConstIterator
           b (i.biophysicalPropertiess ().begin ()), e (i.biophysicalPropertiess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "biophysicalProperties: " << *b;
      }

      for (NeuroMLDocument::CellConstIterator
           b (i.cells ().begin ()), e (i.cells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "cell: " << *b;
      }

      for (NeuroMLDocument::BaseCellConstIterator
           b (i.baseCells ().begin ()), e (i.baseCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "baseCell: " << *b;
      }

      for (NeuroMLDocument::IafTauCellConstIterator
           b (i.iafTauCells ().begin ()), e (i.iafTauCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "iafTauCell: " << *b;
      }

      for (NeuroMLDocument::IafTauRefCellConstIterator
           b (i.iafTauRefCells ().begin ()), e (i.iafTauRefCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "iafTauRefCell: " << *b;
      }

      for (NeuroMLDocument::IafCellConstIterator
           b (i.iafCells ().begin ()), e (i.iafCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "iafCell: " << *b;
      }

      for (NeuroMLDocument::IafRefCellConstIterator
           b (i.iafRefCells ().begin ()), e (i.iafRefCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "iafRefCell: " << *b;
      }

      for (NeuroMLDocument::IzhikevichCellConstIterator
           b (i.izhikevichCells ().begin ()), e (i.izhikevichCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "izhikevichCell: " << *b;
      }

      for (NeuroMLDocument::AdExIaFCellConstIterator
           b (i.adExIaFCells ().begin ()), e (i.adExIaFCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "adExIaFCell: " << *b;
      }

      for (NeuroMLDocument::FitzHughNagumoCellConstIterator
           b (i.fitzHughNagumoCells ().begin ()), e (i.fitzHughNagumoCells ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "fitzHughNagumoCell: " << *b;
      }

      for (NeuroMLDocument::PulseGeneratorConstIterator
           b (i.pulseGenerators ().begin ()), e (i.pulseGenerators ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "pulseGenerator: " << *b;
      }

      for (NeuroMLDocument::SineGeneratorConstIterator
           b (i.sineGenerators ().begin ()), e (i.sineGenerators ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "sineGenerator: " << *b;
      }

      for (NeuroMLDocument::RampGeneratorConstIterator
           b (i.rampGenerators ().begin ()), e (i.rampGenerators ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "rampGenerator: " << *b;
      }

      for (NeuroMLDocument::VoltageClampConstIterator
           b (i.voltageClamps ().begin ()), e (i.voltageClamps ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "voltageClamp: " << *b;
      }

      for (NeuroMLDocument::SpikeArrayConstIterator
           b (i.spikeArrays ().begin ()), e (i.spikeArrays ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spikeArray: " << *b;
      }

      for (NeuroMLDocument::SpikeGeneratorConstIterator
           b (i.spikeGenerators ().begin ()), e (i.spikeGenerators ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spikeGenerator: " << *b;
      }

      for (NeuroMLDocument::SpikeGeneratorRandomConstIterator
           b (i.spikeGeneratorRandoms ().begin ()), e (i.spikeGeneratorRandoms ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spikeGeneratorRandom: " << *b;
      }

      for (NeuroMLDocument::SpikeGeneratorPoissonConstIterator
           b (i.spikeGeneratorPoissons ().begin ()), e (i.spikeGeneratorPoissons ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spikeGeneratorPoisson: " << *b;
      }

      for (NeuroMLDocument::IF_curr_alphaConstIterator
           b (i.IF_curr_alphas ().begin ()), e (i.IF_curr_alphas ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "IF_curr_alpha: " << *b;
      }

      for (NeuroMLDocument::IF_curr_expConstIterator
           b (i.IF_curr_exps ().begin ()), e (i.IF_curr_exps ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "IF_curr_exp: " << *b;
      }

      for (NeuroMLDocument::IF_cond_alphaConstIterator
           b (i.IF_cond_alphas ().begin ()), e (i.IF_cond_alphas ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "IF_cond_alpha: " << *b;
      }

      for (NeuroMLDocument::IF_cond_expConstIterator
           b (i.IF_cond_exps ().begin ()), e (i.IF_cond_exps ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "IF_cond_exp: " << *b;
      }

      for (NeuroMLDocument::EIF_cond_exp_isfa_istaConstIterator
           b (i.EIF_cond_exp_isfa_istas ().begin ()), e (i.EIF_cond_exp_isfa_istas ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "EIF_cond_exp_isfa_ista: " << *b;
      }

      for (NeuroMLDocument::EIF_cond_alpha_isfa_istaConstIterator
           b (i.EIF_cond_alpha_isfa_istas ().begin ()), e (i.EIF_cond_alpha_isfa_istas ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "EIF_cond_alpha_isfa_ista: " << *b;
      }

      for (NeuroMLDocument::HH_cond_expConstIterator
           b (i.HH_cond_exps ().begin ()), e (i.HH_cond_exps ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "HH_cond_exp: " << *b;
      }

      for (NeuroMLDocument::ExpCondSynapseConstIterator
           b (i.expCondSynapses ().begin ()), e (i.expCondSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "expCondSynapse: " << *b;
      }

      for (NeuroMLDocument::AlphaCondSynapseConstIterator
           b (i.alphaCondSynapses ().begin ()), e (i.alphaCondSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "alphaCondSynapse: " << *b;
      }

      for (NeuroMLDocument::ExpCurrSynapseConstIterator
           b (i.expCurrSynapses ().begin ()), e (i.expCurrSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "expCurrSynapse: " << *b;
      }

      for (NeuroMLDocument::AlphaCurrSynapseConstIterator
           b (i.alphaCurrSynapses ().begin ()), e (i.alphaCurrSynapses ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "alphaCurrSynapse: " << *b;
      }

      for (NeuroMLDocument::SpikeSourcePoissonConstIterator
           b (i.SpikeSourcePoissons ().begin ()), e (i.SpikeSourcePoissons ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "SpikeSourcePoisson: " << *b;
      }

      for (NeuroMLDocument::NetworkConstIterator
           b (i.networks ().begin ()), e (i.networks ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "network: " << *b;
      }

      for (NeuroMLDocument::ComponentTypeConstIterator
           b (i.ComponentTypes ().begin ()), e (i.ComponentTypes ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "ComponentType: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IncludeType& i)
    {
      if (i.href ())
      {
        o << ::std::endl << "href: " << *i.href ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IonChannel& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      for (IonChannel::GateConstIterator
           b (i.gates ().begin ()), e (i.gates ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "gate: " << *b;
      }

      for (IonChannel::GateHHratesConstIterator
           b (i.gateHHratess ().begin ()), e (i.gateHHratess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "gateHHrates: " << *b;
      }

      for (IonChannel::GateHHratesTauConstIterator
           b (i.gateHHratesTaus ().begin ()), e (i.gateHHratesTaus ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "gateHHratesTau: " << *b;
      }

      for (IonChannel::GateHHtauInfConstIterator
           b (i.gateHHtauInfs ().begin ()), e (i.gateHHtauInfs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "gateHHtauInf: " << *b;
      }

      for (IonChannel::GateHHratesInfConstIterator
           b (i.gateHHratesInfs ().begin ()), e (i.gateHHratesInfs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "gateHHratesInf: " << *b;
      }

      for (IonChannel::GateHHratesTauInfConstIterator
           b (i.gateHHratesTauInfs ().begin ()), e (i.gateHHratesTauInfs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "gateHHratesTauInf: " << *b;
      }

      if (i.species ())
      {
        o << ::std::endl << "species: " << *i.species ();
      }

      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      if (i.conductance ())
      {
        o << ::std::endl << "conductance: " << *i.conductance ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IonChannelHH& i)
    {
      o << static_cast< const ::neurona::schema::IonChannel& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, ChannelTypes::Value i)
    {
      return o << ChannelTypes::_xsd_ChannelTypes_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelTypes& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, GateTypes::Value i)
    {
      return o << GateTypes::_xsd_GateTypes_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateTypes& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateHHUndetermined& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.q10Settings ())
      {
        o << ::std::endl << "q10Settings: " << *i.q10Settings ();
      }

      if (i.forwardRate ())
      {
        o << ::std::endl << "forwardRate: " << *i.forwardRate ();
      }

      if (i.reverseRate ())
      {
        o << ::std::endl << "reverseRate: " << *i.reverseRate ();
      }

      if (i.timeCourse ())
      {
        o << ::std::endl << "timeCourse: " << *i.timeCourse ();
      }

      if (i.steadyState ())
      {
        o << ::std::endl << "steadyState: " << *i.steadyState ();
      }

      o << ::std::endl << "instances: " << i.instances ();
      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateHHRates& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.q10Settings ())
      {
        o << ::std::endl << "q10Settings: " << *i.q10Settings ();
      }

      o << ::std::endl << "forwardRate: " << i.forwardRate ();
      o << ::std::endl << "reverseRate: " << i.reverseRate ();
      o << ::std::endl << "instances: " << i.instances ();
      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateHHTauInf& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.q10Settings ())
      {
        o << ::std::endl << "q10Settings: " << *i.q10Settings ();
      }

      o << ::std::endl << "timeCourse: " << i.timeCourse ();
      o << ::std::endl << "steadyState: " << i.steadyState ();
      o << ::std::endl << "instances: " << i.instances ();
      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateHHRatesTauInf& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.q10Settings ())
      {
        o << ::std::endl << "q10Settings: " << *i.q10Settings ();
      }

      o << ::std::endl << "forwardRate: " << i.forwardRate ();
      o << ::std::endl << "reverseRate: " << i.reverseRate ();
      o << ::std::endl << "timeCourse: " << i.timeCourse ();
      o << ::std::endl << "steadyState: " << i.steadyState ();
      o << ::std::endl << "instances: " << i.instances ();
      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateHHRatesTau& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.q10Settings ())
      {
        o << ::std::endl << "q10Settings: " << *i.q10Settings ();
      }

      o << ::std::endl << "forwardRate: " << i.forwardRate ();
      o << ::std::endl << "reverseRate: " << i.reverseRate ();
      o << ::std::endl << "timeCourse: " << i.timeCourse ();
      o << ::std::endl << "instances: " << i.instances ();
      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GateHHRatesInf& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.q10Settings ())
      {
        o << ::std::endl << "q10Settings: " << *i.q10Settings ();
      }

      o << ::std::endl << "forwardRate: " << i.forwardRate ();
      o << ::std::endl << "reverseRate: " << i.reverseRate ();
      o << ::std::endl << "steadyState: " << i.steadyState ();
      o << ::std::endl << "instances: " << i.instances ();
      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Q10Settings& i)
    {
      o << ::std::endl << "type: " << i.type ();
      if (i.fixedQ10 ())
      {
        o << ::std::endl << "fixedQ10: " << *i.fixedQ10 ();
      }

      if (i.q10Factor ())
      {
        o << ::std::endl << "q10Factor: " << *i.q10Factor ();
      }

      if (i.experimentalTemp ())
      {
        o << ::std::endl << "experimentalTemp: " << *i.experimentalTemp ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const HHRate& i)
    {
      o << ::std::endl << "type: " << i.type ();
      if (i.rate ())
      {
        o << ::std::endl << "rate: " << *i.rate ();
      }

      if (i.midpoint ())
      {
        o << ::std::endl << "midpoint: " << *i.midpoint ();
      }

      if (i.scale ())
      {
        o << ::std::endl << "scale: " << *i.scale ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const HHVariable& i)
    {
      o << ::std::endl << "type: " << i.type ();
      if (i.rate ())
      {
        o << ::std::endl << "rate: " << *i.rate ();
      }

      if (i.midpoint ())
      {
        o << ::std::endl << "midpoint: " << *i.midpoint ();
      }

      if (i.scale ())
      {
        o << ::std::endl << "scale: " << *i.scale ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const HHTime& i)
    {
      o << ::std::endl << "type: " << i.type ();
      if (i.rate ())
      {
        o << ::std::endl << "rate: " << *i.rate ();
      }

      if (i.midpoint ())
      {
        o << ::std::endl << "midpoint: " << *i.midpoint ();
      }

      if (i.scale ())
      {
        o << ::std::endl << "scale: " << *i.scale ();
      }

      if (i.tau ())
      {
        o << ::std::endl << "tau: " << *i.tau ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const DecayingPoolConcentrationModel& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "ion: " << i.ion ();
      o << ::std::endl << "restingConc: " << i.restingConc ();
      o << ::std::endl << "decayConstant: " << i.decayConstant ();
      o << ::std::endl << "shellThickness: " << i.shellThickness ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const FixedFactorConcentrationModel& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "ion: " << i.ion ();
      o << ::std::endl << "restingConc: " << i.restingConc ();
      o << ::std::endl << "decayConstant: " << i.decayConstant ();
      o << ::std::endl << "rho: " << i.rho ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BaseSynapse& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BaseConductanceBasedSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BaseSynapse& > (i);

      o << ::std::endl << "gbase: " << i.gbase ();
      o << ::std::endl << "erev: " << i.erev ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExpOneSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BaseConductanceBasedSynapse& > (i);

      o << ::std::endl << "tauDecay: " << i.tauDecay ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExpTwoSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BaseConductanceBasedSynapse& > (i);

      o << ::std::endl << "tauDecay: " << i.tauDecay ();
      o << ::std::endl << "tauRise: " << i.tauRise ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BlockingPlasticSynapse& i)
    {
      o << static_cast< const ::neurona::schema::ExpTwoSynapse& > (i);

      if (i.plasticityMechanism ())
      {
        o << ::std::endl << "plasticityMechanism: " << *i.plasticityMechanism ();
      }

      if (i.blockMechanism ())
      {
        o << ::std::endl << "blockMechanism: " << *i.blockMechanism ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, BlockTypes::Value i)
    {
      return o << BlockTypes::_xsd_BlockTypes_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BlockTypes& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BlockMechanism& i)
    {
      o << ::std::endl << "type: " << i.type ();
      o << ::std::endl << "species: " << i.species ();
      o << ::std::endl << "blockConcentration: " << i.blockConcentration ();
      o << ::std::endl << "scalingConc: " << i.scalingConc ();
      o << ::std::endl << "scalingVolt: " << i.scalingVolt ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, PlasticityTypes::Value i)
    {
      return o << PlasticityTypes::_xsd_PlasticityTypes_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PlasticityTypes& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PlasticityMechanism& i)
    {
      o << ::std::endl << "type: " << i.type ();
      o << ::std::endl << "initReleaseProb: " << i.initReleaseProb ();
      o << ::std::endl << "tauRec: " << i.tauRec ();
      if (i.tauFac ())
      {
        o << ::std::endl << "tauFac: " << *i.tauFac ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BaseCell& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IafTauCell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      o << ::std::endl << "leakReversal: " << i.leakReversal ();
      o << ::std::endl << "thresh: " << i.thresh ();
      o << ::std::endl << "reset: " << i.reset ();
      o << ::std::endl << "tau: " << i.tau ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IafTauRefCell& i)
    {
      o << static_cast< const ::neurona::schema::IafTauCell& > (i);

      o << ::std::endl << "refract: " << i.refract ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IafCell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      o << ::std::endl << "leakReversal: " << i.leakReversal ();
      o << ::std::endl << "thresh: " << i.thresh ();
      o << ::std::endl << "reset: " << i.reset ();
      o << ::std::endl << "C: " << i.c ();
      o << ::std::endl << "leakConductance: " << i.leakConductance ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IafRefCell& i)
    {
      o << static_cast< const ::neurona::schema::IafCell& > (i);

      o << ::std::endl << "refract: " << i.refract ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IzhikevichCell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      o << ::std::endl << "v0: " << i.v0 ();
      o << ::std::endl << "thresh: " << i.thresh ();
      o << ::std::endl << "a: " << i.a ();
      o << ::std::endl << "b: " << i.b ();
      o << ::std::endl << "c: " << i.c ();
      o << ::std::endl << "d: " << i.d ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const AdExIaFCell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      o << ::std::endl << "C: " << i.c ();
      o << ::std::endl << "gL: " << i.gL ();
      o << ::std::endl << "EL: " << i.eL ();
      o << ::std::endl << "reset: " << i.reset ();
      o << ::std::endl << "VT: " << i.vT ();
      o << ::std::endl << "thresh: " << i.thresh ();
      o << ::std::endl << "delT: " << i.delT ();
      o << ::std::endl << "tauw: " << i.tauw ();
      o << ::std::endl << "refract: " << i.refract ();
      o << ::std::endl << "a: " << i.a ();
      o << ::std::endl << "b: " << i.b ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const FitzHughNagumoCell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      o << ::std::endl << "I: " << i.i ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Cell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      if (i.morphology ())
      {
        o << ::std::endl << "morphology: " << *i.morphology ();
      }

      if (i.biophysicalProperties ())
      {
        o << ::std::endl << "biophysicalProperties: " << *i.biophysicalProperties ();
      }

      o << ::std::endl << "morphology: " << i.morphology1 ();
      o << ::std::endl << "biophysicalProperties: " << i.biophysicalProperties1 ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Morphology& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      for (Morphology::SegmentConstIterator
           b (i.segments ().begin ()), e (i.segments ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "segment: " << *b;
      }

      for (Morphology::SegmentGroupConstIterator
           b (i.segmentGroups ().begin ()), e (i.segmentGroups ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "segmentGroup: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Segment& i)
    {
      o << static_cast< const ::neurona::schema::BaseWithoutId& > (i);

      if (i.parent ())
      {
        o << ::std::endl << "parent: " << *i.parent ();
      }

      if (i.proximal ())
      {
        o << ::std::endl << "proximal: " << *i.proximal ();
      }

      o << ::std::endl << "distal: " << i.distal ();
      o << ::std::endl << "id: " << i.id ();
      if (i.name ())
      {
        o << ::std::endl << "name: " << *i.name ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SegmentParent& i)
    {
      o << ::std::endl << "segment: " << i.segment ();
      o << ::std::endl << "fractionAlong: " << i.fractionAlong ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Point3DWithDiam& i)
    {
      o << ::std::endl << "x: " << i.x ();
      o << ::std::endl << "y: " << i.y ();
      o << ::std::endl << "z: " << i.z ();
      o << ::std::endl << "diameter: " << i.diameter ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SegmentGroup& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.notes ())
      {
        o << ::std::endl << "notes: " << *i.notes ();
      }

      if (i.annotation ())
      {
        o << ::std::endl << "annotation: " << *i.annotation ();
      }

      for (SegmentGroup::MemberConstIterator
           b (i.members ().begin ()), e (i.members ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "member: " << *b;
      }

      for (SegmentGroup::IncludeConstIterator
           b (i.includes ().begin ()), e (i.includes ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "include: " << *b;
      }

      for (SegmentGroup::PathConstIterator
           b (i.paths ().begin ()), e (i.paths ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "path: " << *b;
      }

      for (SegmentGroup::SubTreeConstIterator
           b (i.subTrees ().begin ()), e (i.subTrees ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "subTree: " << *b;
      }

      for (SegmentGroup::InhomogeneousParameterConstIterator
           b (i.inhomogeneousParameters ().begin ()), e (i.inhomogeneousParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "inhomogeneousParameter: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const InhomogeneousParameter& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.proximal ())
      {
        o << ::std::endl << "proximal: " << *i.proximal ();
      }

      if (i.distal ())
      {
        o << ::std::endl << "distal: " << *i.distal ();
      }

      o << ::std::endl << "variable: " << i.variable ();
      o << ::std::endl << "metric: " << i.metric ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, Metric::Value i)
    {
      return o << Metric::_xsd_Metric_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Metric& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ProximalDetails& i)
    {
      o << ::std::endl << "translationStart: " << i.translationStart ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const DistalDetails& i)
    {
      o << ::std::endl << "normalizationEnd: " << i.normalizationEnd ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Member& i)
    {
      o << ::std::endl << "segment: " << i.segment ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Include& i)
    {
      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Path& i)
    {
      if (i.from ())
      {
        o << ::std::endl << "from: " << *i.from ();
      }

      if (i.to ())
      {
        o << ::std::endl << "to: " << *i.to ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SubTree& i)
    {
      if (i.from ())
      {
        o << ::std::endl << "from: " << *i.from ();
      }

      if (i.to ())
      {
        o << ::std::endl << "to: " << *i.to ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SegmentEndPoint& i)
    {
      o << ::std::endl << "segment: " << i.segment ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BiophysicalProperties& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "membraneProperties: " << i.membraneProperties ();
      if (i.intracellularProperties ())
      {
        o << ::std::endl << "intracellularProperties: " << *i.intracellularProperties ();
      }

      if (i.extracellularProperties ())
      {
        o << ::std::endl << "extracellularProperties: " << *i.extracellularProperties ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const MembraneProperties& i)
    {
      for (MembraneProperties::ChannelPopulationConstIterator
           b (i.channelPopulations ().begin ()), e (i.channelPopulations ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "channelPopulation: " << *b;
      }

      for (MembraneProperties::ChannelDensityConstIterator
           b (i.channelDensitys ().begin ()), e (i.channelDensitys ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "channelDensity: " << *b;
      }

      for (MembraneProperties::ChannelDensityNernstConstIterator
           b (i.channelDensityNernsts ().begin ()), e (i.channelDensityNernsts ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "channelDensityNernst: " << *b;
      }

      for (MembraneProperties::ChannelDensityGHKConstIterator
           b (i.channelDensityGHKs ().begin ()), e (i.channelDensityGHKs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "channelDensityGHK: " << *b;
      }

      for (MembraneProperties::ChannelDensityNonUniformConstIterator
           b (i.channelDensityNonUniforms ().begin ()), e (i.channelDensityNonUniforms ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "channelDensityNonUniform: " << *b;
      }

      for (MembraneProperties::ChannelDensityNonUniformNernstConstIterator
           b (i.channelDensityNonUniformNernsts ().begin ()), e (i.channelDensityNonUniformNernsts ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "channelDensityNonUniformNernst: " << *b;
      }

      for (MembraneProperties::SpikeThreshConstIterator
           b (i.spikeThreshs ().begin ()), e (i.spikeThreshs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spikeThresh: " << *b;
      }

      for (MembraneProperties::SpecificCapacitanceConstIterator
           b (i.specificCapacitances ().begin ()), e (i.specificCapacitances ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "specificCapacitance: " << *b;
      }

      for (MembraneProperties::InitMembPotentialConstIterator
           b (i.initMembPotentials ().begin ()), e (i.initMembPotentials ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "initMembPotential: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ValueAcrossSegOrSegGroup& i)
    {
      if (i.value ())
      {
        o << ::std::endl << "value: " << *i.value ();
      }

      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      if (i.segment ())
      {
        o << ::std::endl << "segment: " << *i.segment ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpikeThresh& i)
    {
      o << static_cast< const ::neurona::schema::ValueAcrossSegOrSegGroup& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpecificCapacitance& i)
    {
      o << static_cast< const ::neurona::schema::ValueAcrossSegOrSegGroup& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const InitMembPotential& i)
    {
      o << static_cast< const ::neurona::schema::ValueAcrossSegOrSegGroup& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Resistivity& i)
    {
      o << static_cast< const ::neurona::schema::ValueAcrossSegOrSegGroup& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelPopulation& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ChannelPopulation::VariableParameterConstIterator
           b (i.variableParameters ().begin ()), e (i.variableParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "variableParameter: " << *b;
      }

      o << ::std::endl << "ionChannel: " << i.ionChannel ();
      o << ::std::endl << "number: " << i.number ();
      o << ::std::endl << "erev: " << i.erev ();
      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      if (i.segment ())
      {
        o << ::std::endl << "segment: " << *i.segment ();
      }

      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelDensityNonUniform& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ChannelDensityNonUniform::VariableParameterConstIterator
           b (i.variableParameters ().begin ()), e (i.variableParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "variableParameter: " << *b;
      }

      o << ::std::endl << "ionChannel: " << i.ionChannel ();
      o << ::std::endl << "erev: " << i.erev ();
      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelDensityNonUniformNernst& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ChannelDensityNonUniformNernst::VariableParameterConstIterator
           b (i.variableParameters ().begin ()), e (i.variableParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "variableParameter: " << *b;
      }

      o << ::std::endl << "ionChannel: " << i.ionChannel ();
      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelDensity& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ChannelDensity::VariableParameterConstIterator
           b (i.variableParameters ().begin ()), e (i.variableParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "variableParameter: " << *b;
      }

      o << ::std::endl << "ionChannel: " << i.ionChannel ();
      if (i.condDensity ())
      {
        o << ::std::endl << "condDensity: " << *i.condDensity ();
      }

      o << ::std::endl << "erev: " << i.erev ();
      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      if (i.segment ())
      {
        o << ::std::endl << "segment: " << *i.segment ();
      }

      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelDensityNernst& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ChannelDensityNernst::VariableParameterConstIterator
           b (i.variableParameters ().begin ()), e (i.variableParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "variableParameter: " << *b;
      }

      o << ::std::endl << "ionChannel: " << i.ionChannel ();
      if (i.condDensity ())
      {
        o << ::std::endl << "condDensity: " << *i.condDensity ();
      }

      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      if (i.segment ())
      {
        o << ::std::endl << "segment: " << *i.segment ();
      }

      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ChannelDensityGHK& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ChannelDensityGHK::VariableParameterConstIterator
           b (i.variableParameters ().begin ()), e (i.variableParameters ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "variableParameter: " << *b;
      }

      o << ::std::endl << "ionChannel: " << i.ionChannel ();
      o << ::std::endl << "permeability: " << i.permeability ();
      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      if (i.segment ())
      {
        o << ::std::endl << "segment: " << *i.segment ();
      }

      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const VariableParameter& i)
    {
      if (i.inhomogeneousValue ())
      {
        o << ::std::endl << "inhomogeneousValue: " << *i.inhomogeneousValue ();
      }

      o << ::std::endl << "parameter: " << i.parameter ();
      o << ::std::endl << "segmentGroup: " << i.segmentGroup ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const InhomogeneousValue& i)
    {
      o << ::std::endl << "inhomogeneousParameter: " << i.inhomogeneousParameter ();
      o << ::std::endl << "value: " << i.value ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Species& i)
    {
      o << static_cast< const ::neurona::schema::ValueAcrossSegOrSegGroup& > (i);

      o << ::std::endl << "id: " << i.id ();
      o << ::std::endl << "concentrationModel: " << i.concentrationModel ();
      if (i.ion ())
      {
        o << ::std::endl << "ion: " << *i.ion ();
      }

      o << ::std::endl << "initialConcentration: " << i.initialConcentration ();
      o << ::std::endl << "initialExtConcentration: " << i.initialExtConcentration ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ConcentrationModel_D& i)
    {
      o << static_cast< const ::neurona::schema::DecayingPoolConcentrationModel& > (i);

      o << ::std::endl << "type: " << i.type ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IntracellularProperties& i)
    {
      for (IntracellularProperties::SpeciesConstIterator
           b (i.speciess ().begin ()), e (i.speciess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "species: " << *b;
      }

      for (IntracellularProperties::ResistivityConstIterator
           b (i.resistivitys ().begin ()), e (i.resistivitys ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "resistivity: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExtracellularProperties& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (ExtracellularProperties::SpeciesConstIterator
           b (i.speciess ().begin ()), e (i.speciess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "species: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExtracellularPropertiesLocal& i)
    {
      for (ExtracellularPropertiesLocal::SpeciesConstIterator
           b (i.speciess ().begin ()), e (i.speciess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "species: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ReactionScheme& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      o << ::std::endl << "source: " << i.source ();
      o << ::std::endl << "type: " << i.type ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PulseGenerator& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "delay: " << i.delay ();
      o << ::std::endl << "duration: " << i.duration ();
      o << ::std::endl << "amplitude: " << i.amplitude ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SineGenerator& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "delay: " << i.delay ();
      o << ::std::endl << "phase: " << i.phase ();
      o << ::std::endl << "duration: " << i.duration ();
      o << ::std::endl << "amplitude: " << i.amplitude ();
      o << ::std::endl << "period: " << i.period ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const RampGenerator& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "delay: " << i.delay ();
      o << ::std::endl << "duration: " << i.duration ();
      o << ::std::endl << "startAmplitude: " << i.startAmplitude ();
      o << ::std::endl << "finishAmplitude: " << i.finishAmplitude ();
      o << ::std::endl << "baselineAmplitude: " << i.baselineAmplitude ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const VoltageClamp& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "delay: " << i.delay ();
      o << ::std::endl << "duration: " << i.duration ();
      o << ::std::endl << "targetVoltage: " << i.targetVoltage ();
      o << ::std::endl << "simpleSeriesResistance: " << i.simpleSeriesResistance ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Spike& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "time: " << i.time ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpikeArray& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      for (SpikeArray::SpikeConstIterator
           b (i.spikes ().begin ()), e (i.spikes ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "spike: " << *b;
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpikeGenerator& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "period: " << i.period ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpikeGeneratorRandom& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "maxISI: " << i.maxISI ();
      o << ::std::endl << "minISI: " << i.minISI ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpikeGeneratorPoisson& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "averageRate: " << i.averageRate ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Network& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      for (Network::SpaceConstIterator
           b (i.spaces ().begin ()), e (i.spaces ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "space: " << *b;
      }

      for (Network::RegionConstIterator
           b (i.regions ().begin ()), e (i.regions ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "region: " << *b;
      }

      for (Network::ExtracellularPropertiesConstIterator
           b (i.extracellularPropertiess ().begin ()), e (i.extracellularPropertiess ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "extracellularProperties: " << *b;
      }

      for (Network::PopulationConstIterator
           b (i.populations ().begin ()), e (i.populations ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "population: " << *b;
      }

      for (Network::CellSetConstIterator
           b (i.cellSets ().begin ()), e (i.cellSets ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "cellSet: " << *b;
      }

      for (Network::SynapticConnectionConstIterator
           b (i.synapticConnections ().begin ()), e (i.synapticConnections ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "synapticConnection: " << *b;
      }

      for (Network::ProjectionConstIterator
           b (i.projections ().begin ()), e (i.projections ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "projection: " << *b;
      }

      for (Network::ExplicitInputConstIterator
           b (i.explicitInputs ().begin ()), e (i.explicitInputs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "explicitInput: " << *b;
      }

      for (Network::InputListConstIterator
           b (i.inputLists ().begin ()), e (i.inputLists ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "inputList: " << *b;
      }

      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      if (i.temperature ())
      {
        o << ::std::endl << "temperature: " << *i.temperature ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, NetworkTypes::Value i)
    {
      return o << NetworkTypes::_xsd_NetworkTypes_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const NetworkTypes& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Space& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.structure ())
      {
        o << ::std::endl << "structure: " << *i.structure ();
      }

      if (i.basedOn ())
      {
        o << ::std::endl << "basedOn: " << *i.basedOn ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpaceStructure& i)
    {
      if (i.xSpacing ())
      {
        o << ::std::endl << "xSpacing: " << *i.xSpacing ();
      }

      if (i.ySpacing ())
      {
        o << ::std::endl << "ySpacing: " << *i.ySpacing ();
      }

      if (i.zSpacing ())
      {
        o << ::std::endl << "zSpacing: " << *i.zSpacing ();
      }

      o << ::std::endl << "xStart: " << i.xStart ();
      o << ::std::endl << "yStart: " << i.yStart ();
      o << ::std::endl << "zStart: " << i.zStart ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, AllowedSpaces::Value i)
    {
      return o << AllowedSpaces::_xsd_AllowedSpaces_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const AllowedSpaces& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Region& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      if (i.space ())
      {
        o << ::std::endl << "space: " << *i.space ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Population& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      if (i.layout ())
      {
        o << ::std::endl << "layout: " << *i.layout ();
      }

      for (Population::InstanceConstIterator
           b (i.instances ().begin ()), e (i.instances ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "instance: " << *b;
      }

      if (i.cell ())
      {
        o << ::std::endl << "cell: " << *i.cell ();
      }

      if (i.network ())
      {
        o << ::std::endl << "network: " << *i.network ();
      }

      if (i.component ())
      {
        o << ::std::endl << "component: " << *i.component ();
      }

      if (i.size ())
      {
        o << ::std::endl << "size: " << *i.size ();
      }

      if (i.type ())
      {
        o << ::std::endl << "type: " << *i.type ();
      }

      if (i.extracellularProperties ())
      {
        o << ::std::endl << "extracellularProperties: " << *i.extracellularProperties ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, PopulationTypes::Value i)
    {
      return o << PopulationTypes::_xsd_PopulationTypes_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PopulationTypes& i)
    {
      return o << static_cast< const ::xml_schema::String& > (i);
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Layout& i)
    {
      if (i.random ())
      {
        o << ::std::endl << "random: " << *i.random ();
      }

      if (i.grid ())
      {
        o << ::std::endl << "grid: " << *i.grid ();
      }

      if (i.unstructured ())
      {
        o << ::std::endl << "unstructured: " << *i.unstructured ();
      }

      if (i.space ())
      {
        o << ::std::endl << "space: " << *i.space ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const UnstructuredLayout& i)
    {
      if (i.number ())
      {
        o << ::std::endl << "number: " << *i.number ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const RandomLayout& i)
    {
      if (i.number ())
      {
        o << ::std::endl << "number: " << *i.number ();
      }

      if (i.region ())
      {
        o << ::std::endl << "region: " << *i.region ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const GridLayout& i)
    {
      if (i.xSize ())
      {
        o << ::std::endl << "xSize: " << *i.xSize ();
      }

      if (i.ySize ())
      {
        o << ::std::endl << "ySize: " << *i.ySize ();
      }

      if (i.zSize ())
      {
        o << ::std::endl << "zSize: " << *i.zSize ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Instance& i)
    {
      o << ::std::endl << "location: " << i.location ();
      if (i.id ())
      {
        o << ::std::endl << "id: " << *i.id ();
      }

      if (i.i ())
      {
        o << ::std::endl << "i: " << *i.i ();
      }

      if (i.j ())
      {
        o << ::std::endl << "j: " << *i.j ();
      }

      if (i.k ())
      {
        o << ::std::endl << "k: " << *i.k ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Location& i)
    {
      if (i.x ())
      {
        o << ::std::endl << "x: " << *i.x ();
      }

      if (i.y ())
      {
        o << ::std::endl << "y: " << *i.y ();
      }

      if (i.z ())
      {
        o << ::std::endl << "z: " << *i.z ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const CellSet& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      o << ::std::endl << "select: " << i.select ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SynapticConnection& i)
    {
      if (i.from ())
      {
        o << ::std::endl << "from: " << *i.from ();
      }

      if (i.to ())
      {
        o << ::std::endl << "to: " << *i.to ();
      }

      if (i.synapse ())
      {
        o << ::std::endl << "synapse: " << *i.synapse ();
      }

      if (i.destination ())
      {
        o << ::std::endl << "destination: " << *i.destination ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Projection& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (Projection::ConnectionConstIterator
           b (i.connections ().begin ()), e (i.connections ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "connection: " << *b;
      }

      if (i.presynapticPopulation ())
      {
        o << ::std::endl << "presynapticPopulation: " << *i.presynapticPopulation ();
      }

      if (i.postsynapticPopulation ())
      {
        o << ::std::endl << "postsynapticPopulation: " << *i.postsynapticPopulation ();
      }

      if (i.synapse ())
      {
        o << ::std::endl << "synapse: " << *i.synapse ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Connection& i)
    {
      if (i.id ())
      {
        o << ::std::endl << "id: " << *i.id ();
      }

      if (i.preCellId ())
      {
        o << ::std::endl << "preCellId: " << *i.preCellId ();
      }

      if (i.preSegmentId ())
      {
        o << ::std::endl << "preSegmentId: " << *i.preSegmentId ();
      }

      if (i.preFractionAlong ())
      {
        o << ::std::endl << "preFractionAlong: " << *i.preFractionAlong ();
      }

      if (i.postCellId ())
      {
        o << ::std::endl << "postCellId: " << *i.postCellId ();
      }

      if (i.postSegmentId ())
      {
        o << ::std::endl << "postSegmentId: " << *i.postSegmentId ();
      }

      if (i.postFractionAlong ())
      {
        o << ::std::endl << "postFractionAlong: " << *i.postFractionAlong ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExplicitInput& i)
    {
      if (i.target ())
      {
        o << ::std::endl << "target: " << *i.target ();
      }

      if (i.input ())
      {
        o << ::std::endl << "input: " << *i.input ();
      }

      if (i.destination ())
      {
        o << ::std::endl << "destination: " << *i.destination ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const InputList& i)
    {
      o << static_cast< const ::neurona::schema::Base& > (i);

      for (InputList::InputConstIterator
           b (i.inputs ().begin ()), e (i.inputs ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "input: " << *b;
      }

      if (i.population ())
      {
        o << ::std::endl << "population: " << *i.population ();
      }

      if (i.component ())
      {
        o << ::std::endl << "component: " << *i.component ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Input& i)
    {
      if (i.id ())
      {
        o << ::std::endl << "id: " << *i.id ();
      }

      if (i.target ())
      {
        o << ::std::endl << "target: " << *i.target ();
      }

      if (i.destination ())
      {
        o << ::std::endl << "destination: " << *i.destination ();
      }

      if (i.segmentId ())
      {
        o << ::std::endl << "segmentId: " << *i.segmentId ();
      }

      if (i.fractionAlong ())
      {
        o << ::std::endl << "fractionAlong: " << *i.fractionAlong ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BasePyNNCell& i)
    {
      o << static_cast< const ::neurona::schema::BaseCell& > (i);

      if (i.cm ())
      {
        o << ::std::endl << "cm: " << *i.cm ();
      }

      if (i.i_offset ())
      {
        o << ::std::endl << "i_offset: " << *i.i_offset ();
      }

      if (i.tau_syn_E ())
      {
        o << ::std::endl << "tau_syn_E: " << *i.tau_syn_E ();
      }

      if (i.tau_syn_I ())
      {
        o << ::std::endl << "tau_syn_I: " << *i.tau_syn_I ();
      }

      if (i.v_init ())
      {
        o << ::std::endl << "v_init: " << *i.v_init ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BasePyNNIaFCell& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNCell& > (i);

      if (i.tau_m ())
      {
        o << ::std::endl << "tau_m: " << *i.tau_m ();
      }

      if (i.tau_refrac ())
      {
        o << ::std::endl << "tau_refrac: " << *i.tau_refrac ();
      }

      if (i.v_reset ())
      {
        o << ::std::endl << "v_reset: " << *i.v_reset ();
      }

      if (i.v_rest ())
      {
        o << ::std::endl << "v_rest: " << *i.v_rest ();
      }

      if (i.v_thresh ())
      {
        o << ::std::endl << "v_thresh: " << *i.v_thresh ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BasePyNNIaFCondCell& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCell& > (i);

      if (i.e_rev_E ())
      {
        o << ::std::endl << "e_rev_E: " << *i.e_rev_E ();
      }

      if (i.e_rev_I ())
      {
        o << ::std::endl << "e_rev_I: " << *i.e_rev_I ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IF_curr_alpha& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCell& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IF_curr_exp& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCell& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IF_cond_alpha& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCondCell& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const IF_cond_exp& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCondCell& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const EIF_cond_exp_isfa_ista& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCondCell& > (i);

      if (i.a ())
      {
        o << ::std::endl << "a: " << *i.a ();
      }

      if (i.b ())
      {
        o << ::std::endl << "b: " << *i.b ();
      }

      if (i.delta_T ())
      {
        o << ::std::endl << "delta_T: " << *i.delta_T ();
      }

      if (i.tau_w ())
      {
        o << ::std::endl << "tau_w: " << *i.tau_w ();
      }

      if (i.v_spike ())
      {
        o << ::std::endl << "v_spike: " << *i.v_spike ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const EIF_cond_alpha_isfa_ista& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNIaFCondCell& > (i);

      if (i.a ())
      {
        o << ::std::endl << "a: " << *i.a ();
      }

      if (i.b ())
      {
        o << ::std::endl << "b: " << *i.b ();
      }

      if (i.delta_T ())
      {
        o << ::std::endl << "delta_T: " << *i.delta_T ();
      }

      if (i.tau_w ())
      {
        o << ::std::endl << "tau_w: " << *i.tau_w ();
      }

      if (i.v_spike ())
      {
        o << ::std::endl << "v_spike: " << *i.v_spike ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const HH_cond_exp& i)
    {
      o << static_cast< const ::neurona::schema::BasePyNNCell& > (i);

      if (i.v_offset ())
      {
        o << ::std::endl << "v_offset: " << *i.v_offset ();
      }

      if (i.e_rev_E ())
      {
        o << ::std::endl << "e_rev_E: " << *i.e_rev_E ();
      }

      if (i.e_rev_I ())
      {
        o << ::std::endl << "e_rev_I: " << *i.e_rev_I ();
      }

      if (i.e_rev_K ())
      {
        o << ::std::endl << "e_rev_K: " << *i.e_rev_K ();
      }

      if (i.e_rev_Na ())
      {
        o << ::std::endl << "e_rev_Na: " << *i.e_rev_Na ();
      }

      if (i.e_rev_leak ())
      {
        o << ::std::endl << "e_rev_leak: " << *i.e_rev_leak ();
      }

      if (i.g_leak ())
      {
        o << ::std::endl << "g_leak: " << *i.g_leak ();
      }

      if (i.gbar_K ())
      {
        o << ::std::endl << "gbar_K: " << *i.gbar_K ();
      }

      if (i.gbar_Na ())
      {
        o << ::std::endl << "gbar_Na: " << *i.gbar_Na ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const BasePynnSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BaseSynapse& > (i);

      if (i.tau_syn ())
      {
        o << ::std::endl << "tau_syn: " << *i.tau_syn ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExpCondSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BasePynnSynapse& > (i);

      if (i.e_rev ())
      {
        o << ::std::endl << "e_rev: " << *i.e_rev ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const AlphaCondSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BasePynnSynapse& > (i);

      if (i.e_rev ())
      {
        o << ::std::endl << "e_rev: " << *i.e_rev ();
      }

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const ExpCurrSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BasePynnSynapse& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const AlphaCurrSynapse& i)
    {
      o << static_cast< const ::neurona::schema::BasePynnSynapse& > (i);

      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const SpikeSourcePoisson& i)
    {
      o << static_cast< const ::neurona::schema::Standalone& > (i);

      o << ::std::endl << "start: " << i.start ();
      o << ::std::endl << "duration: " << i.duration ();
      o << ::std::endl << "rate: " << i.rate ();
      return o;
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace neurona
{
  namespace schema
  {
    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::std::string& u,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
        ::neurona::schema::neuroml (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::std::string& u,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
        ::neurona::schema::neuroml (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
        ::neurona::schema::neuroml (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::neurona::schema::neuroml (isrc, f, p);
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::neurona::schema::neuroml (isrc, h, f, p);
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::neurona::schema::neuroml (isrc, h, f, p);
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::neurona::schema::neuroml (isrc, f, p);
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::Flags::dont_initialize) == 0,
        (f & ::xml_schema::Flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::neurona::schema::neuroml (isrc, h, f, p);
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::neurona::schema::neuroml (isrc, h, f, p);
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xercesc::InputSource& i,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xsd::cxx::tree::error_handler< char > h;

      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

      return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
        ::neurona::schema::neuroml (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xercesc::InputSource& i,
             ::xml_schema::ErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
        ::neurona::schema::neuroml (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< char > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< char > ();

      return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
        ::neurona::schema::neuroml (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (const ::xercesc::DOMDocument& doc,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties& p)
    {
      if (f & ::xml_schema::Flags::keep_dom)
      {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > (
          ::neurona::schema::neuroml (
            std::move (d), f | ::xml_schema::Flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (n.name () == "neuroml" &&
          n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > r (
          ::xsd::cxx::tree::traits< ::neurona::schema::NeuroMLDocument, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "neuroml",
        "http://www.neuroml.org/schema/neuroml2");
    }

    ::std::unique_ptr< ::neurona::schema::NeuroMLDocument >
    neuroml (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::Flags f,
             const ::xml_schema::Properties&)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::Flags::keep_dom) &&
         !(f & ::xml_schema::Flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (e));

      if (f & ::xml_schema::Flags::keep_dom)
        doc.setUserData (::xml_schema::dom::treeNodeKey,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == "neuroml" &&
          n.namespace_ () == "http://www.neuroml.org/schema/neuroml2")
      {
        ::std::unique_ptr< ::neurona::schema::NeuroMLDocument > r (
          ::xsd::cxx::tree::traits< ::neurona::schema::NeuroMLDocument, char >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "neuroml",
        "http://www.neuroml.org/schema/neuroml2");
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

